<!doctype html>
<html><head><title>CS8001 - ODA Notes</title><meta charset="UTF-8"><link href="http://fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic|Roboto:400,700,700italic,400italic" rel="stylesheet" type="text/css"><style>/*

body {
    font-size: 15px;
    color: #333;
    background: white;
    padding: 60px 95px;
    max-width: 900px;
    margin: 0 auto;
    text-rendering: optimizeLegibility;
    font-feature-settings: "kern";
    font-kerning: normal;
    -moz-font-feature-settings: "kern";
    -webkit-font-feature-settings: "kern";
}

/* Headings */
h1,
h2,
h3,
h4,
h5,
h6,
th {
    font-family: Roboto, sans-serif;
    font-weight: 700;
    margin: 0;
    margin-top: 1.25em;
    margin-bottom: 0.75em;
}

h1 {
    font-size: 35px;
    line-height: 42px;
}

h1:first-child {
    margin-top: 0;
}

h2 {
    font-size: 22px;
    line-height: 22px;
}

h3 {
    font-size: 18px;
    line-height: 16px;
}

h4,
h5,
h6 {
    font-size: 15px;
    line-height: 14px;
}
h5 {
    font-style: italic;
}

h6 {
    font-weight: unset;
    text-decoration: underline;
}

.capitalize-h3 h3 {
    text-transform: uppercase;
}

/* Body text */
body,
p,
ul,
ol,
td {
    font-family: "Crimson Text", serif;
    font-size: 16px;
    line-height: 20px;
}

blockquote,
q {
    display: block;
    margin: 1em 0;
    font-style: italic;
}

blockquote a,
q a {
    text-decoration: underline;
}

blockquote {
    padding-left: 10px;
    border-left: 4px solid #a6a6a6;
}

q {
    color: #a6a6a6;
    line-height: 40px;
    font-size: 24px;
    text-align: center;
    quotes: none;
}

q a {
    color: #a6a6a6;
}

code,
pre {
    font-family: Consolas, "Liberation Mono", Menlo, "Courier Prime Web",
        Courier, monospace;
    background: #f2f2f2;
}

code {
    padding: 1px;
    margin: 0 -1px;
    border-radius: 3px;
}

pre {
    display: block;
    line-height: 20px;
    text-shadow: 0 1px white;
    padding: 5px 5px 5px 30px;
    white-space: nowrap;
    position: relative;
    margin: 1em 0;
}

pre:before {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 15px;
    border-left: solid 1px #dadada;
}

/* Text Alignment */
.line {
    margin-top: 0;
    margin-bottom: 0;
}

.align-center {
    text-align: center;
}

.align-right {
    text-align: end;
}

/* Lists */
div[data-section-style="5"],
div[data-section-style="6"],
div[data-section-style="7"] {
    margin: 12px 0;
}

ul {
    padding: 0 0 0 40px;
}

ul li {
    margin-bottom: 0.4em;
}

/* Bulleted list */
div[data-section-style="5"] ul {
    list-style-type: disc;
}
div[data-section-style="5"] ul ul {
    list-style-type: circle;
}
div[data-section-style="5"] ul ul ul {
    list-style-type: square;
}
div[data-section-style="5"] ul ul ul ul {
    list-style-type: disc;
}
div[data-section-style="5"] ul ul ul ul ul {
    list-style-type: circle;
}
div[data-section-style="5"] ul ul ul ul ul ul {
    list-style-type: square;
}

/* Numbered list */
div[data-section-style="6"] ul {
    list-style-type: decimal;
}
div[data-section-style="6"] ul ul {
    list-style-type: lower-alpha;
}
div[data-section-style="6"] ul ul ul {
    list-style-type: lower-roman;
}
div[data-section-style="6"] ul ul ul ul {
    list-style-type: decimal;
}
div[data-section-style="6"] ul ul ul ul ul {
    list-style-type: lower-alpha;
}
div[data-section-style="6"] ul ul ul ul ul ul {
    list-style-type: lower-roman;
}

/* Checklist */
div[data-section-style="7"] ul {
    list-style-type: none;
}

div[data-section-style="7"] ul li:before {
    content: "\2610";
    position: absolute;
    display: inline;
    margin-right: 1.2em;
    margin-left: -1.2em;
}

div[data-section-style="7"] ul li.checked {
    text-decoration: line-through;
}

div[data-section-style="7"] ul li.checked:before {
    content: "\2611";
    text-decoration: none;
}

/* Tables */
div[data-section-style="8"] {
    margin: 12px 0;
}

table {
    border-spacing: 0;
    border-collapse: separate;
    border: solid 1px #bbb;
    table-layout: fixed;
    position: relative;
}

table th,
table td {
    padding: 2px 2px 0;
    min-width: 1.5em;
    word-wrap: break-word;
}

table th {
    border-bottom: 1px solid #c7cbd1;
    background: #f2f2f2;
    font-weight: bold;
    vertical-align: bottom;
    color: #3a4449;
    text-align: center;
}

table td {
    padding-top: 0;
    border-left: 1px solid #c7cbd1;
    border-top: 1px solid #c7cbd1;
    vertical-align: top;
}

table td.bold {
    font-weight: bold;
}

table td.italic {
    font-style: italic;
}

table td.underline {
    text-decoration: underline;
}

table td.strikethrough {
    text-decoration: line-through;
}

table td.underline.strikethrough {
    text-decoration: underline line-through;
}

table td:first-child {
    border-left: hidden;
}

table tr:first-child td {
    border-top: hidden;
}

/* Images */
div[data-section-style="11"] {
    margin-top: 20px;
    margin-bottom: 20px;
    margin-left: auto;
    margin-right: auto;
}

div[data-section-style="11"][data-section-float="0"] {
    clear: both;
    text-align: center;
}

div[data-section-style="11"][data-section-float="1"] {
    float: left;
    clear: left;
    margin-right: 20px;
}

div[data-section-style="11"][data-section-float="2"] {
    float: right;
    clear: right;
    margin-left: 20px;
}

div[data-section-style="11"] img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: auto;
}

div[data-section-style="11"].show-border {
    outline: 1px solid rgba(0, 0, 0, 0.12);
    box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.05);
}

hr {
    width: 70px;
    margin: 20px auto;
}

/* Apps */
div[data-section-style="19"].placeholder {
    margin: 0.8em auto;
    padding: 4px 0;
    display: block;
    color: #3d87f5;
    text-align: center;
    border: 1px solid rgba(41, 182, 242, 0.2);
    border-radius: 3px;
    background: #e9f8fe;
    font-family: Roboto, sans-serif;
}

div[data-section-style="19"].first-party-element {
    margin-bottom: 10px;
    background-repeat: no-repeat;
    background-size: contain;
}

div[data-section-style="19"].first-party-element.kanban {
    background-image: url("https://quip-cdn.com/nK0hSyhsb4jrLIL2s5Ma-g");
    height: 166px;
}

div[data-section-style="19"].first-party-element.calendar {
    background-image: url("https://quip-cdn.com/OYujqLny03RILxcLIiyERg");
    height: 244px;
}

div[data-section-style="19"].first-party-element.poll {
    background-image: url("https://quip-cdn.com/fbIiFrcKGv__4NB7CBfxoA");
    height: 116px;
}

div[data-section-style="19"].first-party-element.countdown {
    background-image: url("https://quip-cdn.com/3bPhykD2dBei9sSjCWteTQ");
    height: 96px;
}

div[data-section-style="19"].first-party-element.process_bar {
    background-image: url("https://quip-cdn.com/ybQlHnHEIIBLog5rZmYs_w");
    height: 36px;
}

div[data-section-style="19"].first-party-element.project_tracker {
    background-image: url("https://quip-cdn.com/OFQU087b4Mxzz1ZaHwtjXA");
    height: 164px;
}

div[data-section-style="19"] img {
    margin: 0.5em;
}

div[data-section-style="19"] img.masked-image {
    margin: 0;
    transform-origin: top left;
}

div[data-section-style="19"] .image-mask {
    position: relative;
    overflow: hidden;
}
/*
 * Copyright 2019 Quip
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

body {
    counter-reset: indent0 indent1 indent2 indent3 indent4 indent5 indent6
        indent7 indent8;
}

/* Numbered list */
div[data-section-style="6"] {
    counter-reset: indent0 indent1 indent2 indent3 indent4 indent5 indent6
        indent7 indent8;
}
div[data-section-style="6"].list-numbering-continue {
    counter-reset: none;
}
div[data-section-style="6"].list-numbering-restart-at {
    counter-reset: indent0 var(--indent0) indent1 indent2 indent3 indent4
        indent5 indent6 indent7 indent8;
}
div[data-section-style="6"] ul {
    /* indent0 is not reset since it is shared across the div elements */
    list-style-type: none !important;
}
div[data-section-style="6"] ul ul {
    counter-reset: indent1;
}
div[data-section-style="6"] ul ul ul {
    counter-reset: indent2;
}
div[data-section-style="6"] ul ul ul ul {
    counter-reset: indent3;
}
div[data-section-style="6"] ul ul ul ul ul {
    counter-reset: indent4;
}
div[data-section-style="6"] ul ul ul ul ul ul {
    counter-reset: indent5;
}
div[data-section-style="6"] ul li {
    counter-increment: indent0;
}
div[data-section-style="6"] ul ul li {
    counter-increment: indent1;
}
div[data-section-style="6"] ul ul ul li {
    counter-increment: indent2;
}
div[data-section-style="6"] ul ul ul ul li {
    counter-increment: indent3;
}
div[data-section-style="6"] ul ul ul ul ul li {
    counter-increment: indent4;
}
div[data-section-style="6"] ul ul ul ul ul ul li {
    counter-increment: indent5;
}
div[data-section-style="6"] ul li:before {
    content: counter(indent0, decimal) ". ";
}
div[data-section-style="6"] ul ul li:before {
    content: counter(indent1, lower-alpha) ". ";
}
div[data-section-style="6"] ul ul ul li:before {
    content: counter(indent2, lower-roman) ". ";
}
div[data-section-style="6"] ul ul ul ul li:before {
    content: counter(indent3, decimal) ". ";
}
div[data-section-style="6"] ul ul ul ul ul li:before {
    content: counter(indent4, lower-alpha) ". ";
}
div[data-section-style="6"] ul ul ul ul ul ul li:before {
    content: counter(indent5, lower-roman) ". ";
}
</style></head><body><h1 id='temp:C:VbX43672a3d9b3d4041a1afbb103'>CS8001 - ODA Notes</h1>

Problem Sets - what to expect<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX6ae5972ab6c346deafe4b2a05'><li id='temp:C:VbXa5df1947e08d489aa21488879' class='' value='1'>The questions will be quite similar to the reality checks being made up primarily of multiple choice and code snippets.

<br/></li><li id='temp:C:VbX98993267a53044729212e8e23' class=''>There's a good bit of questions ranging between 1 to 2 dozen questions.

<br/></li><li id='temp:C:VbX76e7fefa59ee470184fe8d75b' class=''>The questions will show whether they are correct or incorrect

<br/></li></ul></div><br/>

<h2 id='temp:C:VbX8e47116941a941ac907862637'>Table of Contents</h2>

<div class="" data-section-style='6' style="">
<ul id='temp:C:VbXcc4dadf26bd44812abacc726d'>
    <li id='temp:C:VbX953314a3b068483c9d0bbfa8d' class='' value='1'>
        <a href="#temp:C:VbX42566e50ac43425f8371f7777">M3 - Stacks/Queue ADTs</a>
        <br/>
    </li>
    <li id='temp:C:VbX9589f0f91b9c442d9485f2366' class=''>
        <a href="#temp:C:VbX0bbbfe0ebcd34cf4b01c980f6">M4 - BST Introduction</a>
        <br/>
    </li>
    <li id='temp:C:VbX4c3e2c7f459a44f1a32e9f289' class=''>
        <a href="#temp:C:VbX4bf0e8fbc89e4a7d988322334">M5 - BST Operations</a>
        <br/>
    </li>
    <li id='temp:C:VbXbb9c54a3768c4b5fa2934ff06' class=''>
        <a href="#temp:C:VbX96c08b7462934804b7a95934b">M6 - Heaps</a>
        <br/>
    </li>
    <li id='temp:C:VbX0977857a3fc542628a7e9a8d3' class=''>
        <a href="#temp:C:VbX24d3e95ac4cc41378c6de0c34">M7 - Hashmaps</a>
        <br/>
    </li>
    <li id='temp:C:VbX9f5ff7264e624a93815e3de72' class=''>
        <a href="#temp:C:VbXfb368b002a514314989b2235c">M8 - AVLs</a>
        <br/>
    </li>
    <li id='temp:C:VbXe4e503dedc334c04bbfab9235' class=''>
        <a href="#temp:C:VbX2a2d2e91c25d44adb2ac7d37c">M99 - SkipLists</a>
        <br/>
    </li>
    <li id='temp:C:VbX1337221d7099469b82c71d1b5' class=''>
        <a href="#temp:C:VbX7c7da7b24cf54f12baa818bef">M9 - (2-4) Trees</a>
        <br/>
    </li>
    <li id='temp:C:VbX5b3a307754b7429a93970b93c' class=''>
        <a href="#temp:C:VbX385e433045a8438794984cecb">Module 10 - Sorting</a>
        <br/>
    </li>
    <li id='temp:C:VbX2ddad70bb0824da884cbee5a5' class=''>
        <a href="#temp:C:VbX42e6cde3f09343a2a3395cca0">Module 11 - Divide and Conquer Sorts</a>
        <br/>
    </li>
    <li id='temp:C:VbX262ab5be0e0c49e5b1e29177e' class=''>
        <a href="#temp:C:VbX264de70eeee54798b52e7b920">Module 12 - Pattern Matching Algorithms</a>
        <br/>
    </li>
    <li id='temp:C:VbX111d89c6d2b14f8a82bd17bf5' class=''>
        <a href="#temp:C:VbX59841bad0ff64dcfa7abd7d09">M13 Graph Algorithms</a>
        <br/>
    </li>
    <li id='temp:C:VbX8acf9479d6de4245854f1f5d1' class=''>
        <a href="#temp:C:VbX4c04f4fbb2464e3eb2e09ec91">M14 - Dijkstra's Shortest Path</a>
        <br/>
    </li>
    <li id='temp:C:VbX2e6c478c904246b986220a6c9' class=''>
        <a href="#temp:C:VbX2e0b31296ce94bda96b567293">M15 Minimum Spanning Trees (MSTs)</a>
        <br/>
    </li>
    <li id='temp:C:VbXe65cb8e16c8a46d6b5c06caca' class=''>
        <a href="#temp:C:VbXe1f02679539b4a7e94413ae6f">M16 - Dynamic Programming</a>
        <br/>
    </li>
</ul>
</div>

<br/></li></ul></div><h1 id='temp:C:VbX42566e50ac43425f8371f7777'>M3 - Stacks/Queue ADTs</h1>

<h2 id='temp:C:VbX23fae3aee6d94487ad3c0b6cb'>Priority Queues</h2>

We will very briefly discuss a tangentially related concept to Queues, called the <b>Priority Queue</b>. The topic is placed here to help broaden you awareness of the ideas that can emerge from the topic. This is an important growth mindset technique to think about data structures and behavior in order to create different structures. We will not be discussing the typical implementation of them until later in Module 6<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/etnE09dKlMlV93fTRLox9g?a=J80yMXPFXKZna51NkJNXaVa6Fn2GSbaMODXfsl2OMUoa' id='temp:C:VbXd7ae2b9a18e14f93be4d0b4bc' width='800' height='356' alt="Screen Shot 2024-05-29 at 11.28.11 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/yaTmmjKMOWBp5RVpF7dnZA?a=hywWjDqDWarzPQHXOCMJaoQZ1qYJ76W9A7IapwqvXFga' id='temp:C:VbX980da3feb2154d10a79e04c44' width='800' height='308' alt="Screen Shot 2024-05-29 at 11.29.05 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/g-dDRTN98dhwqy6A894XIg?a=i2Gr9RNa8386q6SKECbe0Qv2cUzLKYyEQFji0VdZQqIa' id='temp:C:VbX8109d3d5af5e457ba3521fa76' width='800' height='356' alt="Screen Shot 2024-05-29 at 11.29.16 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Vib1Hgn4MrNL_iY2Aj8ckw?a=FvMra4PX8oNkYQVVVa3w6y7E5WjI3vnhpiyXJPmu8aca' id='temp:C:VbX4677876dbc974917b2675b04b' width='800' height='363' alt="Screen Shot 2024-05-29 at 11.29.46 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/pW0hP8kn7httoLwbQBhx2Q?a=9RiXfnMKHaPavSydV3yHaviYtapE9tIm4tWI9bVNb0Ma' id='temp:C:VbX348daa0c7a884dfbae95d08eb' width='800' height='339' alt="Screen Shot 2024-05-29 at 11.30.12 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/MNy_EWr6_BliAulbkmlFTA?a=rQTe90RqB80LHUOwSCYFcMjXTd8nWh0RAx2amCUu0H4a' id='temp:C:VbX0a4d072d3b3846c6bac1bc8cc' width='800' height='326' alt="Screen Shot 2024-05-29 at 11.30.57 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5DECZnWmEdWS8kRU4YHPiA?a=eRbAtN7WbrwIlF8ylLoW949fDcvsBMZ3vJWXSBWcN7Aa' id='temp:C:VbXedeb7c0d35654c2ba63c8f656' width='800' height='395' alt="Screen Shot 2024-05-29 at 11.31.29 PM.png"></img></div><h3 id='temp:C:VbX8625a159bf154b14bf477e0cb'><b>Priority Queues: A Linear Model?</b></h3>

In the video, we briefly mentioned that Priority Queues are a linear ADT. This is partially true since we can think of the data being placed linearly in sorted order based on priority. For queues, this was precisely the case, except that the priority was the order in which data was enqueued. However, in practice, a linear model doesn't work very well for implementing Priority Queues. Let's consider the idea of implementing a Priority Queue by maintaining a sorted list. We have two options to consider, an array-backed sorted list or a linked sorted list.<br/>

<br/>

For the array-backed version, it would similar to an ArrayQueue where the element with the highest priority could be at the front, while the element with lowest priority could be at the back. With this model, dequeuing and peeking would be 𝑂(1) operations like in the ArrayQueue. However, in general, enqueuing would be an 𝑂(𝑛) procedure, even if we consider amortizing the resize cost. This is because if we wanted to enqueue, we'd need to maintain the sorted order of the data, so we'd need to shift data around to place it. There are other variations we could use such as flipping the priority order and keeping the data zero-aligned, but they all lead us to similar conclusions.<br/>

<br/>

For the linked version, it would again be similar to a LinkedQueue where the element with highest priority would be at the head while the element with lowest priority would be at the tail. Once again, peeking and dequeuing operations are 𝑂(1), but enqueuing would be an 𝑂(𝑛) operation since we need to find the location to insert the data.<br/>

<br/>

So, with our current range of ideas, it appears that implementing a Priority Queue efficiently is out of reach. We will begin developing the ideas that we do need starting with Module 6, in the near future!<br/>

<br/>

<h2 id='temp:C:VbXe8f75da1e27847dbbce83b572'>Deques (double-ended queue “deck”)</h2>

We end the section by discussing a natural extension of both Stacks and Queues, the <b>Deque ADT</b>. Rather than specializing in a specific add and remove behavior like Stacks and Queues, Deques support add and remove operations from either end of the data. The techniques involved in implementing the deque have already been discussed, so we will simply upcycle the ideas to show how it can be done.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BGyngEV6meBTDfCtQH9OKA?a=ay79rRn6vGDv4qKKCz0CbLQ5iMcSf5UJc53wXv8gHu4a' id='temp:C:VbX7552eaf282e24e98a6ef86057' alt="Screen Shot 2024-05-29 at 11.51.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/G1EbqqC9WkS7hFRWIvxEzw?a=QRdaYFz4OXjWVvntQLD5SCs8gqVdCBRJdTRk0FrsjJga' id='temp:C:VbX9c460b3b7f02434c80823ac5b' alt="Screen Shot 2024-05-29 at 11.51.59 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/lpg_FSw9ie0-o8F90JSaMQ?a=GUb63knjAlhiTmOtbXr5qWkSMU3H6yjlIB1oJq44DTMa' id='temp:C:VbX0964888548e34a388986bc3ee' alt="Screen Shot 2024-05-29 at 11.51.21 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dH9uDhKYhfmtBslB0JnLLQ?a=XMdRa8B0UGg51w5us6udeFCv73E55sDoSPjaHJ1XHn4a' id='temp:C:VbXe721b508db914619ac3c8f366' width='800' height='371' alt="Screen Shot 2024-05-29 at 11.52.21 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/hXaKxYkNQNr5nZupxXrLZA?a=4UiFw3kxGKeXI9aN721r3ldmk1bnyCRTnkFtD5GXYLoa' id='temp:C:VbX74aecfdb64c4446a8883feb6b' alt="Screen Shot 2024-05-29 at 11.52.32 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5JIMisRZgWTQWSicq03E9w?a=3sgBxkkJeABxzazMd2IyHOOGHqdBcQ7p7f08HR9vEfca' id='temp:C:VbX2e5de8086c884ddd95a161fe7' alt="Screen Shot 2024-05-29 at 11.53.20 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/tTaJIqLR0Wd4mrpD9uIOHg?a=xQGDs3acK3aVE40Er5kqrEkAwftH9Jc8BkoS308Lc4Ea' id='temp:C:VbXb223355d66e74357869fb0eaf' width='800' height='395' alt="Screen Shot 2024-05-29 at 11.54.26 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5fmEXfYcEFTeXheZyeP0mg?a=06eBkLj6MAWEFJaRN1SnwkGSMRanKCNGtnWpRfhE6DIa' id='temp:C:VbX460b7c46519c4e7899d0800a1' alt="Screen Shot 2024-05-29 at 11.55.14 PM.png"></img></div>Found in online purchasing system.<br/>

<h3 id='temp:C:VbXd45f2af87ff544a49a8ec6cc8'><b>Java's % Operator</b></h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/e-Ik3z9uW6Gm5egVgozkjA?a=xh4lDG1tVrIVa3kBavptwBrz5elnWSxg83DsJ8yaJloa' id='temp:C:VbXa2108fc6a5cc416cac2ffb4ad' width='787' height='642' alt="Screen Shot 2024-05-29 at 11.44.15 PM.png"></img></div><h3 id='temp:C:VbXcc6d04653ef5474796fd2ba64'>CSVIS</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/AWfxAEyZOKjIoe7PtKvPgg?a=vmSVLz6a3ac5ucjzhctfU9YJHbGvQOei6cs4qeXWCM8a' id='temp:C:VbX5b97a28bbff54fdd83c9a9d97' width='800' height='410' alt="Screen Shot 2024-05-29 at 11.56.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/C8HVPKjIYiR3O-iNEnGN6Q?a=6pia55jeakVjxLGETrkH9NjcBaSpmeW0LYjy4BLVDDwa' id='temp:C:VbX0dc0052c9afe4032bdb933f53' width='800' height='306' alt="Screen Shot 2024-05-30 at 12.04.14 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YDJlHkRZAvCVoB9xGNBPHQ?a=nEhO7QDxK9kzyfNQtNOaMj4BobxDDOLaPaWmHb5LDbga' id='temp:C:VbXdd144f06d1a44d7f9ae7a0eb2' alt="Screen Shot 2024-05-30 at 12.04.37 AM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/bI3cXDk8K9AFwlbmdy541A?a=8c64VseWzjNiaUbZMg1itdL8Tnnzaaed51Vym6PAO44a' id='temp:C:VbX91650d5bc87a41489daff23e3' width='800' height='316' alt="Screen Shot 2024-05-30 at 12.05.03 AM.png"></img></div><hr style='width:100%'><h1 id='temp:C:VbX0bbbfe0ebcd34cf4b01c980f6'>M4 - BST Introduction</h1>

<h2 id='temp:C:VbX1e5fe317db184042b3f191b00'>Introduction to Tree ADT</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX971403f27fa544eda494b1fd7'><li id='temp:C:VbX6864600f645d4be38e1427a88' class='' value='1'>Stacks, queues and deques are limited by their ADT operations (linear)

<br/></li><li id='temp:C:VbXb691e591cb7d4d799fd41df33' class=''>Trees are a type of linked lists

<br/></li><li id='temp:C:VbX314ce6eb7a39428893023b3be' class=''>Trees are typically not bidirectional

<br/></li><li id='temp:C:VbX5e69dbf6fddc45ada14cdc3fb' class=''>Node with children are internal nodes, nodes with no children are leaf nodes (or external nodes)

<br/></li><li id='temp:C:VbXddcb761239b843a5863f3432a' class=''>No concept of front and back since they aren’t linear

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/MuqdVztmINH2JToIFKQxGw?a=TgJlaxT97lue8DnGzGT30YSEA1WtJHXkYSfZb1LaSaAa' id='temp:C:VbX9027679b04084729a627dce32' width='800' height='370' alt="Screen Shot 2024-05-30 at 12.53.05 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HF65QN3jb8KsbPkBe1rVvg?a=DcJpCv0XPVGy4A1r3mP7ljO9MwA6pCXD9smZ6yrsoBQa' id='temp:C:VbX02e7ed19a3bb4be49d9b35035' width='800' height='345' alt="Screen Shot 2024-05-30 at 12.53.18 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SXwS2pFCNi_dwefuuB0BSQ?a=todRvua8FCmzYmCHOxc3wxMnWvPZRdTRbEDTaKk54aka' id='temp:C:VbX94a5b60ebc654712ad2e28004' width='800' height='370' alt="Screen Shot 2024-05-30 at 12.55.29 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/VjqwQzAV0o8Vs3Tv69R0zw?a=eDoaXnlo2peN3GAfo8ONmIBEnk0OdySTIBngOZFVZMga' id='temp:C:VbXd8dcea02e27d4ae19e1aab499' width='800' height='374' alt="Screen Shot 2024-05-30 at 12.57.38 AM.png"></img></div><h3 id='temp:C:VbX2970b4e7f81446e19825c01c3'><b>Was that an ADT?</b></h3>

In the first few modules, we made a large distinction between ADTs and data structures. To be clear, ADTs are high-level descriptions of a model, whereas a data structure is the low-level, detail-oriented implementation of a model. Up until now, the distinction was stark because there were multiple implementations for each ADT, and it served as a nice way of introducing the concepts.<br/>

<br/>

However, moving forward, we'll be much looser with that distinction. We do this for multiple reasons, however, the primary reason is that the distinction will more inhibit learning than helping it in the topics to come. Some of the upcoming topics can be difficult to grasp. We would prefer for you to focus on these topic complexities, rather than worry about the semantics of whether a Tree is an ADT or a data structure (it can be either depending on the language used). We will still distinguish between the ADTs in the diagrams shown in the module review sections, but they are not as important as they were in previous modules.<br/>

<br/>

<h2 id='temp:C:VbX2762d6e35a2d4219a811b1841'>Binary Trees</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX42448fdecf564f549e65c1e64'><li id='temp:C:VbX38bf1f3c001e4eccac5e2ec12' class='' value='1'>Each node has minimum 3 components, data and reference to its left / right children.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nFMi_SsbZiWSGGBgfd5RoQ?a=wG5LahlrMK0ve2AGa1wAedhi9QvDdkjmDQTYni7w6U0a' id='temp:C:VbX13ef27365ef046359615258a4' width='800' height='376' alt="Screen Shot 2024-05-30 at 1.00.14 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/kjLlT0lBGfuoMv6tx-TGyA?a=yaB2rdoWdMrAVyITPtIR9PKeZ7KrYgIAHJARIEBrtOsa' id='temp:C:VbXb4e1f7f37e124e0a82114f21a' width='800' height='247' alt="Screen Shot 2024-05-30 at 1.01.49 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Wu_pWrHLTSBc-sbhuoYrAA?a=TZpyzC7WlejrD8wjrd8qX4dBtDS9n6Pu8hPCpsZmWhYa' id='temp:C:VbX6a70cd46dd68472f852d4497a' width='800' height='346' alt="Screen Shot 2024-05-30 at 1.02.56 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dO1C6W5jyijq0jOiF_ScjA?a=EnaEO2ZRbIyF6hSG8HZw7fd4oNM8DMI0EGHy8eALRkYa' id='temp:C:VbX4f49fa867d1b482086112c3c2' width='800' height='155' alt="Screen Shot 2024-05-30 at 1.03.18 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FY5Lyoev2jRktc09VFPa9A?a=QL7y8aaxe4KnDEoTOwF0franbVc2W8UAK3luw9fvvVsa' id='temp:C:VbX4abb44a5f06a4be3ac0d289fa' width='800' height='284' alt="Screen Shot 2024-05-30 at 1.03.57 AM.png"></img></div><h2 id='temp:C:VbX6e98057fd25248a6ae5a598d5'>Binary Search Trees</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX452c89efa9884ed984eadcc93'><li id='temp:C:VbX96398619fce042ddaa7339449' class='' value='1'>Left node must be smaller than parent node, right node must be greater than parent node.

<br/></li><li id='temp:C:VbX35cdeafd5ac7482b8c0f4b525' class='parent'>Big-O: 

<br/></li><ul><li id='temp:C:VbXb569d248ebd9489485ac2472a' class=''>Average: BST divides data in half perfectly at each level.  Insertion + search + deletion are all <b>O(log n)</b>.

<br/></li><li id='temp:C:VbX8c1b2e2996b643d5939ba5bf4' class=''>Worst: If BST doesn’t divide the data in half (ie same as linked list).  In this case, i + s + d are O(n).

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/k4bdha7jVxsjPfe9WOTRjw?a=pWAaGfdiKkoEqaZNF1xuGUMQaF6qavTRBKknlpXcG04a' id='temp:C:VbX2397c55c55be460db308a535d' width='800' height='351' alt="Screen Shot 2024-05-30 at 1.05.56 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/UKwDbfaSCcYDz2POd9AgHQ?a=na2RcTI7goH2TnfDNl57DoFFF28NNUtaaoQGHK1BCCca' id='temp:C:VbXc56eb77cf9954ea6b3d210491' width='800' height='327' alt="Screen Shot 2024-05-30 at 1.07.24 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/h6rBGyIlWcskXu4_0__gRQ?a=baBQFhEINIAXM9gEdeADXtT53HToaaxnre1stmRxvPka' id='temp:C:VbX7d5879bca4494f32a337cf9c9' width='800' height='263' alt="Screen Shot 2024-05-30 at 1.07.47 AM.png"></img></div><h4 id='temp:C:VbX767c786c61f2467cb9046f3f9'>CSVIZ</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/D4E_oNX4YeMkD0XJJOvY7Q?a=k1xeMAadbynuFiRTo9cvt7ayJ6NHNVmqdIf9IxkO9PQa' id='temp:C:VbX035e13a4e4a9423fa749df62f' alt="Screen Shot 2024-05-30 at 1.11.28 AM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/XCDBNedLATYIjSGQ5yUdzg?a=5uoGWcPQSlRaM24uqB60tAZbez1AHNx94S3rlsCPaUQa' id='temp:C:VbX41db4df02e9343c0b427d2aa3' alt="Screen Shot 2024-05-30 at 1.12.14 AM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mSp9y38MwlBQl-TaVcIaFQ?a=gDNWU1V6Mhf4c0iJVmz8KmhaQvZhjxsWlc3Ajb5klusa' id='temp:C:VbX00680aa93ffd4f509b6b0d10a' alt="Screen Shot 2024-05-30 at 1.12.46 AM.png"></img></div><br/>

<h2 id='temp:C:VbX8e0f912112524e519d93af19f'>Preorder Traversal</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX43a643605c7641eead4afb032'><li id='temp:C:VbXc31abcc6abc5471dbed52069b' class='' value='1'>There are three different binary search tree traversals that all share a common strategy in how they approach accessing every data. 

<br/></li><li id='temp:C:VbX95fbbc5d4bd74502ad65f36c5' class=''>Each traversal is a variation of the same recursive strategy of traversing to the depths of each path.

<br/></li><li id='temp:C:VbXb476e79beed6470eadb64026a' class=''>Traversals essentially accomplish what an Iterable/Iterator in Java does. All that is different is the ordering of the same actions.

<br/></li><li id='temp:C:VbX58555f19eabd4511be1d84d8f' class=''>Preorder is a depth-first algorithm

<br/></li><li id='temp:C:VbX2e5a3cf693f84ecebca6458bc' class=''>Useful when making an exact copy of a tree.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/4qqBC6osl24tUKrrfHaRZw?a=SkW1wroGJWLBmRFHW7uH0yN4DJebadgZwaiPWJ3tYSka' id='temp:C:VbX22173c32257a4fc5bc1083a98' width='800' height='245' alt="Screen Shot 2024-06-01 at 6.12.28 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/g2DRkVzprQqvbqd83_AW4Q?a=sZ0GlE3zINH7PPkayagi4JUEi5KaLZ1x8zzf9kw8vGca' id='temp:C:VbX91c273d5c01a4ab2a5db286d6' width='800' height='356' alt="Screen Shot 2024-06-01 at 6.14.17 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/7kXocjuxh4D4q4aBUf1hxg?a=cFmKUy57g7fxNLA8NT6rwD0sFrH7BWUE853X0o4v1wIa' id='temp:C:VbXdbe47d96cc604c7590dcaf0dd' width='800' height='350' alt="Screen Shot 2024-06-01 at 6.16.17 PM.png"></img></div>(when left mark is reached, record data)<br/>

<h2 id='temp:C:VbX2e65cf716101444da46b20ab0'>Postorder Traversal</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5eafd5ffafe544489fd5a79f1'><li id='temp:C:VbX95bc1c8fd6704cb6b98380217' class='' value='1'>Also depth-first

<br/></li><li id='temp:C:VbX6d5a1d6ef09643d58f2e6f40f' class=''>Useful when removing leavings from a tree.

<br/></li><li id='temp:C:VbX8426a32931b0409989f785fc5' class=''>recurses first before looking at the data, whereas preorder looks at data first.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/elajf7-yBIFkNUDBE_meSg?a=eCh9rwaiMa2YO1aGxZkTjx6YP6o5ShntxDQvx5H2JSAa' id='temp:C:VbX73806b68386d4a348263bc332' width='800' height='248' alt="Screen Shot 2024-06-01 at 6.17.22 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/yCKwU2pGT80ZlQhFdZWPrg?a=ddQo6rTaiu2WDuyvKrNFCswrYPKhUWScyUTL4xYajiEa' id='temp:C:VbX9e178cdb2b4e4968bdd84f686' width='800' height='353' alt="Screen Shot 2024-06-01 at 6.19.39 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QXCR8mSP0AvCCA2T-sWeWA?a=92Ksju6gOIeJNj3OFC5K6hqdgrH6kQbFYlTB3ahb6dka' id='temp:C:VbXfc55515e1d94498e8c6c29d22' width='800' height='354' alt="Screen Shot 2024-06-01 at 6.21.54 PM.png"></img></div>(when right mark is reached, record data)<br/>

<h2 id='temp:C:VbXc5b7c662791045fd81482d965'>Inorder Traversal</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX904515740e154335be8fbbe9e'><li id='temp:C:VbX1c0e69eda8074788b86a24cac' class='' value='1'>Depth-first

<br/></li><li id='temp:C:VbX94f73216293a46eea8dcfa576' class=''>Unique for BSTs since it returns a sorted list.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8KVJrA4qS0heBhhAOEwhxQ?a=vLjxgtPGiPauzMAaQwix7MLSwrK7madR09tjFeCEaLEa' id='temp:C:VbX4e6c989a910e4929ba3a78fc7' width='800' height='246' alt="Screen Shot 2024-06-01 at 6.22.54 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/XP5eVKqZitqNHNcOAl3Xuw?a=RjbNuP7dotLSz4pqWvsavhQaOCwJhRedAUfhjaP3cb8a' id='temp:C:VbX8edb7a73e95b4398b06577264' width='800' height='351' alt="Screen Shot 2024-06-01 at 6.24.48 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/u2zgFYUkum4AjwUHrMbgLw?a=Zd8szKDEWzpCuKD0XfaiFNDt1NICn2VIkBatNTNUtFga' id='temp:C:VbXbf7e0401767640f48b902c6cd' width='800' height='351' alt="Screen Shot 2024-06-01 at 6.26.07 PM.png"></img></div><h2 id='temp:C:VbXf59551b085bf4eacab2624df5'>Levelorder Traversal</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX207db5881c4b4b8da9118b6fe'><li id='temp:C:VbXb7902c676be34c8683a6fc984' class='' value='1'>Breadth-first traversal strategy

<br/></li><li id='temp:C:VbX59d655a9d468416399c3f4a1d' class=''>There are other variations of this concept, but they are all similar to the levelorder traversal.

<br/></li><li id='temp:C:VbX17d0a02160c14862b30200473' class=''>Unlike depth traversals that utilize a <b>Stack</b> (the recursive stack), the levelorder traversal utilizes a <b>Queue</b> (with while loop) to access each data in an order sorted by closeness to the root, the level.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/OQt41q2X4BikFoRRwo6FfQ?a=1orfQ9vVfglLpMfmPEQnvJcraGdk2LrptaJLS7XfbLYa' id='temp:C:VbXe9a07de7b92d4a69bd1768e9b' width='800' height='364' alt="Screen Shot 2024-06-01 at 6.27.50 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9BFwCKPYTaHJoFNSkYGCVg?a=tI2H4fwQAsFIhkMTs4ybWQMxUwZjykPUbxaykIQvo2sa' id='temp:C:VbX7e7a2293ce164b2682be88847' width='800' height='363' alt="Screen Shot 2024-06-01 at 6.30.01 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FADyQGX7YPxPGB4Nx7uAzA?a=KNdGrEwcOG2ju9d7NScraa7BgFaSQVxZvU66YLK9hkga' id='temp:C:VbX8af7eca5ad864226a906807ab' width='800' height='367' alt="Screen Shot 2024-06-01 at 6.31.36 PM.png"></img></div><h2 id='temp:C:VbX55b92b333feb41cc86871952e'>Choosing a Traversal</h2>

We have covered four different traversals for Binary Trees in this module. It is important to note that these traversal concepts can easily be extended to general trees. After all, three of the traversals are derived from simply changing up the order the "look at node" operation is performed with respect to the recursive calls. The procedures within each traversal are defined for Binary Trees. However, the properties of the traversals are exemplified when specifically examining the data returned from BSTs.<br/>

Let's take the time to highlight some of their uses and distinguishing properties. So, what makes each of these traversals unique?<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX149cd2be7d5f4d008b534100d'><li id='temp:C:VbX048320de5eb44f6c8681aa6e0' class='' value='1'><b>Preorder:</b> <b>The preorder traversal <i>uniquely</i> identifies a BST</b>, when adding the data to an empty tree in the order given by this traversal. Although we haven't discussed how the add method works in BSTs, you can double check this feature of preorder traversal in the visualization tool. Most definitely, check this feature out after you've learned about the adding procedure. The preorder traversal is a hybrid depth approach that biases towards giving you data closer to the root faster, than data in leaf nodes.

<br/></li><li id='temp:C:VbX459f730a34a44f46b61ec88ef' class=''><b>Inorder:</b> The most notable property of the inorder traversal is that if implemented on a BST, <b>the data is returned in a sorted order.</b> However, please note that the inorder traversal is the only one of the four traversals that does not uniquely define the BST. If the traversal is operating on a general Binary Tree, then it will give you the data on a left-to-right basis (if the tree is properly spaced out when drawn).

<br/></li><li id='temp:C:VbXf98e2509fdb04a1c815526ae3' class=''><b>Postorder:</b> The postorder traversal is similar to preorder in that it <b><i>uniquely</i> identifies the BST</b>. One useful feature of the postorder traversal is that if you were to remove data from this ordering, <b>you would only remove leaf nodes</b>. This particular property will come in handy when you learn the remove procedure of a BST. The postorder traversal is a hybrid depth approach that biases towards giving you data in leaf nodes faster, than data closer to the root.

<br/></li><li id='temp:C:VbX5723bdd32284413aa025e161c' class=''><b>Levelorder:</b> This traversal is the black sheep in implementation, but it's also the easiest to understand conceptually. <b>The levelorder traversal gives you the data in an ordering sorted based on the depth of the data</b>. Thus, it is the fully realized version of the preorder traversal where it gives you full control of getting internal nodes before deeper leaves. As you might have guessed, it also uniquely defines a BST.

<br/></li></ul></div>We hope that this helps you keep track of what each traversal does. But more importantly, we hope that you look at these four traversals and think about what else you can change up to get the behavior and ordering that you want. For example, you could try traversing right first before traversing left in an inorder fashion to get the list is descending order. The procedures we've given you are the bare bones skeletons, which you can start modifying and tailoring to your needs as they arise, so have some fun experimenting!<br/>

<h1 id='temp:C:VbX4bf0e8fbc89e4a7d988322334'>M5 - BST Operations</h1>

<blockquote id='temp:C:VbXad727f44510346cd951fd70b6'>We are going to explore the power of the tree data structure, specifically Binary Search Trees, BSTs. We discuss the motivation for BSTs and how they relate to the binary search algorithm. We present efficient procedures for searching, adding, and removing in a BST. Similar to how binary search works, BSTs work by splitting the data into subtrees with about half of the data as the level above it, yielding running times on average.</blockquote>

<blockquote id='temp:C:VbX7373d2606f0e4988b7ff4aeb6'>At the end of the module, we introduce an example of a probabilistic data structure known as a SkipList at the end of the module. Though the basis of SkipLists and their structure is different from BSTs, they are actually very similar in how their search procedure works, which is why we've chosen to introduce them here.</blockquote>

<br/>

<b>Learning Objectives</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX9daf23ce496847acb56771922'><li id='temp:C:VbXd7ff3764de014ed59c3a2d5b9' class='' value='1'>Extend their understanding of tree structures and their impact on efficient search operations.

<br/></li><li id='temp:C:VbXc83106b37b7740c0a626cae08' class=''>Learn efficient procedures for searching, adding, and removing from BSTs.

<br/></li><li id='temp:C:VbXe55f01daabe34bab86e300bf0' class=''>Further their understanding of the pointer reinforcement restructuring recursion technique by applying it to the add and remove methods.

<br/></li><li id='temp:C:VbX195ed9fb673a4266bf1a69dce' class=''>Learn about a simple probabilistic data structure as a gateway to the world of randomization.

<br/></li></ul></div><h2 id='temp:C:VbXabbc24a0ad9d470cbb8d573a6'>BST Searching</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX779cab80b523472dbd2adefae'><li id='temp:C:VbX6df3c4dc5e874eb2a56680144' class='' value='1'>If tree is sorted, then tree is cut by half at each height.

<br/></li><li id='temp:C:VbX3b870b0c8c8447868f7369b8e' class=''>Efficiency: Avg: O(log n), Worst: O(n), Best: O(1)

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dftSc4XXd6NlSFr5_MzzcQ?a=2gVQ4STApjRXFP7WNVhxUmq3TROaoAL5NzyZkjgCKb8a' id='temp:C:VbX5f1c12e76175404eaaf9387bc' width='800' height='344' alt="Screen Shot 2024-06-01 at 7.07.09 PM.png"></img></div><h3 id='temp:C:VbX01423015ab03472faaa4fd9e4'><b>Best and Average Case Complexity Analysis</b></h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/wZ4H6vUIT6xA1VAlpxTLoQ?a=7iEzFCYRdmW19eH2XVV5OAEeGC5DipWiOqPpPt8P2dsa' id='temp:C:VbX6e3b0c30a01046ef8ec267210' width='800' height='689' alt="Screen Shot 2024-06-01 at 7.11.25 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/x2HePzGCWhzt82BW_CcJzQ?a=8boquLT8beX8h6YXOyufPvf69BDwHxcl3g4pZ2FQlcAa' id='temp:C:VbXafa69552110e4fc4a86e3cc6e' width='800' height='474' alt="Screen Shot 2024-06-01 at 7.11.38 PM.png"></img></div><h2 id='temp:C:VbX8b9764b6646a46b392d50d6a4'>BST Adding</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd704d2e90442462aa1e9c2dcc'><li id='temp:C:VbXe91d1d24e45e471ba4ddacc1c' class='' value='1'>Similar to BST search

<br/></li><li id='temp:C:VbX78235645d7e04ae1b73029957' class=''>Use ‘pointer reinforcement’, different from ‘look-ahead’ which keeps track of parent instead of current node and never reaches a null node.

<br/></li><li id='temp:C:VbX5e1cfe7d29f34625a735aada0' class=''>Pointer reinforcement uses return field to restructure tree.  Happens after recursive call.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/h9d-GCpb5KRY--Tc5gcPOg?a=6Z42XxnFdaWxSNaIHWxvo2RzLUQETapMudWgQ9GkD8wa' id='temp:C:VbX7d28bbf231614cdc87e2e06d7' width='800' height='362' alt="Screen Shot 2024-06-01 at 7.12.53 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ioTeyEBWayYdzfJfuPcYPg?a=f4tXtypCGZWCU7yLpo4pyY8Q3sNc8uk5lam1OU5J5Zga' id='temp:C:VbX05711906e7a14a21bd178633b' width='800' height='277' alt="Screen Shot 2024-06-01 at 7.15.30 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-J3hWVFhZVyfrSG2kvZBWQ?a=3uwPiWo1akyG7nbQlbCA2xSPu1nriMQzuzRQa95bLu4a' id='temp:C:VbX98fb59e062d74bb59486d6739' width='800' height='328' alt="Screen Shot 2024-06-01 at 7.16.00 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nvUbsNdlkOoknGLJVYamNw?a=6dY7FTuCn4nKGuyhfSAQI0NtVOnFivfxLUm1CTWWTika' id='temp:C:VbX4be5157feb404b39b6bba3483' width='800' height='290' alt="Screen Shot 2024-06-01 at 7.18.24 PM.png"></img></div><h3 id='temp:C:VbX72d02714b4d34f6ea8b7c159b'>Pointer Reinforcement Pseudocode</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc1a1988c59f84fad9a2430b76'><li id='temp:C:VbXb75d893411d04319ba6ff2e91' class='' value='1'>Public wrapper + private helper method.

<br/></li><li id='temp:C:VbX43ca2e8eda6a41189d922361c' class=''>make sure to return the current node at the end to reinforce the pointer.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/zVdiLIICcUyyvTbofHqKOw?a=xXeyiygh7Aqr2eWFvgU1BladRPXE0F1ahv4O2YTYSWwa' id='temp:C:VbXa14f717952874373b6a079a33' width='800' height='320' alt="Screen Shot 2024-06-01 at 7.22.28 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Gu2-ou79KNitRjHM-c6Fkw?a=bZQRaZsZSfJ3QKAMqkaeuXalhVet0BbZcNyNYC21LqYa' id='temp:C:VbX52a2f91ae1994c98b9b8164af' width='800' height='321' alt="Screen Shot 2024-06-01 at 7.19.44 PM.png"></img></div><h2 id='temp:C:VbXc4157786d4aa480ab79897300'>BST Removing</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX94af3b15e67947f8983381ade'><li id='temp:C:VbXeb5a93dcc0cd4a60bb5913946' class='' value='1'>Must find element before removing.

<br/></li><li id='temp:C:VbXeb5ae8f5f40448f98c97d0639' class=''>3 types of removal (zero-child case, predecessor, successor, two child case)

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FKujytlI7fw4bfztkudAlw?a=RLW81b46CchAYeQmHRhVgYAZP9aG2OWKcK4QNaajQGQa' id='temp:C:VbX9d217dced5b147b9bd8a51511' width='800' height='362' alt="Screen Shot 2024-06-02 at 3.55.50 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ERkv1VfnDb071xZZdQLrHg?a=S3c9aNf4x4QNhaFEeAbxWmA6i54qyUX5Ncb0wfjFX50a' id='temp:C:VbX11db12fc3d8f4f79861208611' width='800' height='307' alt="Screen Shot 2024-06-02 at 3.57.37 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXbb56f780710a4e93865094d76'><li id='temp:C:VbXe4767383a9634c3597148b333' class='' value='1'>Easiest, just remove node if node to remove has no child.  No restructuring needed.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8kn4s91oXh9jnsC954fUdg?a=htokS3wX6dZ6tL3AWACRxtQnDSzPx00zSpxruIPSdUca' id='temp:C:VbX92b51eb3978042ab999001f0b' width='800' height='307' alt="Screen Shot 2024-06-02 at 3.58.23 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXb2782d3c4bee48de870483f1e'><li id='temp:C:VbX3141e818fc594c2eb15ef1a2e' class='' value='1'>Removing node with one child, set pointer of parent node (13) to its child (8).

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/wJzvuNoHwUuApxFT1GTKhA?a=FHIiCcTaQvReiaeeHL6fPEaSFLXUvt0gSKRFIuqLbbga' id='temp:C:VbXab2f9db1abc947aca8d21817e' width='800' height='323' alt="Screen Shot 2024-06-02 at 4.00.17 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX78a52157ebf644fdbf1d53766'><li id='temp:C:VbX4cae17182ace486891374de6d' class='' value='1'>Find “predecessor” of node to be deleted, and make that the parent of tree.  This is the farthest right node on the left half of sub-tree.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mNSd1ZgwYfm2h-h0AX3Jxg?a=D6N1jvuX6di9k6YRQTw6kD3BzkmCNb3lfV6LMan73xUa' id='temp:C:VbX4e19e6d16ada4fac9bbfd5cea' width='800' height='311' alt="Screen Shot 2024-06-02 at 4.01.11 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX707e6189e20f403ea73846269'><li id='temp:C:VbXd673b8069a4b4c43a921f7ac1' class='' value='1'>Find “successor” of node to be deleted, and make that the parent.  This is the farthest left node on the right half of sub-tree.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ScYsBmzhHHz9uLaWrYMlAQ?a=LuB8P6d5KzXGt2himEcOamcjPBWaqV2x5dJ8Yys4aEga' id='temp:C:VbX25085d1734d3424aacc575f0d' width='800' height='372' alt="Screen Shot 2024-06-02 at 4.01.52 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXcae12780e9ea41f99ad694936'><li id='temp:C:VbXc0c23344c493401ca96d12a9c' class='' value='1'>Resulting tree differs based on using either predecessor or successor strategy.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/cxBS3onUq9-1lLSStdjdKw?a=AMg8ay8PhLvFrXd0T36oYVgpNSuDSO6uZtaza28bfzYa' id='temp:C:VbX165ffc87fde643cfbcaeb8c4a' width='800' height='367' alt="Screen Shot 2024-06-02 at 4.03.06 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX5c85e57d6aa64f459411812f5'><li id='temp:C:VbXccbdfe0a997b42e9942f84a4a' class='' value='1'>The two <code>i</code> (public, private) are different variables

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9tRoRHicIZ7vedDuq35bLg?a=FWO7JIfa94k7pmhrNRYry7ThusUoUZJFgdU0LFaEHZQa' id='temp:C:VbX4ed2a433c80d4bdb8c2476810' alt="Screen Shot 2024-06-02 at 4.24.10 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dfBQA0LPsW_K_HRJMn6W9Q?a=tATrIigXfZLOsigdon78TluawDXWmuPO3ljdMjXaP2wa' id='temp:C:VbX1b270eeacfa44ff59d7559390' alt="Screen Shot 2024-06-02 at 4.23.53 PM.png"></img></div><br/>

<h3 id='temp:C:VbX947f4accf70a4ece9d5607ad0'>Pointer Reinforcement Remove Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/iquUHoZyxAhBTSzZWW-tKw?a=LXR25lkgtev8HobUbPP3w9TJDjtj5WStGIE3A92vYLsa' id='temp:C:VbXb0c6961e06494ef184638a002' width='800' height='329' alt="Screen Shot 2024-06-02 at 4.04.55 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX9250e8da33d4482b96bd550fd'><li id='temp:C:VbX7f27bda7fb1b46f48dfb338f8' class='' value='1'>Dummy node serves as storage data passed in recursive call.

<br/></li><li id='temp:C:VbXb7225f4eea62476a87c958a46' class=''>pointer reinforcement logic same as add

<br/></li><li id='temp:C:VbXd7084b90eb1042e18d37a461d' class=''>2 base cases: if node is null + is node data matches data to remove.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/V1Fu0byOwGoIqE_1apCFYA?a=gGglf7aIIqAqkgrDjfQ5bTY28wbaHagXslHlmWdOc1Ia' id='temp:C:VbX58a70977370540999e44fc2f9' width='800' height='295' alt="Screen Shot 2024-06-02 at 4.06.30 PM.png"></img></div><div class="" data-section-style='6' style=""><ul id='temp:C:VbX4662a46727e84062a191bf3c1'><li id='temp:C:VbXdbc52f846d8b473eaeb3d6884' class='' value='1'>If no children - return null - sets parent’s pointer to child as null

<br/></li><li id='temp:C:VbX20d890a9e78043a79c46f66b9' class=''>If non-null - return child node

<br/></li><li id='temp:C:VbX9ca91e2d6e3740c49c9f8eb7e' class='parent'>If 2 children - make another call to remove successor (or predecessor)

<br/></li><ul><li id='temp:C:VbXaf14e82d6ee54c8b904807150' class=''>Get data from successor by making another recursive call to remove successor node and get data.  Then set current node’s data to child node’s data.

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FWnc8Q6XBEtU8l-AyBBCIg?a=GaIBdX2WpD9VJzdxFD7aL5WHXE2s4DZjJox3ozOqLl4a' id='temp:C:VbX9a2d1e7e48bf4e5db168217ea' width='800' height='197' alt="Screen Shot 2024-06-02 at 4.08.50 PM.png"></img></div><br/>

<h1 id='temp:C:VbXc67445067f034da8b32810c09'>END OF PROBLEM SET 1</h1>

<h1 id='temp:C:VbX96c08b7462934804b7a95934b'>M6 - Heaps</h1>

Let's look at the "cousin" to BSTs in the Binary Tree group, <b>(binary) Heaps</b>. Heaps are a binary tree-type data structure that prioritize access to either the smallest or largest item in the data structure depending on the heap type. In a sense, heaps are a specialist data structure most commonly coupled with the Priority Queue ADT. Whereas, BSTs are a generalist data structure useful for a lot of different operations.<br/>

<br/>

An interesting caveat to heaps is that unlike BSTs, they are commonly implemented using backing arrays. There is an additional shape property constraint for heaps on top of the binary tree shape which lends itself to an array implementation. This allows us the opportunity to explore how an array implementation may work for a tree-type data structure. We'll explore this through three operations: adding, removing, and building a heap from a group of unordered data.<br/>

<br/>

<b>Learning Objectives</b><br/>

<br/>

<b>Students will:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX8457efcb5bc84d20a3fb8e702'><li id='temp:C:VbX5608c6e9a490435dae8467585' class='' value='1'>Learn about heaps, the most common data structure for implementing the Priority Queue ADT.

<br/></li><li id='temp:C:VbXcf55aaea41424445a76d30149' class=''>Break down and understand efficient algorithms for adding, removing, and building a heap.

<br/></li><li id='temp:C:VbXfef3d02b47154f27982193e7d' class=''>Expand their knowledge of different tree types structures and orderings, along with the benefits (and difficulties) such constraints bring.

<br/></li><li id='temp:C:VbX03851dac2777462bbc5668ac4' class=''>Experience what it's like to back a tree-type data structure using an array rather than in a linked fashion.

<br/></li></ul></div><h2 id='temp:C:VbX144f8ad3f60045a4be7c73889'>Intro to (Binary) Heaps</h2>

Here we present an introduction to a new data structure, (binary) heaps. The term binary is in parentheses because there are multiple types of heaps, and we are discussing a particular heap. Binary heaps are the most common type of heap. Thus, when a heap is mentioned, most often it is usually referring to a binary heap.<br/>

<br/>

Heaps are another binary tree type of data structure with the additional shape property of completeness. We will study this concept in this lesson. Completeness is a very nice property that <b>lends itself to an array-implementation</b>, which is usually faster at a low-level when compared to a tree node implementation. Heaps also have a <b>different order property when compared to BSTs</b>. The heap order property changes the way we need to look at basic operations such as add and remove.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/kLkIfvUUU69Auey3SPwk4Q?a=k2vRqyLyjVAyfvTWJYEnppy78Vg3kike3B4LoXbzokEa' id='temp:C:VbXab130a0e90b043e1b7cf976af' width='800' height='369' alt="Screen Shot 2024-06-02 at 4.46.37 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX0fed1710ae144acdb2b121110'><li id='temp:C:VbX6432b5d46b4d43089e4b1f2a3' class='' value='1'>Heaps must be “complete” - filled left to right with no gaps.

<br/></li></ul></div><h3 id='temp:C:VbX37d7d1aa7188416f9d97d5917'>Order Property</h3>

In a heap, the parent node is always larger (in the case of a maxheap) or smaller (in the case of a<br/>

minheap) than its children. There is no relationship between the children.<br/>

<h3 id='temp:C:VbX3415c23e1a6f4382bee75ffa0'>Shape Property</h3>

<span style="color:#2cab21" textcolor="#2cab21">A heap is always complete.</span> At any point, each level of the tree is completely filled, except for the<br/>

last level which may be filled from left to right with no gaps.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXdce8d4038df84228a84dd3216'><li id='temp:C:VbX62d05261207b4ec68dca5dd96' class='' value='1'>Can not search a heap!

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-jTxnL8dlAQHBX2Nv-9c-w?a=Okjm82vFxKYosOZWh609go3sLKT16ZYnyQaDR5CGZRoa' id='temp:C:VbXb662a0fbf55f45b793ae45d62' width='800' height='355' alt="Screen Shot 2024-06-02 at 4.47.17 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HsEpxar9jI6pgDNnKG5X3A?a=MYm1GHds4SomT6t8VvBxlS6a1mCr8amGfzsgEsLrqfQa' id='temp:C:VbXe4a9e0b43dfc4412b21d1e154' width='800' height='364' alt="Screen Shot 2024-06-02 at 4.48.21 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX6d8d31f5625747a39d68e24e8'><li id='temp:C:VbX38232d4d852847eb86a4e832e' class='' value='1'><b>Min Heap</b> - Smallest element at the root

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0hZcwK6qJ_IMzniqo7TMoQ?a=Mjo972l4aocW5ayPeJOEo9orswlj3ghsdWv5XBIzn8ga' id='temp:C:VbX6e8de5c1eee0444db6960bcf1' width='800' height='349' alt="Screen Shot 2024-06-02 at 4.48.09 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXab85e0391bb2428bb95c8dc43'><li id='temp:C:VbX9609753d6c834a33942d887e3' class='' value='1'><b>Max heap</b> - Largest element at the root

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/D5kCHbwI6ZRviGqLSUrpdA?a=BdAu5w05I01YGoSOy7St7sL3uPIOJvcTXa2nJlo8km4a' id='temp:C:VbX2438eaf8676c4ff9a75757ff2' width='800' height='372' alt="Screen Shot 2024-06-02 at 4.51.13 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX04c95c96610c44649d15955f8'><li id='temp:C:VbXd10d5ab50d334c7c97e5193e8' class='' value='1'>Backing array doesn’t have any gaps

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/X-PnH-yNecMSGreeWjSOaw?a=gbsbxkbKUuI9xWtVuOsVVYYznX7frgq0E5dZ4zt7CdQa' id='temp:C:VbX92caaf91e5814f94ab26f181e' width='800' height='309' alt="Screen Shot 2024-06-02 at 4.52.01 PM.png"></img></div><h2 id='temp:C:VbX6ce2edee99dd42439ff72ea04'>Heap Operations</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd0d8b2af4ca64dfa8e9a1b38f'><li id='temp:C:VbXad7231b3e6724a278b13bca55' class='' value='1'>Not designed for search!

<br/></li><li id='temp:C:VbXa5bf35b302e149c18527ff92b' class=''>Index 0 never used (makes math easier)

<br/></li><li id='temp:C:VbXe48378cb86314c328b85caffb' class=''>Only consider add and remove.

<br/></li><li id='temp:C:VbXfb22f4da383648e091f09bd96' class=''>Key Idea: Enforce shape property, then order property. “Up-heaping”.

<br/></li><li id='temp:C:VbXf2897e7b6a1843a2b340bd0a6' class=''>The left child of an item in index i would then be at index <i>2i</i>, and the right child would be at index <i>2i + 1</i>.

<br/></li><li id='temp:C:VbXd88cf6a465154da08caf3d208' class=''>The parent of an item in index i would be at <i>i/2</i>(this is assuming you are doing integer division).

<br/></li></ul></div><h3 id='temp:C:VbX1f9d66cea09d48e39d0e25b13'>Adding</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/NYqwij2gIZUtNSVqGQhWnQ?a=RN4iRV9tvBLu5wjavXuxlY4aS3kxrv4kJreThnarBSIa' id='temp:C:VbX19f309c3e78740158c11ba4d6' width='800' height='272' alt="Screen Shot 2024-06-02 at 5.02.57 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Ciwj1jXKokptcCGgPQkGug?a=KtJ93aSYqaqtaIS6GGugwvU6GvhDX3dICaQcVa27xqQa' id='temp:C:VbX0f4796a4f9a241fd877eb26e7' width='800' height='369' alt="Screen Shot 2024-06-02 at 5.01.07 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BAzDU9AhCvA46p5UItpZEA?a=KOPhuPoMwr4qYafM0V8NBupXljVfkMsFEPZBHOXxDs0a' id='temp:C:VbXf15b653060ee4b7f9e67e5040' width='800' height='374' alt="Screen Shot 2024-06-02 at 5.02.04 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXdf3ccea2970b4bcc8b2042d26'><li id='temp:C:VbX0c551bf480c64f5e81140c391' class='' value='1'>Upheaping (ie. swapping nodes) continues up to root node.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Wz0DYIgNl3AHRu3MFvhOYA?a=4YZa9TMbvDLPfyGZh52OGEYavovNOZSf0re2xWLedvwa' id='temp:C:VbX8465ba58d6ca423d8d27f234e' width='800' height='451' alt="Screen Shot 2024-06-02 at 5.58.10 PM.png"></img></div><h3 id='temp:C:VbXcdd93eef13bd454ea9cd5762c'>Removing</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX21a3032bbf9e4a7eaeb360f8b'><li id='temp:C:VbX1f2ab2b9478943cb906015f4a' class='' value='1'>You can only remove from the root

<br/></li><li id='temp:C:VbXf02ee43c2af94665af09064c6' class=''>Remove the item at the root, and move the item in the last slot of the heap to the root. This might break the order property, but that is fine.

<br/></li><li id='temp:C:VbXabccc75c69f049f6822b7eeee' class=''>Compare the item with the item in the left child and the item in the right child. If either the left child or the right child is smaller (in the case of a minheap) or larger (in the case of a maxheap), swap the item with the smaller/larger of the two children.

<br/></li><li id='temp:C:VbXcc0823b3d0964dafaa72afea2' class=''>Repeat the previous step until you don’t make a swap or you reach the bottom of the heap.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/pKlWGeAvEmmV9AqIT1qRHQ?a=e7uvuVxjWXGs5g7rTP7k1Vq6LO5wfnmyLPaN84UMBdUa' id='temp:C:VbX4739faec53c44fc5914ca7b4b' width='800' height='309' alt="Screen Shot 2024-06-02 at 5.07.27 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX3ba6054a21534afbba5a41e26'><li id='temp:C:VbXfc132cbd5df64301a5aea467e' class='' value='1'>Re-ordering takes the most time (like upheaping).

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/rchR0Ayu5QhwgduZ4lA7dg?a=gbiasbwHNupyTqwp2Q3BdOHxiW3ZZa2HaXdLgnDhWs8a' id='temp:C:VbXdd0e558b405047dc8a71fdf0a' width='800' height='365' alt="Screen Shot 2024-06-02 at 5.06.10 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/u-7uOSebECmcVzx6pWbwRQ?a=fmdBCF4bXa4vsmLSafA2aQtrJFd7tOETJHAc6YaqzWQa' id='temp:C:VbXaeba4b2d12e34907853c4b19b' width='800' height='366' alt="Screen Shot 2024-06-02 at 5.05.57 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXa6dea391281a4961b35b37b14'><li id='temp:C:VbX6050bb8b101b477e8d7c649d0' class='' value='1'>order property is violated, so we perform a downheap (this is a max heap implementation)

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/e5lgLByzOegh2NcEaZ7IRA?a=Wb182Ee9beKZqvaaPLbaXFIVgxrT4X14hdilfAzOhOsa' id='temp:C:VbX28684b50a0d940aca0dc811c3' width='800' height='365' alt="Screen Shot 2024-06-02 at 5.06.52 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX3f8ac414511f4ef0b93d8a667'><li id='temp:C:VbX45c53ab7fbcb469aa53508c0b' class='' value='1'>Continue until order property is satisfied.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/7PVFQ-Buk9WBe1d3T8DW2A?a=NACapc4YCpruHIN4JDvWxs6IhKTEKtDdYMReWvIelnca' id='temp:C:VbXf502ae11bc7f41d3b55789f7b' width='800' height='361' alt="Screen Shot 2024-06-02 at 5.07.12 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/t8J4rq29zILDIGvpQOHOmQ?a=Ek6br5bWuDttMaUnYuV9KM8NFoikKJivwQYBauSLs38a' id='temp:C:VbX8034d01fd3974ee9af67ccbc1' width='800' height='494' alt="Screen Shot 2024-06-02 at 5.59.57 PM.png"></img></div><h3 id='temp:C:VbX0e7241751f2a40af80eab3999'>Performance</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/VVsTLaeQ936EPht85MFpeQ?a=I6elJ8eWHmFKljV0nJBUCpAvE00AJtPLaQnduxVA9CEa' id='temp:C:VbX3682e9bc32ed4870b86157d29' width='800' height='346' alt="Screen Shot 2024-06-02 at 6.00.36 PM.png"></img></div><h2 id='temp:C:VbX26d8863852f946d8bd1ca45b5'>New Operations? New Heaps - Food for Thought</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oaJEBzX83L8VDhD3fQxzNw?a=uPYXFaSatiPg6dyzsoCEJBGxtPNtsAAokj3NgikTNBwa' id='temp:C:VbX6ec458cd7ac243a7a48043533' width='800' height='482' alt="Screen Shot 2024-06-02 at 5.30.15 PM.png"></img></div><h2 id='temp:C:VbX32b9e03dc9804df29d1160aae'>Build Heap Algorithm</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/y7IxIhWlyhdKCHyKg0DggA?a=QqfUZJsspiuq42Nj7cZhYJLRLESreUhtadRaHXBCatsa' id='temp:C:VbX10e22ebd90574425ba2995e5a' width='800' height='298' alt="Screen Shot 2024-06-02 at 5.32.37 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/6G8mpkrG_AZu-xWuLRv-nQ?a=OzJ0aEeosoK2vB9pu5tRqDqGmJBO5OarPxQQDJ7h8Lga' id='temp:C:VbX58de49df24084c28a475a2d88' width='800' height='335' alt="Screen Shot 2024-06-02 at 5.33.07 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/DSNtLH4KAxmPE8AKGNgpPg?a=h3OyyEdaUtL4R07zYCZNMZxEUmOoI4YaNhWqNXstLa8a' id='temp:C:VbXd28df582a8f5479590534fc87' width='800' height='230' alt="Screen Shot 2024-06-02 at 5.34.04 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/kUxsfuTgCcjPiue_wEbA-g?a=VtmEiRlMA8Dca3YwVYLGWz0V0ycCwGjaafzzQueSykEa' id='temp:C:VbX80820799503e487d984730c13' width='800' height='367' alt="Screen Shot 2024-06-02 at 5.34.25 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX08c672c308ea4252ad5ba6ad6'><li id='temp:C:VbX07256438e09042af9d62298fd' class='' value='1'>Need to build from bottom up

<br/></li><li id='temp:C:VbX9e2bda29ef8d4468bec3e5ca3' class=''>index size / 2 gives you the parent

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-jY1muTtCpzyJQh_E0JjFA?a=6amN61LJTYgolI5QEIahpU2nclJlV1NDWhyecLIbzd4a' id='temp:C:VbXef59ac9c9188407e89730bf69' width='800' height='373' alt="Screen Shot 2024-06-02 at 5.36.07 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/xSaFpIL7c4Z4kO1FHi9Ubw?a=depEVVadcIROUYIerBrKvlXJ08EnMlaT3RlKaP55Uu4a' id='temp:C:VbX34797a689aca4a32b6c3e4208' width='800' height='369' alt="Screen Shot 2024-06-02 at 5.36.56 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXcdec18f362414bfd9839abe9b'><li id='temp:C:VbX8aa6a7dadeae400faee60554b' class='' value='1'>Start with last index divided by 2 (32).  Swap parent with smaller child (32 with 5) and perform a downheap.  Downheap looks at swapped child node, if child node is a leaf the subrouting terminates.  If child exists, it continues the swapping.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qn9FRcC-NLihOW5qhCoHoA?a=LzUJGhceFETURluLJI0MMiI3KRbdEBSKNqlmfrKCTRAa' id='temp:C:VbXa8c997451ab542bfbb9f86c2b' width='800' height='373' alt="Screen Shot 2024-06-02 at 5.38.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Fe77N8hkxG5CLkb9FSUzzw?a=NOwem3OmElZWaOFjkiSC1mWqdlkDiMA24MDzhWEoOlUa' id='temp:C:VbX7285113a9c5044dc987db2cc8' width='800' height='369' alt="Screen Shot 2024-06-02 at 5.38.56 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX890230371f67485491dd95142'><li id='temp:C:VbX7d8fbe19d8134c51a48a45b1b' class='' value='1'>71 is swapped with smallest data, continue downheap

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/pud51heCtCt6g_IqsgPVxg?a=IyBISXM9xIg5PbYgOZhuNC5QWuShx62r10nMAvtuOv0a' id='temp:C:VbX3b581b13470e431e99d8db909' width='800' height='367' alt="Screen Shot 2024-06-02 at 5.39.35 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXffe86228b69e4d4490997425b'><li id='temp:C:VbX2255c9885168423ba73aede36' class='' value='1'>Swap smallest child with 71.  Downheap is complete since 71 has a leaf node.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oSJK14g_ORaBH3fUS5up5A?a=4FPBwaOlfOEjvHOvxGaoCTaoRfSNriGlCTg8ILGU34Ia' id='temp:C:VbX93871256b04c4e18b4b7e1b4e' width='800' height='364' alt="Screen Shot 2024-06-02 at 5.40.09 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX1a9f3e8e1fed40e69381ee895'><li id='temp:C:VbX67a7ff08e37648c79d0e5b91b' class='' value='1'>Reach the root node, both children meet the ordering requirement.  Terminate downheap.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/zVDUJ3UBcEqd3K3YEa7VTQ?a=JWLkk55aUy4skWTIPzjYCozSBdW9eyhrTaa4BWNYopAa' id='temp:C:VbX3febbfcc85824837a5a453296' width='800' height='356' alt="Screen Shot 2024-06-02 at 5.40.43 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX1795f01f08ce4928bf6627609'><li id='temp:C:VbXb9fc3adee32847b8a4a10eded' class='' value='1'>Time complexity is actually O(n)

<br/></li><li id='temp:C:VbX00fa4064284a4979bccdc30ac' class=''>Leaf nodes have O(1) cost, and few of the higher nodes have O(log n) cost.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/pYSJ-sl0iJoyLAPPFvu7YA?a=jIC0HQfa2o0uhJHEpvaDGCwW1hVWoaHmdaPVNnaxKGka' id='temp:C:VbX2031932042a64b06ba22294e9' width='800' height='380' alt="Screen Shot 2024-06-02 at 5.41.39 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/fzwNj-cEEDx34IhWXQIgBg?a=uJU70AzfEkeHL8RjJMSMq1g6qiirLgJOdcpb5az71dca' id='temp:C:VbX6e3ac437a340406091c0580e7' width='800' height='369' alt="Screen Shot 2024-06-02 at 5.41.47 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YRzNroNAyKaXKP3M4NjMOA?a=7iftMmw1irRBv9wpVnlCjXghxapl1IoJagulg9GWzB0a' id='temp:C:VbXc2424faf061148269b0cc88c0' width='800' height='367' alt="Screen Shot 2024-06-02 at 5.42.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class='tall'><img src='https://quip.com/blob/VbXAAAKnj4j/2Yx4QNdDFbNFlqMvHusOjg?a=afhSkBPtLMIdTMCXi1IaERFh4qwaw1faVSVUfP89xaoa' id='temp:C:VbXe875788b98c14e629d0311eb6' width='800' height='824' alt="Screen Shot 2024-06-02 at 5.43.18 PM.png"></img></div><h1 id='temp:C:VbX24d3e95ac4cc41378c6de0c34'>M7 - Hashmaps</h1>

Now, we take a look at <b>HashMaps (HashTables)</b>, one of the most commonly used data structures in computer science. HashMaps are very useful if we want to search for a specific data in our data structure. This is helpful when we'd like to check for membership of data where we're using the search data as a unique identifier for some other data (in which case the searched data is called a <b>key</b>, and the implemented ADT is the <b>Map ADT</b>), and with the <b>Set ADT.</b><br/>

<br/>

Looking back at our toolbox, the best time complexity we have for this problem so far is on average 𝑂(log⁡(𝑛)) via BSTs. Remarkably, we can do better, with 𝑂(1) search times on average! In this module, we'll be introducing the big idea of how we achieve this incredible efficiency, known as <b>hashing</b>. We won't be rigorously proving the average efficiency, but we hope to provide you with an understanding of the mechanisms of hashing, the flexibility such a technique brings, as well as some intuition for why the idea works.<br/>

<br/>

<b>Learning Objectives</b><br/>

Students will:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1ddcca04d3e94e88a640c98c7'><li id='temp:C:VbX092004307af54da2a2c4fc440' class='' value='1'>Learn about the Set ADT and the Map ADT.

<br/></li><li id='temp:C:VbX305ba6ddfeb541da82f4f736c' class=''>Explore the idea of hash functions, along with how they're used in HashMaps to achieve <br>𝑂(1) average search times.

<br/></li><li id='temp:C:VbX135e14234cdf4544bd1503564' class=''>Understand the challenges of <b>collisions</b>, a necessary consequence of how HashMaps work.

<br/></li><li id='temp:C:VbX350401f497214b569e7b9ecaf' class=''>Observe multiple collision resolution strategies at work: external chaining, linear probing, quadratic probing, and double hashing.

<br/></li></ul></div><h2 id='temp:C:VbX401e61e388f149059ffbcf392'>Introduction to HashMaps</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0_E8rXHKiOE6YapoE6FtnQ?a=5M21JH61xsnS4gB8aWyxYnOrbdbluquvWpMRoEJhrf4a' id='temp:C:VbX732dfad9a8db41088ee7c894c' alt="Screen Shot 2024-06-11 at 9.43.22 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ShOZXQltcwJqqlhg_XtlxQ?a=R5VJvOrn6xY9Uhew3B9va8AfAXyayZLHdkamsKazS7sa' id='temp:C:VbX25bcaf50acb54b609a9c94a46' alt="Screen Shot 2024-06-11 at 9.45.05 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/K34NImM79TrngD6tXq5bpg?a=GzdZAsP2ix8mZDQlNOUQtZr3YaFajYxKwPTs0N8duzIa' id='temp:C:VbX7018197bab244cf4824d428f8' width='800' height='367' alt="Screen Shot 2024-06-11 at 9.46.01 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXb4d3a7de1a17457db6a193f80'><li id='temp:C:VbX827883545812421f95eab3692' class='' value='1'>Note: backing array of 100

<br/></li><li id='temp:C:VbX6e9f7c01989e4766a310ccf5a' class=''>Mod hashcode by 100 to get compress keys

<br/></li><li id='temp:C:VbXa730b4a8245d4bb9a9a31fbe6' class=''>Collision may occur with modulo - this is inevitable, but there are ways around it

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/WeyYYVCcjVwmvArnLdRwcw?a=aWVvJaocc0E9U97C0aN03T2bGMcDlwTGavCZjqyYiYoa' id='temp:C:VbX0ba945550a154a77994fdb9f5' width='800' height='325' alt="Screen Shot 2024-06-11 at 9.48.26 PM.png"></img></div><h3 id='temp:C:VbX46f866fcfba4487885b88dfa0'><b>The Map and Set ADTs</b></h3>

Let's first recap what we know about the Map ADT. Maps are defined by multiple key-value pairs (denoted <br><code>&lt;K,V&gt;</code>), satisfying the following properties:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX2029bbda08764542a43a034c2'><li id='temp:C:VbX1acb5a2130bb4a0cb3dbf2135' class='' value='1'>Keys are unique and immutable, essentially allowing keys to act as search objects for their associated values.

<br/></li><li id='temp:C:VbX3d852d2db8754887b50e950e5' class=''>Values are tied to keys, but they do not need to be unique. There may be multiple key value pairs where the value is the same.

<br/></li><li id='temp:C:VbXfffb7b6fd90a4bdba9a7d4a99' class=''>The keys do not need to have any sort of ordering to them, though they are allowed to. If ordering is desired, then it becomes something called an Ordered Map, which we will not be delving into in this course.

<br/></li></ul></div>Now, what operations do maps typically support? There are other operations such as returning the size or clearing the data structure that might be useful, but we omit them for brevity.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX71655e20c6b24f45a751fbc7a'><li id='temp:C:VbX22febee484d6453e933021fb5' class='' value='1'><code>V put(K key, V value)</code>: This method adds the key-value pair to the map. If they key is already present in the map, then the value is replaced with the new one passed into the method, and the old value is returned. If the key is not a duplicate, then a null reference is returned.

<br/></li><li id='temp:C:VbX723d3fa1ce7848669afe4628d' class=''><code>V remove(K key)</code>: This method removes a key-value pair from the map and returns the value associated with the key.

<br/></li><li id='temp:C:VbX2cbf2655c13242a1a675258f2' class=''><code>V search(K key)</code>: This method looks for the key in the map and returns the associated value. A modification of this operation that is commonly used is to just check if a key is in the map (typically called <br>containsKey.

<br/></li><li id='temp:C:VbXa6b3be0056144c71aafa34930' class=''><code>Set&lt;K&gt; keySet()</code>: This method returns a Set of all of the keys in the map. We will discuss what a set is below.

<br/></li><li id='temp:C:VbX80c522d392fe4a93a8bb3d9bd' class=''><code>List&lt;V&gt; values()</code>: This method returns a list of all the values in the map. The ordering of the list is in no particular order.

<br/></li></ul></div>Now, what exactly is a set? The Set ADT can be thought of as exactly what a Map is, except we only have keys as our data and no values. If you're familiar with what a set is in math, then you can think of them as much the same thing here, except that these sets are typed to hold only one type of data. Similarly, you may sometimes hear people say the term dictionary to refer to a Map; in particular, Python uses the term dictionary to refer to this idea in the language.<br/>

<br/>

If you think back to some of our earlier data structures such as BSTs, you can think of them as implementing the Set ADT or the Map ADT. If we search in a BST to check for membership of data, then it's a Set. If we're looking up some identifier tied to other data (such as an id number tied to a user record), then it's a Map. For most of the examples in this module, we will omit the values and only look at the keys. This is because there is very little restriction imposed on the values, so any search algorithm will depend solely on the keys.<br/>

<h2 id='temp:C:VbX3fa56328c6954b06be4d27e16'><b>Spec'ing our HashMap</b></h2>

In the video in the previous section, we touched briefly on the idea of collisions, and as you progress through the module, you will find that collisions are the source of most inefficiencies in HashMaps. Most of our time will be spent on how to resolve collisions (<b>collision resolution strategies</b>), but the truth of the matter is that much of the work of a good HashMap occurs even before all of these collison strategies! The old adage "Prevention is the best medicine" applies here very well, so let's take a quick look at some things to consider when designing a HashMap.<br/>

<h3 id='temp:C:VbX9f081c3ca1f440d8aa561edd9'>Picking Hash Functions</h3>

The first thing we're going to look at is <b>hash functions</b>. Formally, a hash function is a function ℎ:𝐾→𝑍, which means a mapping from keys to integers. This step is necessary because our keys might not even be numerical like the phone number example from the video. For example, if our key is a String, then we need a function to convert from a String to an Integer.<br/>

<br/>

As for the requirements of this function, we <i>technically</i> only require that if two keys, 𝑘1 and 𝑘2, are equal, then their hash function evaluations, ℎ(𝑘1) and ℎ(𝑘2) are equal. So, technically, the zero-function, where we map every possible key to 0 is a <i>valid</i> hash function. However, it's not a very good hash function. We want the reverse to be as close to true as possible as well: if the hash function evaluations are equal, then the keys are also equal. In some cases, this may be possible, but in many cases, it may not be possible without infinite memory (<a href="https://en.wikipedia.org/wiki/Countable_set">or may not be possible at all</a>). After all, what good is a perfect hash function if we can't store it in memory?<br/>

<br/>

Let's take a look at our example of converting String keys into Integers. One reasonable way to do this is to just assign each character a numerical value, then add those values up. For example, if we assigned the letter A the value of 1 and the letter B the value 2, then the string ABAB would have the hash value of 1+2+1+2=6. This is an okay hash function, but it has a weakness. It doesn't take the ordering of characters into account at all, so any string of length 4 with an equal number of A and B characters will collide into the same hash value. One way we can fix this is by taking a page out of our number system and multiplying these values by something based on their position before adding it up. For example, if we multiplied it by powers of 10 based on the position from right to left, then we get <control data-remapped="true" id="temp:C:VbX8ea2b43e3df048c48f5e09255">1×103+2×102+1×101+2×100=1212</control>.<br/>

<br/>

This was just one example of a hash function from Strings to Integers, but there are plenty of other reasonable ones as well. In Java, hash functions are written in the <code>hashcode()</code> method, which is why Java always tells you to override it when you override the <code>equals()</code> method!<br/>

<br/>

<b>TLDR on <code>.hashcode()</code>:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5b493107ef3d4cdeb69e4c6cf'><li id='temp:C:VbX4fa13217284c46fbb918d287d' class='' value='1'><code>.hashcode()</code> returns an <b>numeric representation of an object</b>

<br/></li><li id='temp:C:VbXd46d56b207fe4cf3ada434036' class=''><code>.hashcode()</code> is an instance method of any object in Java

<br/></li><li id='temp:C:VbXd3851c4d19a840fd8b98e412a' class=''>In the ideal <i>unrealistic</i> scenario, every distinct object has a distinct hashcode value

<br/></li><li id='temp:C:VbXacf6a8e20a574ef980286d4cd' class=''>In the real scenario, some objects which are different have the same hashcode which is called a <b>collision</b>

<br/></li><li id='temp:C:VbX80742f675e874f598846e59ca' class=''>Objects that are equal by <code>.equals()</code> have the same hashcode

<br/></li></ul></div>There are strategies to create a hashcode implementation that aims at minimizing collisions. To see more about it, take a look at the class below (credit for the file to our colleagues in CS 1331). This class has an implemented class Vehicle which includes the overridden <code>.hashcode()</code> method which is aimed at minimizing collisions.<br/>

<a href="https://gatech.instructure.com/courses/406950/files/50941137?wrap=1">Vehicle.java</a> <br/>

<h3 id='temp:C:VbX557d04cc8ae945e48c5f31b02'>Other Considerations</h3>

Once we've picked our hash function, we also have three other things to consider: <b>compression function</b>, <b>table size</b>, and <b>load factor</b>. The compression function's job is to shrink and shift the output of the hash function so that it fits into the range backing table (array). This is because for most applications, it's not reasonable to have a table of capacity the largest hash function value. The most common compression function you will see is to simply mod by the table length, though there can be others.<br/>

<br/>

Since the compression function often uses the table size in order to "spread out" our data in the specified range, it's also common to have the table size be a prime number in order to minimize collisions due to compression. There are again, other choices for table sizes, but most often, HashMap implementations will "lazily attempt" to use a prime number for the table length without actually checking if it's prime or not. Another popular choice for table sizes is to use a power of two since it makes the modulo operation more efficient (this is out of scope of the course, but prime numbers are the most expensive for divide-type operations, whereas powers of two are efficient thanks to bitmasks).<br/>

<br/>

Finally, we have the load factor, which is defined as the size over the capacity. This parameter has to do with how high we're willing to let the load factor become before we resize the table, and it varies quite a bit in implementation. It's also very dependent on how we decide to handle collisions. The intuition here though is that as the load factor increases, the table will become inundated with entries, and it becomes more likely for a collision to occur. If we keep the threshold low, then we can almost guarantee 𝑂(1) search times, but we may have to resize more often, and we will use more memory than we may want to.<br/>

<br/>

As you can see, a lot goes into designing a good HashMap. There are countless papers and studies out there looking at what hash functions work best in practice and in theory, so it's a very interesting topic to look at! It also speaks to how important these ideas are; these ideas are quite flexible and general, so they can be applied in data structures other than HashMaps.<br/>

<h2 id='temp:C:VbXce1921469d7d4acaba3f753fc'>External Chaining</h2>

Now begins our exploration into various <b>collision handling policies</b>. These policies can be broadly categorized into two different types:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX39b3329c6d2847c28c341a1e3'><li id='temp:C:VbXa88051b7c9ca4182b7bc3b80d' class='' value='1'><b>Closed Addressing:</b> A policy where all keys that collide into the same location are stored at that location by some means.

<br/></li><li id='temp:C:VbX95210fd01bc74fa8b278e7691' class=''><b>Open Addressing:</b> A policy where additional, colliding keys can be stored at a different location based on the original location.

<br/></li></ul></div>We will discuss one closed-addressing policy and three different open addressing policies. The first policy we discuss is the simplest one in this lesson, <b>external chaining</b>, a form of closed addressing.<br/>

<h3 id='temp:C:VbXdb7f02e4322d4a1db5d6f1ddf'>What is External Chaining?</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXeeb5341b78524085af7bc18c9'><li id='temp:C:VbX402f986b121c4f43968778c57' class='' value='1'>Backing structure: array of LinkedLists → each index can store multiple entries

<br/></li><li id='temp:C:VbXde417bb3b1ec4c3ebcc3ccff2' class=''>“Closed addressing” strategy - entries are put at the exact index calculated (see index 61 in image below).

<br/></li><li id='temp:C:VbX6adcd0dfa4c34cbe8db585763' class=''>For duplicate entries, you need to traverse the entire LinkedLists

<br/></li></ul></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/vuz4pL-vM852llgYqbFMQA?a=xlogQfa5ija0QwpOHsgIznO7LmHbrYFVmBx2ynwyqIUa' id='temp:C:VbXff92ad46292e4e7193d81d7de' alt="Screen Shot 2024-06-11 at 10.05.18 PM.png"></img></div><br/>

<h3 id='temp:C:VbXa3f78e50df0a4538af49a2155'>Resizing with External Chaining</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX852fc5e293e84bc2a0cd2b266'><li id='temp:C:VbXaaceeba1ecb34cec8d1b4aca9' class='' value='1'>When using external chaining, we don’t run out of space.  However, long chains impact runtimes.

<br/></li><li id='temp:C:VbXa5502203180145e68876e8b9c' class=''>Given an backingArray of size 10 and index 0 has 5 K-V pairs as LinkedLists.  Load factor = size / capacity = 5 / 10 = 50%  (Tip: Don’t think of size as indices that are filled, it’s per K-V pairs).

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/UsC8lDUMNaGk-6wfG2Q31g?a=DxsIPq8L6V1JGSxua951JLjlfzK79OakXzQYWdrqqLYa' id='temp:C:VbXed23fe73328b40cb8d76e57b4' width='800' height='238' alt="Screen Shot 2024-06-11 at 10.11.08 PM.png"></img></div><h2 id='temp:C:VbXc7d054331d2043efb5df506f0'>Linear Probing, Example 1 (Adding)</h2>

<b>What is probing?</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX857fa867b8f3476d8b7eccd4f'><li id='temp:C:VbX725ece87f422427f8bf940e36' class='' value='1'>Backing structure - Array → each index can store only <i>one</i> entry.

<br/></li><li id='temp:C:VbX3ca7841ee8f94de08c67e9530' class=''>“Open addressing” strategy - entries may not end up at the original index calculated.

<br/></li></ul></div><b>What is Linear Probing?</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX0e0d8565af1945cdba912e303'><li id='temp:C:VbX58435e97592641e690ac40d36' class='' value='1'>Linear Probing: If a collision occurs at a given index, increment the index by one and check again.

<br/></li><li id='temp:C:VbX96527e3cefb844be8da6557f5' class=''><b><code>Index = (h + origIndex) % backingArray.length</code></b> (h = number of times probed [0 ... N])

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/55tiO8s9QaTm1iSsiJh8mg?a=5BJUw1H4RWg9W1i6rbPSk6HnbkW2V3AfpVzpodR7NbQa' id='temp:C:VbX3fa2185b0bbf447c9e2f03e2b' alt="Screen Shot 2024-06-11 at 10.21.12 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/4_hcRJcTMXA70E3pxKZGdA?a=fRclsOVnFk6AViWlAxZmSYTDmAmsTKKFpmALXhqq6kIa' id='temp:C:VbXdf4d5898684244f7aa8be243d' alt="Screen Shot 2024-06-11 at 10.21.28 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eVqJdba66K-Mu9eLwhmgzQ?a=4vUVX6mrVt0XGX3CM76MuC0htqbiLICAl888HcLRqNoa' id='temp:C:VbX177d4802601140e4a94c83964' alt="Screen Shot 2024-06-11 at 10.21.49 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dB9W_HWoSvMLmX2bOU5Ynw?a=aCceBljyv0qDvMguxDJqIOGyNawtzD8hCoRtHwQCSNQa' id='temp:C:VbXb72837077ab04523b3d923db6' alt="Screen Shot 2024-06-11 at 10.22.25 PM.png"></img></div><br/>

Wraparound technique:  50 ends up at first index (idx + 6 steps % 7).<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LX8Js6aSIgmBKtMYpiqoAA?a=88sDgealdVZifREjyacKcpntmcnEzPqj5TlCG3uQiF8a' id='temp:C:VbX961a29ee7f1a4ee1b7a48df2f' alt="Screen Shot 2024-06-11 at 10.23.15 PM.png"></img></div><br/>

<h2 id='temp:C:VbX16c1072192da47698d17f3cb2'>Linear Probing, Examples 2 and 3 (Searching + Removing)</h2>

The next operations we take a look at are searching and removing from a HashMap. As it turns out, removing from a HashMap doesn't work if we remove items from the array normally. So, we perform what we call is a <b>soft removal. </b> Soft removals are where we leave the entry there, but mark it with a flag to denote that the entry is removed. Such entries are called <b>DEL markers</b>  (some sources refer to them as <b>tombstones</b> ). These are entries that exist in the array in order to assist in HashMap operations, but from the user's perspective, looking at the HashMap as a black box, these entries do not exist at all since the user has already removed them.<br/>

<h3 id='temp:C:VbXa71d803e5dfd43dca0fee7e4c'>Removing from HashMap</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd28221dd29f94ee08382eac95'><li id='temp:C:VbX6c6802c678bb488cbb593106e' class='' value='1'>Move through array and find value to remove.  Pop the value and replace it with a DEL marker.

<br/></li><li id='temp:C:VbX70473848af8a4ed9b4deace17' class=''>DEL markers typically set as a boolean variable at index. We don’t use <code>null</code> because empty array indices are the true nulls.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/bZDWiRBTUZL_A6u-n-mfHg?a=eWccpsaBOtuGgWXQXyPONqXHolsa2MpnSepS65q3mnka' id='temp:C:VbX6f2a0a0a2ece4711bac891983' alt="Screen Shot 2024-06-11 at 10.28.43 PM.png"></img></div><br/>

<h3 id='temp:C:VbX0f68a0c38b2a4dce93efeab60'>Putting into DEL Index</h3>

<h4 id='temp:C:VbX93fd9a04f44c4ec78155378dc'>Probing Scenarios:</h4>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX0abc3cc1277e4d3bb714fa77e'><li id='temp:C:VbX67247a27cf3a4c81bbb95d758' class='' value='1'>Valid (not null or deleted) and unequal key

<br/></li><li id='temp:C:VbX1e4952611fa9444e809cb7462' class=''>Valid and equal key

<br/></li><li id='temp:C:VbX8b88ab04bacc49e89a01d344d' class=''>Deleted (DEL)

<br/></li><li id='temp:C:VbX58741250aaab4cefb5aec301d' class=''>Null

<br/></li></ul></div>Example steps:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX03051a3860ff4f779c4050055'><li id='temp:C:VbX9bd356e72ac849b7990241a8d' class='' value='1'>Start at hashed index of remove value (idx = H(1) % 7 = 1).  Start incrementing index.

<br/></li><li id='temp:C:VbXacaebcbea5a5416f8f0ee8c0c' class=''>Save first DEL index if encountered

<br/></li><li id='temp:C:VbXa64021f6f11d4e8fbd2f60a11' class=''>Continue moving through array to see if value is found.

<br/></li><li id='temp:C:VbX31d669c01efc4ef6baffa68fa' class=''>If not, place probed value into saved DEL index.

<br/></li><li id='temp:C:VbX0ca6c7b5ae944cc2a3e12a796' class=''>If null entry found and DEL index is not encountered, place it in first null index.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BN-vDf78T-xIJkrAGJ3UJw?a=yuWS4UZ4ko6JYVVaVWPQrKQ3rwfvhDFUHHCs6eduaIQa' id='temp:C:VbXf240fd1732494f59b0308c7ca' width='800' height='310' alt="Screen Shot 2024-06-11 at 10.32.15 PM.png"></img></div><h3 id='temp:C:VbX3c8154bc83f047c884a241c82'>Resizing Backing Array (for Linear Probing)</h3>

When backing array surpasses threshold:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX2a8863d94b084d0e89776fa6b'><li id='temp:C:VbX63212032a4f642a09093eeadf' class='' value='1'>Create a new backing array of capacity 2N+1

<br/></li><li id='temp:C:VbX1b9a58dba5df424ba2c7da2bd' class=''>Loop through old backing array

<br/></li><li id='temp:C:VbX7773fac1257845f5a3b695ebb' class=''>Rehash all cells to new backing array

<br/></li><li id='temp:C:VbX234160e726914ae686f2b0d4f' class=''>Skip over all DEL markers. They no longer serve their purpose.

<br/></li></ul></div><h3 id='temp:C:VbXa6615809b64d451bab6a0987c'><b>The Efficiency of DEL Markers</b></h3>

One question to keep in mind, as you consider the use of DEL Markers for removing, is how these DEL markers impact efficiency. The put/remove/search operations all have termination conditions for whether the key is found in the map or not. If the key is in the map, then all is well. However, the more complex problem is when the key is not in the map. There two termination conditions for when the key is not there, whichever comes first:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX8d9630dbee4c49e59a37413f9'><li id='temp:C:VbX1d90a7652d9144878d2302cb1' class='' value='1'>We find a null entry in the table to tell us to stop searching.

<br/></li><li id='temp:C:VbXcc0300b1c11d442c80e123582' class=''>We probe for <code>table.length</code> times, meaning that we've checked every spot in the table already.

<br/></li></ul></div>The second case is especially pathological, but it can in fact happen even if the Max Load Factor threshold is set reasonable. As an example, suppose we have a table of length 13, and one by one, we add and remove the keys <br>0,1,…,11,12 from the table. This leaves us with a final table of size 0 with no null entries, all while never having the load factor be larger than 0.08. This configuration is terrible because it guarantees that any put/remove/search is guaranteed <br>𝑂(𝑛) performance; just goes to show that <b>DEL Markers worsen the efficiency of our operations</b>. This is also why when we resize, we get rid of any DEL Markers in the process.<br/>

<br/>

There are ways to try to avoid this, such as including DEL Markers in the load factor calculation, or triggering an intentional resize or reconstruction of the table if we know beforehand we'll be removing a lot. We won't be delving into more detail than this, but it is worth keeping in mind the cost that DEL Markers have on performance.<br/>

<br/>

<h2 id='temp:C:VbXf164289ef76d4acf9f70290a0'>Quadratic Probing</h2>

Previously, we saw the most basic of open addressing techniques, linear probing. If you do some examples with it, you will find that linear probing has the problem of developing contiguous blocks of data. These blocks of data can be problematic as they get larger, because any search for data in these indices will necessarily continue until we hit the end of that block.<br/>

  <br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/OREoAiJeBkwu1leKjTIl7Q?a=oYCypoobPr4YCO2IYzrqE4YXB1smidEtADim7Ujs59Ma' id='temp:C:VbXf330f0a41b8c4f94b16225a67' width='800' height='92' alt="image.png"></img></div>For example, in the diagram above, indices 3 - 7 are occupied by either data or DEL Markers. If a put/remove/search operation occurs at any of these indices, then the operation continues until it reaches index 8, the green cell, giving a degenerated linear performance. This problem is known as <b>primary clustering</b> (or <b>turtling</b>), and the effect can be mitigated by <b>quadratic probing</b>, which is seen in this lesson.<br/>

<h3 id='temp:C:VbX5d85275fc0b54e089caaa00b3'>What is Quadratic Probing?</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX6e55b81354354f808df5bc0c4'><li id='temp:C:VbXe8697235f0994ee493d0bb083' class='' value='1'><b>Quadratic Probing: </b>If a collision occurs at a given index, add h^2 to the original index and check again.  Why? Breaks up clusters created by linear probing.

<br/></li><li id='temp:C:VbXd88e54ad647a4769b7095b8f7' class=''><code>Index = (h^2 + origIndex) % backingArray.length</code> (h  = number of times we've probed [0 ... N]).

<br/></li></ul></div><h3 id='temp:C:VbXa048cd0cbf5f4982b13ba0706'>Example 1</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sjbNUzkpwwycCvIkvhOekQ?a=Rw8ZaGhHSZCKi430W7V9qmnnGy96BmCvjgly9gl26IEa' id='temp:C:VbXe8b81fbd462b4f1fab061a153' alt="Screen Shot 2024-06-11 at 11.00.19 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/teSOqpQDxKNaF8ZsMmsfmQ?a=s2E4JZ02aWao02mTpkWrRLBuftCIgssk9as8JbkaGQga' id='temp:C:VbX15cb032b71cc44a9b2a31d5d9' alt="Screen Shot 2024-06-11 at 11.00.41 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/auMjzxlq_AVIp6hoeQgEBA?a=Ra7ubt1TvxFSzosppB6ez4Ava1NtdhV6Z2Hy2aejs5ga' id='temp:C:VbX9f1d15ddcb59466eb5fdaa879' alt="Screen Shot 2024-06-11 at 11.01.09 PM.png"></img></div><br/>

<h3 id='temp:C:VbX66acf7c4cf154b9f8ee0dd66c'>Solutions to Infinite Probing</h3>

What happens when quadratic probing keeps finding occupied indices (<b>infinite probing</b>)?  (See value 22 in Example 1)<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa8f285c17f584c6b84c6f87f4'><li id='temp:C:VbX21a167b5c1ad4ce0b00bb853d' class='' value='1'><b>Solution 1:</b> Continually resize until a spot is eventually found

<br/></li><li id='temp:C:VbXaa57d7c10159483f8e58173c5' class=''><b>Solution 2:</b> Impose a set of conditions on the table to ensure that this scenario never occurs.

<br/></li></ul></div><h3 id='temp:C:VbXb830a00780b740ca889b55ab0'><b>The Complexities of Quadratic Probing</b></h3>

As we saw in the video, while quadratic probing is a simple modification of the linear probing schemes, it brings with it some more complexities and complications with it. For one, it was proposed to solve the problem of primary clustering, but quadratic probing suffers from something called <b>secondary clustering</b>, which is where keys belonging to different indices collide in quadratic steps rather than linear ones. It isn't as obvious as in linear probing since there isn't a huge block of data, but it does still exist.<br/>

<br/>

The most pervasive issue of quadratic clustering is the infinite probing issue seen in the video. There are two approaches to this problem:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX6e292e4489694fb79edcb4682'><li id='temp:C:VbXac4b71be7cb346db9ffa7dbad' class='' value='1'>If <code>table.length</code> probes have been made, but a spot still hasn't been found, then resize the hash table and try again.

<br/></li><li id='temp:C:VbXa04938a9322d474fbc0c4df58' class=''>Construct the table so that infinite probing will never occur.

<br/></li></ul></div>The first one is a natural solution to the problem, but it's not without its potential issues as well. A resize operation will involve rehashing keys into a new table, but rehashing can again cause the infinite probing issue. There are some pathological cases where you can setup resizes within resizes, nested however many times you like, though this is quite rare.<br/>

<br/>

The second option will have to be a bit mysterious since a number theory background is not a prerequisite for this course, but some hashing schemes can eliminate the infinite probing case entirely. For example, <b>if we enforce that our table length is a prime number, and we maintain a max load factor of 0.5, then we can guarantee that it will not happen</b>.<br/>

<h2 id='temp:C:VbX42414257f3ad4edd87a748296'>Double Hashing</h2>

<h3 id='temp:C:VbXf3da970ceacf49d2b9597b9e7'>What is Double Hashing?</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe16697cedc5e489eaed057f3b'><li id='temp:C:VbXa0df685dee8a459b851a9db80' class='parent' value='1'><b>Double Hashing: </b>If a collision occurs at a given index, add a multiple of <code>c</code> to the original index and check again.

<br/></li><ul><li id='temp:C:VbXaf2969a0d97345959caeb6188' class=''>Why? Breaks up clusters created by linear probing

<br/></li></ul><li id='temp:C:VbX7d2ab8856c2248558126c9f40' class=''><code>Index = (c * h + origIndex) % backingArray.length</code>  (h= number of times we’ve probed)

<br/></li><li id='temp:C:VbXddbfabbb39884cadbb152a26b' class=''><code>c = result of second hash function</code> (linear probing if c = 1)

<br/></li><li id='temp:C:VbXb261b9bbcc814ba4945834ab0' class='parent'>Hashing strategy:

<br/></li><ul><li id='temp:C:VbXbcd1d980b1e94c2d8db751e88' class=''>First Hash: H(k), used to calculate origIndex

<br/></li><li id='temp:C:VbX23d47c4ca7f048d9aec6aaf24' class='parent'>Second hash: D(k), used to calculate probing constant.

<br/></li><ul><li id='temp:C:VbXe410dcd640504bd7ade73fde3' class=''><code>D(k) = q - H(k) % q</code>

<br/></li><li id='temp:C:VbX180a7441da5845bbb88ddb29e' class=''>q = some prime number, and q &lt; N

<br/></li></ul></ul><li id='temp:C:VbX0a8269c133744f129be8757fc' class=''>Delete flag still required when removing.

<br/></li></ul></div><h3 id='temp:C:VbXbec3cefe3ba7439dbf5b9a8d6'>Example 1</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9gNgF8kt4TAPli6xEK_Gpw?a=wLMmm1fzGL6xIFaDccg0NwBMdkrUv91k1hRaqYmUn3Ua' id='temp:C:VbX9f7dc1f601464befbdaddd26d' alt="Screen Shot 2024-06-11 at 11.27.29 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ArR435Z7MmvS7SKZjpL3EA?a=hzJgS7BI7gStLULWhMhb7MEFQsejG45TJazC4RC8niwa' id='temp:C:VbX96c056aaf9e04ca28b7e4b095' alt="Screen Shot 2024-06-11 at 11.27.51 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/AwtkLCD1DHjmj23XsFH1JQ?a=czT663yNjAQov6DPKsuWqaraAnlK8eEcH21c85LpXOMa' id='temp:C:VbX95d6ade5ca8f47b6b6525d889' alt="Screen Shot 2024-06-11 at 11.28.14 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/leSqpuNGypVp7CTwd91nBg?a=EbSDh57vsBDVz5CuAH4sFurQ8fjJZXxDt9IuOFefYSAa' id='temp:C:VbX12d6b1efab6b44c6ba5b2d2cf' alt="Screen Shot 2024-06-11 at 11.28.43 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/T_LdAUqMMfOi1AjfGzUSTg?a=AxOEvdYChaeeH40A43CVlmOgkF2DoFK0m1wgljeFq2oa' id='temp:C:VbX46764975e6ac4a169033a5060' alt="Screen Shot 2024-06-11 at 11.29.27 PM.png"></img></div><br/>

<h3 id='temp:C:VbXfc5bfc54420b461ba29195a03'>More thoughts on double hashing</h3>

As we saw in the example, double hashing can be a powerful framework, so long as it is implemented carefully and efficiently. With a good secondary hash function (one that spreads out the keys and is relatively independent of the primary hash function), even pathological cases where we have many collisions can be prevented unlike linear and quadratic probing.<br/>

<br/>

We would like to make a few remarks that are a bit more subtle, some of which are out of the scope of the course before moving on:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX3e64ca21adbd43d2bf59d371e'><li id='temp:C:VbX4da061f993364d73a32f363b6' class='' value='1'>Linear probing is a special case of double hashing, but quadratic probing is not. The secondary hash function depends on the key as input, whereas if we wanted the same effect as in quadratic probing, we'd need the probe count as the input. The takeaway here is that <b>the secondary hash function is truly a hash function since it's only input is the key, not the probe count</b>.

<br/></li><li id='temp:C:VbX741b5ebc31b643ceb5e47749f' class=''>Double hashing might be more computationally expensive than the other strategies depending on what the secondary hash function is. At a low level, computers often have specialized instruction sets that do things like incrementing (which we'd use in linear probing), making those strategies faster if collisions aren't that pathological.

<br/></li></ul></div>This brings us to the end of the collision strategies we'll be covering in this course. In the next lesson, we'll be doing a wrap-up to help compile all the things we've discussed in this module!<br/>

<br/>

<h2 id='temp:C:VbXd28c16179c944b1e817840832'><b>Collision Handling: A Summary</b></h2>

We've covered a lot of ground in this module, the basics of HashMaps, in addition to the four different collision handling strategies. We presented them in the following order: external chaining, linear probing, quadratic probing, and double hashing. This ordering was chosen for two reasons: (1) we went from simpler concepts to more complicated concepts and (2) we went in (rough) order of popularity.<br/>

<br/>

In practice, you will mostly see external chaining and linear probing (or some variation of them). External chaining is very nice because it is an extremely simple idea. If there are multiple collisions, then just attach the new item to a chain at that index. The primary reason you would not want to use it is something we discussed a while back, <b>locality of reference</b>. Computers are designed to access adjacent/nearby memory locations quickly, which the open addressing schemes can take advantage of. On the other hand, external chaining necessary involves dynamic allocation for the chaining, so it cannot take advantage of this. Linear probing is the simplest scheme to take advantage of this, so it's another popular choice.<br/>

<br/>

So, what about quadratic probing and double hashing? We made a few arguments for why they might be useful in their respective lessons, but now it's time to discuss why they might not be very popular.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX082649e9ab214eecb758cd26f'><li id='temp:C:VbX594197e8d7104d75aff7de95c' class='' value='1'><b>Their implementations can be tricky and need to be done carefully.</b> We've had semesters in the past where students implemented quadratic probing. If you ask one of them what the experience was like, they'll probably respond negatively, and for good reason! These schemes can be efficient in terms of collision handling, but their complicated implementations make them unlikely to be used in practice.

<br/></li><li id='temp:C:VbX50d2ada1f23543818092ed247' class=''><b>Aim to avoid collisions, not how to fix them.</b> We mentioned this previously, but it's important, so we'll say it again. If you are running into cases where you have lots of collisions, then you're not using HashMaps correctly! The <br>𝑂(1) performance of HashMaps happens when there are few collisions, not when we have many collisions. So, if you have lots of collisions, work on the hash function and table sizing rather than the collision strategy.

<br/></li><li id='temp:C:VbXb96e797c24294ac98e873e6b1' class=''><b>The number of collisions is not everything, much happens at a lower level.</b> For example, incrementing is an instruction that is used very often, so computers are optimized to do them very quickly. Arithmetic like multiplication and modulo are also relatively fast, but they're still slower than incrementing. Another example is the idea of locality of reference we mentioned above. Quadratic probing and double hashing "skip" around the array unlike linear probing. So, while they still get a speedup since the memory locations are "close," they're not "adjacent" like they are in linear probing, so it's not as good of a speedup.

<br/></li><li id='temp:C:VbX26a97f79492d4917bc66cfa33' class=''><b>Configuration of the table might be constrained to avoid the infinite probing problem.</b> Both quadratic probing and double hashing can run into the infinite probing problem if not implemented carefully. If you try to implement it in a way to completely avoid this, then your table length needs to be a prime number. In quadratic probing (and in some cases of double hashing), your max load factor is be no more than 0.5. These are rather non-trivial constraints! Putting aside the problem of finding a suitably large prime number as well as resizing, a max load factor of 0.5 means that you have to allocate an array where half of the space is never used, which can be a non-starter in many contexts.

<br/></li></ul></div>Hopefully this helps conceptualize the different collision strategies, giving you an understanding of what techniques are out there, and why they are (or are not) used in practice. If you're a theory-oriented student, you might find the theory of <a href="https://en.wikipedia.org/wiki/K-independent_hashing"><br>𝑘-independent hashing</a> interesting. This concept analyzes the contexts in which we can guarantee 𝑂(1) performance (at least in expectation).  But enough theory-crafting, let's take a look at what some popular programming languages use in their standard implementations for HashMaps.<br/>

<h2 id='temp:C:VbXf0e7bec11019440ab370e1c21'>Food for Thought: What do actual programming languages use?</h2>

Let's look at three different languages that have some standard implementations: Java, Python, and C++.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb6020537d8ac4ed8941a879a9'><li id='temp:C:VbXf5046efb87604a8b99d25c597' class='' value='1'>Java's implementation is the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>, which uses a variation of external chaining. It starts off with external chaining, but if a chain reaches a certain threshold in size, then it will instead use a balanced BST (we'll cover self-balancing BSTs in the next course), sorting based on the hashcodes and the natural ordering imposed by Comparable if implemented. This threshold approach is used because for small chains, the overhead of a BST is not worth it since the performance costs are similar for small 𝑛. The max load factor is by default 0.75.

<br/></li><li id='temp:C:VbX29a73560b6b04996870419ed2' class=''>Python's equivalent is the dictionary. There are variants, so let's look at the <a href="https://hg.python.org/cpython/file/52f68c95e025/Objects/dictobject.c">CPython implementation</a>. This implementation uses a variation of an open addressing strategy like linear probing. It's difficult to describe in detail without getting into the nitty gritty, but it uses a linear recurrence (rather than just incrementing like in linear probing) to determine the probe sequence. Then, it adds a "perturbation" to the recurrence to change how it probes for common failure cases. The table also uses powers of two rather than prime numbers, and the max load factor is 2/3. The link above is worth taking a look at if you're interested; the documentation gives some interesting commentary on the design decisions made in the implementation.

<br/></li><li id='temp:C:VbX9d3575d25a2849d285e49dfdc' class=''>For C++, we have the <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/">unordered_map</a>, which uses external chaining. An interesting thing about this is that the max load factor defaults to 1.0, which is a nice reminder that external chaining is the only strategy we've seen where the load factor can exceed 1.

<br/></li></ul></div>Just looking at these three implementations gives us some interesting strategies and design choices made by the developers, which reminds us that these strategies are not set in stone. It's also good to note that these designs and standards can change over time, so it's possible these will change with more data and later version numbers.<br/>

<h2 id='temp:C:VbX4cff9f4503a0464fa353e18aa'>Food for Thought: A Hashing Application: Bloom Filters</h2>

The only example of a hashing based data structure/algorithm that will be seen in this course sequence is what has been covered thus far for HashMaps in this module. However, hashing is a very popular and flexible idea which is used in many different applications. We would be remiss if we did not look at any of these applications. Let's take a brief glimpse at a data structure that uses hashing, <b>bloom filters</b>.<br/>

<br/>

We want to set the scene first to motivate bloom filters. Suppose we are given a database that hosts a lot of tagging information. This database takes in some text input, then it returns, say the first 10 results with that tag sorted by some metric, back to the user. This database is hosted on some server that is relatively far away from you, and your internet speed is slow.<br/>

<br/>

In this context, performing a search can be an expensive operation (the delay to send search request, search the database, and receive the reply may take a while). We would like to avoid sending the request if the search would yield 0 results. Is this possible without hosting the entire database closer to you? The answer is yes! (But you knew that already didn't you?)<br/>

<br/>

Rather than answering the question of "Is this tag in the database?" correctly all the time, what if we allow incorrect answers rarely? More specifically, let's say we allow <b>false positives</b>, which is when the tag is not in the database, but we incorrectly output that it is. A bloom filter does precisely that.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/khISo8-0LHkuKy989Ecn4Q?a=VbeLu5YIcx2BtOTrSzpr2j7kyaQvflv0tQqE0xDU9pYa' id='temp:C:VbX38b1359cdf2b4a659f7b33e5b' width='800' height='314' alt="image.png"></img></div>  <br/>

In the flow chart above, we have three possible outcomes. If the bloom filter returns no, then we can be sure the answer is correct. If the bloom filter returns yes, then it could be wrong, so we will go ahead and send the search request. In the true positive case, the actual cost is high, but that cost was necessary, so the opportunity cost is low. In the false positive case, the actual cost is high when the search was not necessary, so the opportunity cost is also high. If we can make false positives rare, then on average, we'll be sending requests mostly when necessary, and not sending requests for most negative answers, which is good!<br/>

<br/>

How does a bloom filter achieve this? Why, hashing of course! Since our database is very large, we don't want our backing table to actually store 𝑛 items for our bloom filter. Instead, we'll have use a bit array of length 𝑚 where 𝑚 can be set independently of the number of items, and the array starts with all entries as 0. Additionally, rather than one hash function, we'll need 𝑘 hash functions (again, 𝑘 can be set as you want). To make things more precise, these hash functions are ℎ1,…,ℎ𝑘, where ℎ𝑖:𝐷→{0,1,…,𝑚−1} for all 𝑖=1,…,𝑘, and 𝐷 is our data space.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/x_ZkqKWy8DxmaePXxRBMMw?a=NAG6vhmnpCHfiM5artvAJDkxKKTIbOuJ1wmfpcs4nG8a' id='temp:C:VbX10d9937a089a41c18f6d1db26' width='800' height='312' alt="image.png"></img></div>  <br/>

When adding a new tag to the database, we compute the 𝑘 hash functions for the tag, then we set all of those indices to 1. For querying to see if the tag exists, we compute the 𝑘 hash functions, and we check if all of those indices are 1. If any are 0, then we know for sure the tag isn't in the database. If they're all 1, then it's possible for a false positive since an index could've been flipped to a 1 bit due to a different data. Removing from a bloom filter is possible, but it requires other modifications.<br/>

<br/>

We won't go into performance here, but with the proper setting of 𝑚 and 𝑘, along with well-chosen hash functions, bloom filters do a very good job with less than a 1% false positive error rate. Hopefully, this demonstrates to you just how powerful and flexible an idea hashing is!<br/>

<br/>

<h2 id='temp:C:VbX141b91c4c4154a259d3a4129c'>CS1332 - Secure Computing Considerations</h2>

<b><span style="color:#236fa1" textcolor="#236fa1">Deletion versus Purging &amp; New Memory Acquisition</span></b><br/>

<i>Associated with Module 1: Arrays and ArrayLists</i><br/>

The most basic operations for many of our data structures involve adding elements, accessing those elements, and (eventually) deleting those elements. Many of our students don't realize that many complex systems often "delete" data elements simply by removing the user's ability to access those items through the normal interface, while the actual data still resides in memory. Since the actual data might be sensitive, then it's important to understand the difference between deletion (i.e., simply removing access) versus purging as deliberately overwriting and/or modifying the sensitive data so that it is effectively unreadable if accessed later by unauthorized parties. This can be demonstrated in many of our homework assignments where we require the students to overwrite the to-be-deleted values before modifying the access structures themselves. We could further expand on this by having the students measure the increased number of steps needed to effect purging versus deletion, and discuss how this impacts the overall efficiency of the data structure operations.<br/>

<br/>

This can also be tied into the acquisition of new memory. In many cases, a request is made to the operating system when new memory is needed. One example is the Java Memory Model, where <b>new()</b> requests return a reference to a block of memory with the requested size, but only if such a portion of memory is free. From a security and functionality perspective, it's important to ensure that a new block has actually been assigned before attempting to dereference the results. Also, the Java Memory Model normally purges any potentially sensitive data by overwriting the contents of the portion of memory being returned with zeros.<br/>

<br/>

<b><span style="color:#236fa1" textcolor="#236fa1">Pointers and References</span></b><br/>

<i>Associated with Module 2: Pointers, References &amp; Singly Linked Lists</i><br/>

We make a general distinction between pointers and references. Pointers refer directly to locations in memory. In languages (i.e, C) that allow use of "generic pointers", the flexibility of being able to dereference arbitrary memory locations also allows potential misuse by programs and processes that (attempt to) access memory locations for which they are not authorized. Some languages (e.g., Java) don't support this "generic pointer" approach, and instead provide references. With references, only three general types of operations are allowed: (1) an object reference can be assigned "null", which effectively means that there is not any reference being made to a valid object; (2) an object reference can be assigned to a new() object, where the operating system creates the new instance of the object in memory (barring any exceptions or other anomalous conditions); or, (3) an object reference can be assigned to an another existing object reference (normally of the same type), such that the object will then have two or more references (i.e., "aliases"). The intent of references is to avoid some of the security- and memory management-related problems of allowing generic pointers.<br/>

<br/>

<b><span style="color:#236fa1" textcolor="#236fa1">Hashing</span></b><br/>

<i>Associated with Module 6: Introduction to HashMaps and External Chaining (Closed Addressing)</i><br/>

We use the term "hashing" to define the general process of using some set of mathematical transformations (e.g., formulas) to convert the value of an element (i.e., "key") into the address where that key should be stored for later access/lookup. We will discuss how the term "hashing" is also used to refer to a different set of transformations for a given element. More specifically, users are often advised to "check the hash" of a file that they've downloaded to ensure that file's authenticity. In these cases, a hash function is used to generate a "signature" for the given element, which is often a file, and where the file is often significantly larger in size than a key. Also, the desired properties of the "security-based" hash result are different. For the "addressing-based" hash formula, the main concern is generating as much of a uniformly distributed set of addresses as possible, to ensure that elements are distributed as evenly as possible across the address space as possible to minimize collision effects as well as the average access/lookup times. For the "security-based" hash formula, the main concern is that the hash result should be extremely sensitive to any changes in the file, and yield a (clearly and distinctly) different result if the file's contents have been modified. Given that many Computer Science terms are "overloaded" in practice, it would be worthwhile for students to recognize this distinction in usage.<br/>

<br/>

<b><span style="color:#236fa1" textcolor="#236fa1">Randomness</span></b><br/>

<i>Associated with Module 7: SkipLists &amp; Probabilistic Data Structures</i><br/>

The algorithms that we study are mainly deterministic - each step of the algorithm leads to a single, distinct set of changes to the computation state. We will discuss how the properties of randomness can be leveraged in the implementation of various algorithms (e.g., Skiplists). From a performance standpoint, the randomness can be used to ensure that the elements being stored are distributed to across the data structure to support a relative fast O(log n) access/lookup time.<br/>

And from a security standpoint, the use of randomness makes it significantly more difficult for an adversary to insert elements into the data structure in a way that will deliberately degrade the performance. For example, inserting elements into a Binary Search Tree (BST) structure in sequential (or reverse sequential) order will cause the access/lookup performance of the BST to degrade towards that of a list-like structure - from O(log n) to O(n). Similar "attacks" against a Skiplist, however, would be unsuccessful.<br/>

<br/>

<h1 id='temp:C:VbXfb368b002a514314989b2235c'>M8 - AVLs</h1>

<b>Module Overview</b><br/>

<br/>

The biggest drawback that we encountered for BST operations was that the height of a BST can degenerate to<br/>

due to imbalance in the tree. We left the idea of a "balanced tree" intentionally vague back then because there are different ways to define balancing.<br/>

<br/>

In this module, we'll be covering a sub classification of BSTs called a AVL Trees, which are self-balancing trees. The name of the tree itself comes from its creators Adelson-Velsky and Landis. AVLs formally define what a "balanced tree" is, and they impose the additional restriction that by the end of any operation, the tree must remain balanced. For us, we'll be looking at how this applies to the add and remove operations specifically, and how the pointer reinforcement technique helps us implement the needed mechanisms (known as rotations) in a clean and intuitive way.<br/>

<br/>

<b>Learning Objectives</b><br/>

<br/>

Students will:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7daadfd0d8554a279f312f81e'><li id='temp:C:VbXcef4a91de69d41efb373c32e9' class='' value='1'>Refresh their knowledge of BST operations as well as pointer reinforcement, a technique to implement simple modifier operations cleanly.

<br/></li><li id='temp:C:VbX0ef043c03f144109ad115390f' class=''>Gain familiarity with how AVL trees formally define their balancing scheme along with what a balanced tree is/is not under this definition.

<br/></li><li id='temp:C:VbX8171dc1d7da4432f890b514da' class=''>Learn about the various rotation types of an AVL, and how these rotations fit into the general add/remove operations of a BST.

<br/></li><li id='temp:C:VbXa9e132c791c44b2d9c06e296f' class=''>Better their maturity of recursive concepts by implementing rotations using pointer reinforcement.

<br/></li></ul></div><br/>

<h2 id='temp:C:VbX5f8c8cc4e2414aff8447d0b97'>Intro to AVLs</h2>

Now, we can begin to explore AVL trees by looking at how we define the structure of an AVL. Since AVLs are a sub classification of BSTs, they share the same order and shape properties. However, AVLS have an additional shape property to restrict the height of the tree. Let's take a look at how AVLs define balancing through the concepts of heights and balance factors.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/KNzVO8nQA7LtdVGPDkJK7Q?a=ipN1T6vPx2f5MEsCeu2RwINipf7l6aM37I91azaK6kga' id='temp:C:VbX726f130f42c54d71aa2e8fd6d' width='800' height='334' alt="Screen Shot 2024-06-17 at 10.51.58 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mLoaW0T_6eT3e-UEBe0pLQ?a=BKZeK3bRe0KJaqIcC6Vsz8a0K8ygJakXkaiAumuYsnka' id='temp:C:VbXbce1b57d723b4e2f986923dac' width='800' height='360' alt="Screen Shot 2024-06-17 at 10.53.51 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/aBZzAzMDr1Ptc8dZ3N6jSg?a=xrTsJDqESWGvD0P4K3WlZNhtOVjz0nmBq3GGdBs0pU0a' id='temp:C:VbX85826b0dbfed406da5e84d1d0' width='800' height='363' alt="Screen Shot 2024-06-17 at 10.54.33 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ImgU1hFVTRbnmrFoKQxQJw?a=LOd1VhfX1OYkUYPaX2GeZWongYRcZE9cwutsI7lMMhsa' id='temp:C:VbXa7999340011f4219a031906a4' width='800' height='299' alt="Screen Shot 2024-06-17 at 11.00.26 PM.png"></img></div>Tips:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX4a078e6618f940689ae30d3b4'><li id='temp:C:VbX4ec5adeba2504ec3b0cfcaf46' class='' value='1'>You never need to use children’s balance factors.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FG-_tIF7IrRebUmUO6DsHg?a=umfJTLaf66HI5SfQ0MbqQluBr6oE3bgot0CPJ28L7wwa' id='temp:C:VbXfb73317e0d234fdf8f376cc0f' width='800' height='377' alt="Screen Shot 2024-06-17 at 11.01.22 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX831596873a4947888c476092d'><li id='temp:C:VbX69a068a8661b4821ab97c600f' class='' value='1'>Leniency (-1, 1) is there because a perfectly balanced binary tree is rare.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/jTL1amtqOxSq7OlKLZQ16g?a=QhXPoKI3fYDWf9268hsEppYLBQQsOEQi420RIEzqdXMa' id='temp:C:VbX0491e6da66a24a56a78eea0b3' width='800' height='355' alt="Screen Shot 2024-06-17 at 11.02.10 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXb7c09971ec944b27a4245590a'><li id='temp:C:VbXf7eaf619eee2423a9e4fd1cd8' class='' value='1'><b>Positive BF means node is left heavy, negative BF means node is right heavy.</b>

<br/></li></ul></div><h3 id='temp:C:VbX58c9f6349c404db583ae1e7ee'><b>The Definition of Balanced for AVL Trees</b></h3>

In the video, we saw that <b>balanced trees</b> for an AVL satisfy the following definition: <br>|node.balanceFactor|≤1 for every node. We also saw a brief justification as to why we chose 1 rather than 0. There are many configurations where it's just not possible to have a perfectly balanced tree. For example,<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YWsN4sz8p7PPtr6KpitEzA?a=n34aAvRMHCAAtULDXmWQqpJEdDzvhiitgBVlVt1vcJ8a' id='temp:C:VbX599abe9825bd43cab7b6a4708' width='800' height='341' alt="image.png"></img></div>  <br/>

As we see in the diagram above, we have a perfectly balanced tree with 𝑛=3 (<i>it's so beautiful!</i>). However, this configuration can only happen when 𝑛 is of the form 𝑛=2𝑘−1. Obviously, by adding one more data leads to an unbalanced tree in some way. Thus, we must accept <i>some</i> imbalance in the world of AVLs. The goal is to minimize the sum of the depths of all nodes, which in turn minimizes the imbalance encountered in the tree.<br/>

<br/>

In the diagram below, we add 2 to the original tree. The tree on the left is BST. However, by including the balance found in AVLS, it leads us to the tree on the right.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/PgWb6nKGuIDaljsGdsW2Ew?a=RLWHFQkXh47zACvghrNaD6DjkzPIuu8MN05K0oPVYrYa' id='temp:C:VbX9f152d8c6c49464fbdc5af859' width='800' height='528' alt="image.png"></img></div><br/>

  <br/>

There you go! <i>Perfectly balanced, as all things should be.</i> But wait. <i>At what cost?</i> We got a perfectly balanced tree by minimizing the sum of the node depths, but look at what happened. All the data noted in red are data that moved while maintaining the order property of a BSTs. The balance process made a single add operation, an 𝑂(𝑛) operation, just to update the tree, which is exactly what we were trying to avoid in the first place.<br/>

<br/>

So, maybe minimizing the imbalance isn't the <i>best</i> thing to do. If we <i>tolerate</i> a little more imbalance, then we begin approaching the definition of balanced for an AVL. <b>AVLs allow the depths of leaves to differ by at most 1</b> (which is what the balance factor definition says). If we "lazily update" by adding to the natural spot in a BST, then we can significantly save cost because updates will not occur as often. When an update does occur, it will be very efficient as is shown in the next lesson. AVL trees hit that sweet spot between allowing some imbalance while keeping operations efficient. It can in fact be shown that the height of an AVL tree is at most 1.44 log⁡(𝑛), which is a pretty tight tree!<br/>

<h2 id='temp:C:VbX4277a31689104ff2a0955750a'>AVL Single Rotations</h2>

<h3 id='temp:C:VbXf40886ab75324a9ea0d8bd666'>Properties</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXdcd4f94503404a10a13e0e6fe'><li id='temp:C:VbX3bf8acb1332c497d80b0905b7' class='parent' value='1'>Left rotation: Node BF is -2, and right child has a balance factor of 0 or -1.

<br/></li><ul><li id='temp:C:VbXf93ee8be8ac74bca9056ec43f' class=''>Result: the top node becomes the left child of the middle node.

<br/></li></ul><li id='temp:C:VbXd670d99005934472ba58010df' class='parent'>Right rotation: Node BF is 2, and left child has balance factor of 0 or +1

<br/></li><ul><li id='temp:C:VbX09228e2e089b41f1a6bcd97a6' class=''>Result: the top node becomes the right child of the middle node.

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/l2KtKNAnP_BmX8DPN7qwPA?a=PXptsjWYV2LLuSkfTNvVXOt3VubqTRHaBYBFzO4dLSwa' id='temp:C:VbXbfc4708ed49c4867bdb79b224' width='800' height='355' alt="Screen Shot 2024-06-17 at 11.06.42 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5kG15A30PK_UgRFcKyrt3Q?a=vhf5SQ2r40SmPuuqTZ72ZRBpG4Ohsl3XBs3NvjHR7VIa' id='temp:C:VbX044e173a092f4a78b48db9d7f' width='800' height='356' alt="Screen Shot 2024-06-17 at 11.09.57 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/S-bcFW3JDGQrO7ZeofjwAA?a=8aVOCIauYni0QLMjma135fwtGl9Kf6m4hamGoAyqeKQa' id='temp:C:VbX48d50a1651414b4b8add1f19d' width='800' height='324' alt="Screen Shot 2024-06-17 at 11.06.56 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/khHzQlpVIYOCZ5R6H_bfQw?a=sOY3LL3Hw9nVODgsuW2OGR05J0SQkrILQxh7nnVFa7sa' id='temp:C:VbX173459aad8c242e8b7e95faa9' width='800' height='326' alt="Screen Shot 2024-06-17 at 11.10.24 PM.png"></img></div>Tips:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX491325686e0f4bb98ea6e2921'><li id='temp:C:VbX0df0a92ceeeb48209a9387f29' class='' value='1'>You must always update the height &amp; BF of the former parent (e.g. node A) before doing the same for the new parent.

<br/></li></ul></div><h3 id='temp:C:VbXba332e14f975409ea82b99729'>Rebalancing after removing a node</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX78870801c8f3478daa5547694'><li id='temp:C:VbX026590f260634a318464b1176' class='' value='1'>Use standard BST method to remove a node and repair links

<br/></li><li id='temp:C:VbX6534e9f1beb74a8b879bcdd1b' class=''>Update BF of its parent.

<br/></li><li id='temp:C:VbXd9451c415f034341b8e4f6dd4' class='parent'>Determine is BF is imbalanced (bf &gt; 1 or bf &lt; -1) and needs to left/right rotate.

<br/></li><ul><li id='temp:C:VbX905e4509a1d243a38d7569837' class=''>bf &lt; -1 = left rotation

<br/></li><li id='temp:C:VbX19733384b9514626a01d38a88' class=''>bf &gt; 1 = right rotation

<br/></li></ul><li id='temp:C:VbXdf92f12d7d7548a394fc453a3' class='parent'>Apply rotation.

<br/></li><ul><li id='temp:C:VbX56e5d71332544bcb9385e2180' class=''>Set parent node’s left/right pointer to child node’s left/right child (depending on rotation method)

<br/></li><li id='temp:C:VbXa1ba6aadee724f568337544ab' class=''>Set new parent node’s left/right pointer to former parent node

<br/></li><li id='temp:C:VbXe91b93570e13487b93d6a3ef5' class=''>Update height and BF of affected nodes.

<br/></li></ul></ul></div>Tips:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX057469379a424594b294c4caf'><li id='temp:C:VbX25eb5490227042abb60d4ab39' class='' value='1'>Keep in mind when updating 2 child cases, you may need to update and possibly rebalance on the way back up the predecessor or successor node.  Doing this ensures a balance as we bubbled up the tree.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eVGh1eX-_O8J5QkjCvAw6A?a=RtvCz2CSkmqcRlNphYSmLAdP4SONVqPrjNvwqn1l39Ua' id='temp:C:VbX9411d38dfbe04da892aec38ad' alt="Screen Shot 2024-06-17 at 11.14.08 PM.png"></img></div>Step 1 - Remove node 1, update BF and Height of parent.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/2G9Txl-b8huaLy3RC_wQ6A?a=eaTEF7kJ8fuJaKfGWwBlfz3LMlUWdEhnJhsSjZcXaCQa' id='temp:C:VbXdf6b9a1e979a4d4ca298e23b7' alt="Screen Shot 2024-06-17 at 11.15.35 PM.png"></img></div>Step 2 - BF of parent node is ←1.  Apply left rotation<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/DlOy5y6fPRRJzWqoxxz1Dg?a=A29VaY8uHLVDYagYkd1Hm6GF2bi89siVkun0FdBksW4a' id='temp:C:VbXda800128f9ae48d9b07b73b47' alt="Screen Shot 2024-06-17 at 11.16.05 PM.png"></img></div>Step 3: Link parent node 2 to left child (node 3) of child node (node 4)<br/>

<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/3ZtWOcnayhAvhO8oNyiXGw?a=PDVJVIhQZSNTxNTWU7R0nKRdDo2cw6gVBjfCl0WzHGMa' id='temp:C:VbX2739978950b043159e873b5d9' alt="Screen Shot 2024-06-17 at 11.16.24 PM.png"></img></div>Step 4 - Link child node 4’s left child to be its former parent.  Update weights.<br/>

<h2 id='temp:C:VbX9c351e07c5414946a509544bf'>AVL Double Rotations</h2>

<h3 id='temp:C:VbXa5f96f54e812487cb465e55fa'>Properties</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa0d17d9765bc4009bb4034f1d'><li id='temp:C:VbXb9e9e6ef12b94577a37b8d176' class='parent' value='1'>Left-right Rotation: Node BF is 2 and left child’s BF is -1

<br/></li><ul><li id='temp:C:VbX4ac7e0d0e61b44898c8c6f99b' class=''>Result: top node becomes the right child of the bottom node, and the middle node becomes the left child of the bottom node.

<br/></li></ul><li id='temp:C:VbX339ff72649ad4ce38a0d2469b' class='parent'>Right-left Rotation: Node BF is -2 and right child has balance factor of 1.

<br/></li><ul><li id='temp:C:VbX01db040222554e42abb69a2d0' class=''>Result: top node becomes the left child of the bottom node, and the middle node becomes the right child of the bottom node.

<br/></li></ul><li id='temp:C:VbX9bb657c42f5740faad8011c35' class=''>If a rotation is done, the heights and BF of involved nodes are updated again.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/csbWTDCIoD_PDPVJZisAxw?a=aqpuC8cphaurvhwPrg0TV0gacakFI8ltaED9aYjBjSMa' id='temp:C:VbX49f5ebbcdae54e39991107522' width='800' height='385' alt="Screen Shot 2024-06-18 at 9.16.58 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HwgSpsRERvkCBcliv_kKGQ?a=auYKALvkmRCrjRQJPXjxDkFvBo3uDZfvoggwl7aHHZIa' id='temp:C:VbXc8cbbcec31c548c29cddff0d7' width='800' height='383' alt="Screen Shot 2024-06-18 at 9.17.57 PM.png"></img></div>Right-Left Rotation:  If balance factor of our unbalanced node is +2 and balance factor of right child is +1.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX835174d478a64f42972057f4e'><li id='temp:C:VbXf6bc703c9f3948c6b4cfb898e' class='' value='1'>Right rotation on child

<br/></li><li id='temp:C:VbX2acf8df94bff46b8a87383898' class=''>Left rotation on parent node

<br/></li></ul></div>Left-Right Rotation:  BF of unbalanced node &gt;1 and left child BF &lt; 0.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX4b96dfe6fa4241c0a43a9db16'><li id='temp:C:VbXb50e6d7c3bba43f2a7ce76fa0' class='' value='1'>Left rotation on child

<br/></li><li id='temp:C:VbX8db299affed747cdbba8054c9' class=''>Right rotation on parent node

<br/></li></ul></div>Properties:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa437085b79a34c5dbc5c51f72'><li id='temp:C:VbX6bc7e6c4c2b04f49a6dc6c2e2' class='' value='1'>Original height of an unbalanced subtree will be restored after a rotation due to adding data.

<br/></li></ul></div>Time Complexity:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX3f67b9627fb043959f98da4e2'><li id='temp:C:VbX36379df8a93d42baa8ccfe840' class='' value='1'>Single rotation: O(1), since they’re only concerned with updating 3 nodes at most (unbalanced node, its child, and grandchild)

<br/></li><li id='temp:C:VbX8ccc8ceb7ca2467f855b0d4e3' class=''>Double rotation: O(1), since they’re comprised of 2 single O(1) rotations

<br/></li></ul></div><h3 id='temp:C:VbX8f90c999a62f4c7d8584168a4'>Example: add(54)</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/omAGHGG8kwbqioKoiNkKEA?a=196mdZWzpbGfHglSGk2vwwkmqmvTnaVC20j6S6YFeUUa' id='temp:C:VbXd855b50c2c4343db8fbec85c5' alt="Screen Shot 2024-06-18 at 10.38.23 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Ki6tjSLrm9kNqGz_9-nJpA?a=GDDGCGZXfynQBddjsayY7AQia2JHSgQfVbnYpjTfEfoa' id='temp:C:VbX13e2666b3c5b4f1ba564e60a9' alt="Screen Shot 2024-06-18 at 10.38.42 PM.png"></img></div><br/>

1) Add 54 to BST<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/chHEAYd1vIod2su6tbMsnw?a=3CfWYstB0oGFJkkq1ma9KoVSu1xD3Sj19nWhoPz0vowa' id='temp:C:VbX28f7ca5e0d2e4671ac5467a0a' width='800' height='307' alt="Screen Shot 2024-06-18 at 9.20.13 PM.png"></img></div>2) Update imbalance<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX2e6ce5aa2d2a474785b48544b'><li id='temp:C:VbXc814da9489b04ab7b1d80012c' class='' value='1'>Leaf nodes will have BF of 0

<br/></li><li id='temp:C:VbXaa893f87877147b98eaf154bf' class=''>Increase height of parent node by +1 and BF by +1 (if only one child exists)

<br/></li></ul></div>3) Update balance<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/3zbCeUHdzSFzXneWmeyKWA?a=j80ktS5YMQjov8O2EdJRUaaEyqu41DnIdKUMd8ZYYrEa' id='temp:C:VbXdb5f790e34204dda996ef4f87' alt="Screen Shot 2024-06-18 at 9.22.53 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/AETSDWI-RvohIIjYJ3CULg?a=RaQraaKZ8UMxBjrD42HmlvzmiKtvU5nFgSzXZSfgyqAa' id='temp:C:VbX91223597c18042c68e8dc2252' alt="Screen Shot 2024-06-18 at 9.23.18 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/TbhkMzLp9txjDiaPglOtLg?a=lgSr2lqX4NWiqDNdkbvs9QhWr3qPZmTZ2Et8bmjskxoa' id='temp:C:VbX1c4cfe8591034bd1812cef62c' alt="Screen Shot 2024-06-18 at 9.23.38 PM.png"></img></div>We observe that node 50 is unbalanced.<br/>

4) Apply double rotation if parent node is &gt;= 2.  <br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-lwWrJ_z45l88i-Bav8IeQ?a=TjlmD92zhJT99h2FaX1gfKrx8E4sId5Aon4nlzlX1p4a' id='temp:C:VbXe181bfdea66944208daeae5e8' alt="Screen Shot 2024-06-18 at 9.24.17 PM.png"></img></div>Parent node is -2<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/TCzHJhR3opHuo8O8LLkv1Q?a=BIFYq0pdquLgcghN8jA20SeekUcgBXX6KWxspaWrJXEa' id='temp:C:VbX1d94862fb4554172925cc75d5' alt="Screen Shot 2024-06-18 at 9.32.31 PM.png"></img></div>Left rotate on 50. <br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/83-gIqzGhACtdYbjNFHAPA?a=xB7BQlYowLu8RraIEscKXU0CPCjDzM3La41f25BnfGsa' id='temp:C:VbX82040d9135cd4c40900383f41' alt="Screen Shot 2024-06-18 at 9.26.33 PM.png"></img></div>Update node 44’s BF + height<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/JDyIDIjMB7_nlAbv2R4ggw?a=kI8Lxxm2oRslXBzBlgtwmsDX5J3BDPaYjRv60jKEKy8a' id='temp:C:VbX1bc0f80779354d889eb5483f1' alt="Screen Shot 2024-06-18 at 9.24.35 PM.png"></img></div>Right rotate on 68<br/>

Update BF + Height<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/XTgRMFq0aqzhE7cYEkG7gQ?a=4Y0eZMf22WwVanobHbpGIgwuimUdHVBVX7YUT4CsU7ka' id='temp:C:VbXdebc9cd209324892b574310b5' alt="Screen Shot 2024-06-18 at 9.25.41 PM.png"></img></div>Node 62 moves up, 50 becomes left child.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HDHkb0AOtL6ikrO26fjISA?a=ikv203BAn7NqxvagTsqkTJXlVXdjTSoPQacrDq1CD64a' id='temp:C:VbX7fb94be6f9004493814395f44' alt="Screen Shot 2024-06-18 at 9.24.48 PM.png"></img></div>Node 62 moves up, and 68 becomes right child.<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/KBzeAq-b-kBnnHVJxfmmlw?a=1djmfyOnwckV2YOTzrPXx28kUKagWDGP2Cd9EXc7aQwa' id='temp:C:VbX2c1137e6b5864ec0b9376902f' alt="Screen Shot 2024-06-18 at 9.26.04 PM.png"></img></div>Update BF + height.  Return node 62 as node 44’s right child.<br/>

<h3 id='temp:C:VbX6cf6bd99c50f46a9942d05861'>Rotation Table</h3>

In the past, students have told us that the table presented in the video for rotation types is very useful as a study tool. We provide it here so that you can reference it as needed. Do keep in mind that the shape shown is the simplest case; there will likely be children nodes or entire subtrees in an actual implementation that need to be properly managed.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/aUbXPCOmrAjn6hVPPs55dQ?a=ATLFZW7nZviqt0usgTglRh5ZVE6Ymah1MbI1HLCm4Dca' id='temp:C:VbX5db300f95567450ba7804ba2f' width='800' height='346' alt="image.png"></img></div>Qs:  What needs to be changed with a BST to become an AVL tree<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXb8af3313f2844b8c9f7477f72'><li id='temp:C:VbX56265927239f42e18d85b6535' class='parent' value='1'>Where does the update code go in the add and remove methods?

<br/></li><ul><li id='temp:C:VbX1eb46efcebe94c2287c611f50' class=''>After the add / remove action is made, <b>after</b> the recursive call.

<br/></li></ul><li id='temp:C:VbX424e323e85544594aeab9d709' class=''>What is returned when pointer reinforcement is used? What is returned from each rotation?

<br/></li><li id='temp:C:VbXd645bd0638d14fddb9b7be4f5' class='parent'>How is the balancing information updated? What differences are there in terms of the heights compared to BSTs?

<br/></li><ul><li id='temp:C:VbX7248f0880f104956bd0d55fef' class=''>BF update after each rotation.

<br/></li><li id='temp:C:VbXa0a22af6457347f585d278213' class=''>New root of the rotated subtree?

<br/></li></ul></ul></div><h2 id='temp:C:VbX07ab4e66c8ed43d094dc4f267'>Logistics of an AVL</h2>

There are some final logistics behind the functionality of an AVL tree based on the rotations that need to be covered.<br/>

<h3 id='temp:C:VbXdfd049e7a10c47cba9f2bea49'><b>The Number of Rotations per Add/Remove</b></h3>

Let's get a better handle on how these rotations and updates occur in an AVL tree. Based on the algorithm, we recurse down the tree to find the location to add/remove. Once we've done the standard BST add/remove operation, on the way back up the tree (unwinding the call recursion), we perform updates to the parent(s) node(s). The height and balance factor is updated for every node on the return path up, but a rotation won't be needed at every node. Each rotation is <br>𝑂(1), and so is every update, but it might be a good idea to see how often these rotations actually occur. We know that the number of rotations can be at most 𝑂(log⁡(𝑛)) since the height is 𝑂(log⁡(𝑛)), but perhaps the number of rotations is far less than this.<br/>

<br/>

That is precisely what ends up happening with the add operation. As it turns out, <span style="color:#cc0300" textcolor="#cc0300"><b>each add operation will trigger at most one rotation</b></span>. This is because when adding data, any rotation will reset the unbalanced subtree to have back its original height. On the other hand, <span style="color:#cc0300" textcolor="#cc0300"><b>any remove operation can trigger𝑂O(log⁡(n)) rotations in the worst case</b></span>; remove operations do not have the same nice property. When a rotation is performed due to a removal, the new height of the <u>unbalanced subtree</u> <u>may not regain its original height</u>, propagating height changes up the tree.<br/>

<br/>

Let's try out an example with the add method. <b>The steps involved here will be detail oriented, so take things one step at a time and make sure you understand each step of the reasoning before continuing to read!</b> Consider the diagram below, where we are seeing the first rotation triggered by an <b>add</b> operation up the tree. We can do a similar reasoning for the other rotation types, so let's keep it simple and assume it was a right rotation. We will derive that each of these heights and balance factors shown must be as shown by <b>only assuming that the height of node is ℎ+1 and that a right rotation is necessary</b> (so 𝐶's balance factor is 2).<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/H-9kGQJE_1OZf2lRSaDdLw?a=NuInSuwqOAy1aFSQyRUzDB2aotmdk5PdPPga1khHmmka' id='temp:C:VbX953e7ba86588482e8a7337d90' width='800' height='318' alt="image.png"></img></div><br/>

We immediately know that the height of node 𝐵 is ℎ and the height of 𝑇4 is ℎ−2 due to the balance factor and height of 𝐶. Additionally, this imbalance was caused because of the data added. If any subtree's height changed, it was because the height <b>increased</b>. This also means that the new data must be in the subtree of 𝐵 rather than 𝑇4. The balance factor of 𝐵 can be 0 or 1, but we've written in the image that it must be 1. Why is this? Well, <b>we only added a single data</b>. This means that <b>only</b> the height of 𝐴 or the height of 𝑇3 could have increased, <b>not both</b>, so the balance factor of 𝐵 cannot be 0 and must be 1 (because it's a left rotation). This implies that the new data must be in the subtree of 𝐴 (if it was in the subtree of <br>𝑇3, then the tree would've been unbalanced before the add), giving heights of ℎ−1 for 𝐴 and ℎ−2 for 𝑇3. <br/>

<br/>

After the rotation, 𝑇1,𝑇2,𝑇3, and 𝑇4 are completely unmodified, and, thus, their heights are unmodified. The heights of 𝑇3,𝑇4 determine the height and balance factor of node 𝐶, which is now ℎ−1 and 0 respectively. The height of 𝐴 is also unchanged. This allows us to compute the height and balance factors of the new root 𝐵, which are ℎ and 0 respectively.<br/>

<br/>

This is exactly what we were looking for because the height of this unbalanced subtree was ℎ+1, and before we added the new data, the height was one less, which is ℎ. <b>We've restored the original height, so the rest of the nodes up the tree will not change heights and balance factors!</b><br/>

<h3 id='temp:C:VbX3f23956f5a294140b0c2fe322'><b>The Efficiency of an AVL Tree</b></h3>

AVL trees guarantee that the height of the tree is 𝑂(log⁡(𝑛)), so operations like search, add, and remove now have a worst case of 𝑂(log⁡(𝑛)) since the balancing is all done in 𝑂(log⁡(𝑛)) time along the same path taken to get to the location. To contrast, this is relative to the worst case of 𝑂(𝑛) for those same operations in a normal BST. Additionally, since the height is stored in each AVL node in order to maintain balancing information, computing the height of an AVL tree is now 𝑂(1) as opposed to 𝑂(𝑛) like before. This all seems like a straight improvement compared to a BST, but there are some caveats and asterisks here.<br/>

<br/>

We need to keep in mind that when analyzing the efficiency of some tree operation, we need to be cognizant of how it might differ between an AVL and a BST, both <b>efficiency</b> and <b>correctness</b>. For example, traversals would be <br>𝑂(𝑛) for both since the balancing structure doesn't change the algorithm or efficiency. However, <b>if an operation would modify the tree structure in some way, then it may be harder to do in an AVL since we must maintain proper balancing by the end of the operation</b>. For example, removing all leaves in a BST can be done reasonably easily in <br>𝑂(𝑛) time using a single traversal. For an AVL, this may not be so obvious anymore since removing nodes may trigger rotations, which will change the leaves of the tree midway. In other words, correctness may be harder to achieve due to rebalancing, which may worsen the time complexity.<br/>

<br/>

If the main things we're doing are adding, searching, removing, and traversals though, then we're golden!<br/>

<br/>

<h2 id='temp:C:VbXaa3563a7a87f4ee09a40d24fe'>Food for Thought - Self-Balancing BSTs</h2>

<b>Self-Balancing BSTs: There's Two!?</b><br/>

<br/>

When you look up self-balancing BSTs, you will most likely see two types of BSTs come up: <b>AVL trees</b> and <b>Red Black trees</b>. This course does not cover Red Black trees (perhaps in the future if there is sufficient demand, but there are currently no plans for it), primarily for two reasons:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX2f1e303459234985b1bdcdfde'><li id='temp:C:VbXbfba7292f3c74fd38b48fe70d' class='' value='1'>We see two types of trees in this course with complex operations and balancing schemes (AVLs and <b>(2, 4) trees</b> that we'll see next module). If you can make it through both of these types of trees and understand their operations, then you shouldn't have much trouble learning Red Black trees. Many of the concepts such as rotations will carry over, so we leave it to you if you are interested.

<br/></li><li id='temp:C:VbXceb4fa73ec7c484fb3c28d47a' class=''>We want to keep the material paced well for learning while preventing course length from exploding too much. If we wanted to also cover Red Black trees, we'd probably want to break these three tree types up to prevent the course from becoming too monotonous, and that'd probably extend the data structures part of the course by another 2-3 modules. If you make it through all of these modules, you've probably learned enough so that you can probably go off on your own to learn other interesting data structures!

<br/></li></ul></div>We will talk a bit about how Red Black trees work, but we'll defer that discussion to the next module because Red Black trees are heavily related to (2, 4) trees. <b>For this reason, if you want to look into Red Black trees, we highly suggest you wait until after the next module.</b><br/>

<br/>

We mentioned earlier that AVL trees can be shown to have a worst case height of around 1.44log⁡(𝑛). You may wonder how do Red Black trees fare against this? Red Black trees can be shown to have a worst case height of around <br>2log⁡(𝑛)). In other words, the balancing of a Red Black tree is looser than an AVL tree. Because of this, <span style="color:#cc0300" textcolor="#cc0300">if you know you'll just be performing a lot of lookups, you'd prefer AVL trees of the two</span>.<br/>

<br/>

AVL trees usually store balancing information like heights or balance factors, whereas <span style="color:#cc0300" textcolor="#cc0300">Red Black trees only store one bit, which is the "color" of the node, red or black</span>. This may give Red Black trees the edge in memory, but AVL trees can be optimized to just store the balance factor, which is 2 bits. Red Black trees tend to be better in terms of general purpose, which is why they are the more commonly implemented of the two, but the differences between the two are not that significant in terms of performance for most cases.<br/>

<br/>

A performance analysis by Ben Pfaff back in 2003 studied 4 different BST variants in a variety of settings, so you might find that interesting. It's an experimentation paper, so it's fairly readable, and it's interesting to see in what contexts each BST type excels. We'll cite it in the module review.<br/>

<br/>

You may have noted that we said 4 BST variants. These are the regular BST, AVL, Red Black, and <b>Splay trees</b>. We'll also briefly discuss splay trees in the next module, which are one of the more interesting BST variants because they yield efficient operations without maintaining strict balancing!<br/>

<br/>

<h1 id='temp:C:VbX2a2d2e91c25d44adb2ac7d37c'>M99 - SkipLists</h1>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SH8uXvo0xZDsv0KyoHNV_g?a=gM84vamSNIWGP6Ka3xtPdCaD9UafaiatcqvDAyxnA7Ya' id='temp:C:VbXc9fc8c7db03b4483a66e07380' width='800' height='379' alt="Screen Shot 2024-06-18 at 10.56.51 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/2MAtAja8OggFeN5pPqYOlA?a=DapMqzJMA70CdSYkYQJnF7nqalji9ZvNBsn9vdxYuqga' id='temp:C:VbX59f3124ed2e843ec9ebd5bf4d' width='800' height='290' alt="Screen Shot 2024-06-18 at 10.58.15 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Y4r0vM_Fv9zlGlCDUTwqxw?a=CkavHabCKpkUwqMOviZc963pqCQbz9X5EaYFtf4JVgwa' id='temp:C:VbX12406c1399494232a79ca109a' width='800' height='357' alt="Screen Shot 2024-06-18 at 10.58.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CNmtTkBbIUTManl3GSvlpA?a=swGuopgnqfDbykmm43TdUW5xrdOhUzFCQpu4B549Basa' id='temp:C:VbX967d359df3864e7a9188253ee' width='800' height='365' alt="Screen Shot 2024-06-18 at 11.01.07 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/r2tj9vVIRWLc5_Kc-Nbgyw?a=q03BTVEHYfgKarGubpMB9snvtts05wGgMtHPuJTaq7Qa' id='temp:C:VbX7b13ff86c64346688f1e685fd' width='800' height='288' alt="Screen Shot 2024-06-18 at 11.02.23 PM.png"></img></div><b>Errata</b>: Slide should say, “If data &gt; right, then continue moving right” and “If data &lt; right, move down a level”<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Ft4ij4iMgYrI2l_eAbr9Cg?a=6c9Q9wZ1xNFORUJbgnjtQh80wmJzNXONv21NeMV87uMa' id='temp:C:VbX54309cf27bb3476fadd1387e7' width='800' height='355' alt="Screen Shot 2024-06-18 at 11.03.40 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX7dfdb118c7064f69a34227368'><li id='temp:C:VbX4fab889c41144c5ea610ae755' class='' value='1'>Add 25 between 20 and 45 at bottom level

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/q77RKGYseOqClzCwmfCeLw?a=2GJ4CaSi0XonrNP1NW9NWbw4gqgHaK4sUaBO5V0vypka' id='temp:C:VbXf0dae348200d4574905dc152d' width='800' height='357' alt="Screen Shot 2024-06-18 at 11.04.38 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX355fe71cff7f446aaa593bc97'><li id='temp:C:VbXa06a42e8ab324d3e80eb1471e' class='' value='1'>Once found, LinkedList removal removes 45 from all levels.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Jm2xoFPIP8j2ICgRiOz8Uw?a=0AkRfTw7wvgfy07sDC85dNhD6DcxVo5DYJZaA71PgfAa' id='temp:C:VbXa2b1b5ace76d411a8230a9df3' width='800' height='305' alt="Screen Shot 2024-06-18 at 11.08.05 PM.png"></img></div>Efficiency:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX8f462dc87b244a309a0e7b05f'><li id='temp:C:VbXde5f23e617fc49e58b99f1dd6' class='' value='1'>Search/Add/Remove: Worst case O(n) is when all nodes live on level 0.  Essentially becomes a LinkedLIst.

<br/></li><li id='temp:C:VbXc2386df1dfd9474abde1d5269' class='parent'>Space: Worse case O(n log n) when all nodes are promoted to top level, results in massive grid.

<br/></li><ul><li id='temp:C:VbXfeae164ce5e44d7b8a5afa682' class=''>Avg Case O(n) bc converge to geometric series

<br/></li></ul></ul></div><b>Errata:</b> Best case is O(1) for all, if data we're looking for is the leftmost entry of the SkipList that has been promoted O(log(n)) times.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb24f654037eb42f08284b6949'><li id='temp:C:VbX175fcdfccd7740df9d986eee4' class='' value='1'>In the case of adding, if nothing has been promoted, the head as at level 0, and we add a new minimum data.

<br/></li></ul></div><h3 id='temp:C:VbX6bf6dea638444ea1ab2d438a3'><b>The Purpose of a SkipList</b></h3>

If you are like most students, you may come out of this lesson thinking "Cool, but what is the point of SkipLists, and why are they placed here categorically?" This line of thinking is certainly valid and one we hope that you take as you try to piece together the big picture of this course. To answer these questions, we give a few different answers, which we hope will stimulate some interesting thought and discussion.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX4cb578ccf8b0498598131f6bd'><li id='temp:C:VbX1b3154aeaa8449f18203d3467' class='' value='1'><b>SkipLists can be useful for simple concurrent access operations:</b> Concurrent access is the scenario where you have two users/machines/agents working with the same data structure simultaneously. In a BST, imagine if one user called a remove operation, while another user was searching for some data. If the remove operation begins, and it ends up being a two-child case, then while the pointers are being relinked, the search may occur in the tree while it is being updated. The search may end up yielding the wrong result due to looking at the tree when it wasn't ready for searching.<br><br>SkipLists work decently well with this problem because as long as we move pointers in the correct order, even if we are in the middle of updating the SkipList, the end result of a search will be correct since we won't skip data by accident. However, we should note that for many reasons, SkipLists are not often the tool of choice when it comes to concurrent access operations; we just think it's a cool way to introduce the idea of concurrent access if you've never seen it before.

<br/></li><li id='temp:C:VbX9f9478d3dd0a41498cd62db14' class=''><b>SkipLists are simple to implement:</b> We will see later on in the course multiple variations of BSTs that have some kind of balancing scheme in order to help search times. However, these balancing schemes can be tricky to implement, whereas SkipLists are relatively simple to implement and understand. It still has a worst case behavior similar to BSTs, but its reliance on probability can often allow it to perform comparably to these balancing schemes.

<br/></li><li id='temp:C:VbX75f07c52c81b4d79bbd5afb17' class=''><b>SkipLists are a nice introduction to randomization in computing:</b> This is probably the truest answer for why these are taught in many introductory courses and placed in a similar manner. The fact is that SkipLists are one of the more niche data structures taught in this course. This is in contrast to the rest of the course, which takes a generalist approach, allowing you to build up your toolbox of sledgehammers that you can bring out in a variety of situations and contexts.<br><br>Randomized computing is an extremely interesting area that is actively being researched and used today, but as you may expect, much of it is locked behind a decently hefty mathematical background and maturity. So, although we won't get to see much randomization in this course, SkipLists are an example of a randomization concept that is simple enough to see in an introductory course like this.

<br/></li></ul></div><h2 id='temp:C:VbXe6dfb524bff0463896430c9cb'>Food for Thought - Randomness In Computing</h2>

As we mentioned in the previous SkipList unit, we won't be able to spend much time on randomized computation due to insufficient mathematical background. We would like to take the time to question the use of randomness in computing at all. <b>Randomness</b> is a concept used to model real-world phenomena such as coin tosses or dice rolls. It makes sense to us that if we flip a coin that is equally weighted, we expect about half of the flips to be heads, which we call a "probability of 1/2."<br/>

But does it make sense to assume that computers should have access to randomness? To put it another way, is it fair to assume that computers can model random behavior like flipping a coin? The reason we're doubting this is because computers operate in a <b>deterministic</b> way, meaning that the code they execute will always proceed the same way (no randomness). So, can computers model <i>true</i> randomness?<br/>

<br/>

Another related question is whether or not randomness "helps" computation. That is, if we assume that we have access to randomness, can we come up with solutions to problems that are "better" than purely deterministic ones (i.e. faster or more accurate)? We hope to address these two questions here in a limited capacity.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX626b5741afb145c4a35b105bc'><li id='temp:C:VbX2d418ba8a8f347a9955e28791' class='' value='1'><b>Access to randomness in computing:</b> This is an open question in computer science, whether or not computers can generate truly random results. If you call a <b>random number generator (RNG)</b> in most languages, it will use what is called a <b>Pseudo-RNG (PRNG)</b>, which generates numbers in a completely deterministic way that appears random for most applications. Usually, they have some base number called a <b>seed</b> that is used in large and complex arithmetical operations to "spread out" the numbers in order to appear random. The problem with this approach is that since it's completely deterministic, if you know the seed and the model used, then you can reverse-engineer all of the randomness the PRNG gives.<br><br>Some RNGs make use of real-world phenomena that are very complex in nature such as atmospheric noise or thermal fluctuations in the air as a source of randomness. Whether these phenomena can truly be called random is a valid question, but they avoid the reverse engineering problem that PRNGs have.

<br/></li><li id='temp:C:VbX3acbe8ab8784431da9da9a37e' class=''><b>Usefulness of randomness in computing:</b> Yet again, this question is a major open question in computer science. There are many examples where problems have nice, simple, efficient, and elegant randomized solutions which have seemingly no deterministic counterpart. For example, consider the problem of primality testing: checking whether or not a number is a prime number. We've known for a while of several randomized solutions that are simple to implement and efficient, but it was a major hurdle to find a deterministic solution. Such a solution was eventually found, but it's much more difficult to implement and not as efficient.<br><br>For many of these problems, it appears that randomness plays a key role in solving them efficiently. Perhaps we haven't found the right ideas, or haven't thought out of the box to come up with a deterministic solution. We have nothing that proves for sure whether or not randomness improves or doesn't improve the power of computing. Thus, it remains an open problem.

<br/></li></ul></div><br/>

<h1 id='temp:C:VbX7c7da7b24cf54f12baa818bef'>M9 - (2-4) Trees</h1>

In this module, we continue our exploration of trees by taking a look at a very different type of tree from what we've seen before, a non-binary tree type known as <b>(2, 4) trees</b>. These (2, 4) trees inherit a similar order property found in BSTs, but (2,4) trees have flexible nodes that allow for multiple data and multiple children per node. (2,4) trees have a more strict shape property, requiring that every leaf node resides at the same depth. Thus, making the depth of (2,4) trees logarithmic.<br/>

(2,4) trees are the last type of tree we will be covering in the course sequence, and it also marks the end of the data structures half of the sequence! With the completion of this module, you'll have built up a formidable toolkit of data structures that you can draw from when problem solving in your programming work. Of course, we cannot cover every data structure that might be useful. But with the knowledge and maturity you have built from this course sequence, we know you have the skills to tackle other data structures on your own as you encounter them in your work. Nevertheless, this module also features some <b>optional "Food for Thought"</b> glimpses at <b>splay trees</b> and <b>Red Black trees</b>, which are other types of BSTs that maintain their operations through various rotations.<br/>

<h3 id='temp:C:VbX7828991549c94aeaad148a81d'><b>Learning Objectives</b></h3>

Students will:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX360808b2f9f34797ab26bb0dd'><li id='temp:C:VbX288cd380c30d4dd7aa8c24474' class='' value='1'>Encounter their first tree type that is not binary, (2, 4) trees.

<br/></li><li id='temp:C:VbX15520e5e055646f0b73684f6b' class=''>Gain familiarity with the order, shape, and node properties of (2, 4) trees, and why they lead to logarithmic search times.

<br/></li><li id='temp:C:VbX707568b780da4a4b9c5e12411' class=''>Diagram the add operation and its procedure, along with how it fixes <b>overflow</b> violations via <b>promotion/split operations</b>.

<br/></li><li id='temp:C:VbXbc30243cd9894a84b940fa81a' class=''>Understand the complex inner workings of the remove operation, along with how it fixes <b>underflow</b> violations via <b>transfer</b> and <b>fusion</b> operations.

<br/></li></ul></div><h2 id='temp:C:VbX86432704aa1e4584bc1d57df0'>Intro to 2-4 Trees</h2>

We begin this lesson by looking at the properties of <b>(2, 4) trees</b> (sometimes referred to as <b>2-3-4 tree</b>). These trees are a generalization of BSTs because they allow multiple data to be stored in sorted order in a node, anywhere from 1 to 3 data. (2, 4) trees are a special case of <b>multiway search trees</b>, which allow multiple data to be stored in a node in generality. They're called multiway search trees because if we have 𝑥1&lt;𝑥2&lt;⋯&lt;𝑥𝑚 in a node, then this defines <br>𝑚+1 possible areas for data to be. So, a node with 𝑚 data can have 𝑚+1 children, which hold data in the specified range (the namesake of (2, 4) trees is that every node can have between 2 and 4 children).<br/>

<br/>

Multiway search trees that enforce a strict balancing scheme are known as <b>B-trees</b>. As we will see, (2, 4) trees are always perfectly balanced in terms of tree height, so they are also a special case of B-trees.<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sU0d4B-EN9Wrmylb-xR9oA?a=ZkBLfWbpSNA9DJ31PE1G8GowCE6nReBmKNvnRcrKiS0a' id='temp:C:VbX1b35e066235144fcac3e982a1' width='800' height='290' alt="Screen Shot 2024-06-19 at 7.56.46 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GgCLh85QU527iNxzJAalgA?a=CfTlfX3awfFctqa2dPG7aBI5C5ya64jcYKjfiSNxdrUa' id='temp:C:VbX0b150b9e80954d6f9a249bef8' width='800' height='293' alt="Screen Shot 2024-06-19 at 7.56.57 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FQUxFyNazfzjc0oNKo7p-A?a=WGs9ylaKqsCIqtM7LkhCPFm8eArislKUrwSbJ8h7JAAa' id='temp:C:VbX7f64cc018e3a4c049e366a8dd' width='800' height='344' alt="Screen Shot 2024-06-19 at 7.57.23 PM.png"></img></div>Strict shape property achieves O(log(n)) operations.<br/>

<h3 id='temp:C:VbXcd69ceb3f46e494bbf018a3c5'><b>Balancing in a (2, 4) Tree</b></h3>

In the AVL module, we saw the we cannot always maintain perfect balancing of heights in a BST due to the problem we see below. Perfect balancing can only occur for certain values of 𝑛.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YWsN4sz8p7PPtr6KpitEzA?a=n34aAvRMHCAAtULDXmWQqpJEdDzvhiitgBVlVt1vcJ8a' id='temp:C:VbXdfb4b852f8954987b895e4d08' width='800' height='341' alt="image.png"></img></div>Well, (2, 4) trees solve this problem by allowing more than 1 data to be in a node. Naturally, the time complexity of searching now depends on both the height as well as the number of data allowed per node. Allowing up to 3 data is a nice compromise between the two costs while allowing us to perfectly balance the tree efficiently. Of course, there will be imbalances in the sense that some nodes will be more filled than others, but from the perspective of heights, the tree is perfectly balanced.<br/>

<h3 id='temp:C:VbX0a554042bc6d4fa786197a4b0'><b>Searching in a (2, 4) Tree</b></h3>

In a BST node, there was only one data, 𝑥. The way we decided whether to go left or right was to check if our new data <br>𝑦&lt;𝑥 or 𝑦&gt;𝑥. Searching in a (2, 4) tree follows the same principle. Suppose we have a 4-node as shown below. (The 4-node contains 3 data and has 4 children.)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/JkWYoCZo7rp473ivhvSXbA?a=8cQm3SEz3065MSclM63vhVVSirBla2LYQVbwxXYlaysa' id='temp:C:VbX493b5a0142f44718bc7535ef9' alt="image.png"></img></div><br/>

The direction in which we search for the data is determined by "area" of the search where the data may be located. The decision process is similar for 3-nodes, and, of course, 2-nodes. Let's look at an example. Suppose we have the (2, 4) tree given below and want to look for the data 16. Then, the path followed in the diagram is precisely the search path we would take. The red numbers denote where we compared the data, and the green numbers denote where we found the data.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-7rcQHvYSme01YGcl1Y_Kg?a=LdKBwgd3izT4ffaQWnzsDd62i8ohFmvXMjjvaaeDv90a' id='temp:C:VbX2fa238a3145f48ab844767916' width='800' height='313' alt="image.png"></img></div><br/>

<h2 id='temp:C:VbXc8ac82cefc5149568c3b94f6f'><b>Food for Thought - B-Trees: Querying Large Databases</b></h2>

As we mentioned, <b>(2, 4) trees</b> are a generalization of <b>B-trees</b> that allow up to 4 children per node. Another way of saying this is that a <b>(2, 4) tree is a B-tree of order 4</b>. For those curious about the name of B-trees, there is actually no official consensus for what the B stands for, so assume it to be whatever you like!<br/>

<br/>

As we mentioned, B-trees have a tradeoff that they inherently work with. The higher the order of the tree, the shorter the tree. However, the higher the order of the tree, the more data per node, and therefore more operations to process each node. In short, we're just shifting the cost of searching from traversal of the tree to a sorted list-like structure in a node. That begs the question, what good is that? As it turns out, B-trees are very commonly used for large databases!<br/>

<br/>

Suppose we have a very large database that we'd like to perform many queries on. This database is much larger than what we can expect to store in active memory, so we're going to have to store this somewhere else which has a much larger storage capacity. Historically, this is traditionally done with disk drives (though in more recent times, SSDs are becoming more and more popular/viable). Reading/writing to a disk is orders of magnitude slower than doing the same with RAM, so we want to minimize how many reads we need to query the database.<br/>

<br/>

As with many things in computer science, hierarchical structure is what makes B-trees so useful. <b>B-trees organize hierarchically into blocks (the nodes and different levels).</b> As it turns out, while reading things from a disk is on the order of milliseconds (yes, this is slow for a computer!), this is actually the time it takes to <b>read an entire block of memory</b> rather than a specific memory location. So, it will be much faster to query data in the same block than querying different blocks (such as in a BST) for each query. What the order of B-tree is used will naturally depend on the system, so that has to be tuned for B-trees to be used optimally.<br/>

<br/>

As time moves forward, technologies improve, and what works best before might not work as well now. As we mentioned, SSDs are becoming much more commonplace, and reading/writing to SSDs is indeed faster compared to disk drives. However, this is still much slower than working directly with RAM. Additionally, there are plenty of things that benefit from the hierarchical nature of B-trees, so it's unlikely that B-trees will be going away anytime soon. Not to mention that adoption of newer practices is surprisingly slow in a space like this where technology improves so quickly!<br/>

<h2 id='temp:C:VbXbd613912c6504eee9cacf4556'>Adding and Overflow</h2>

In this lesson, we will leverage how to search in a (2, 4) tree in order to add data to a (2, 4) tree. Similarly to BSTs, we always add new data to a leaf node. Unlike BSTs, the (2, 4) add operation places the data <i>within</i> the leaf node, rather than add a new child node to the leaf node. This is how (2, 4) trees preserve the tree shape and order properties. However, the node size property may be violated as the node "overflows" with data. If the node size property is violated, then a <b>promotion</b> (sometimes called a <b>split</b>) is performed to resolve the violation. Promotion propagates the overflow upwards into parent nodes until a valid (2, 4) tree is formed.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sSge3EELDHIZn3NQKkCr-g?a=qArTVO91azQXekqbFWc3G5ZoPt7AZBE6IpBJSTQhez4a' id='temp:C:VbXbb3212be0a4643f99e31c34bc' width='800' height='196' alt="Screen Shot 2024-06-19 at 8.14.55 PM.png"></img></div>Overflow occurs.  Either middle data will be promoted.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/umiDXopJshz_AhZwzCTebA?a=5uTz8EdC2N3zhFSmoFCUZuVcVpP6ZqgWJrYYvrZVdRAa' id='temp:C:VbX19b9ad90c9f34d359349476c5' width='800' height='231' alt="Screen Shot 2024-06-19 at 8.15.32 PM.png"></img></div>20 is promoted, rest is split left and right into child nodes<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/t2Lcy3yZuq0UeRc1HX6mTQ?a=izXIuFTgo3BPxe1oRr7kDeXR5GPmHuIud9sydMSQ9qEa' id='temp:C:VbX068fc000f04a4cb19dc754d7b' width='800' height='196' alt="Screen Shot 2024-06-19 at 8.16.25 PM.png"></img></div>Overflow occurs.  Third data is promoted, and node is split in two.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sTOIjOc3NMaqTxKN59aipQ?a=6XfjbQB01MFgMJw6S8cJCQiRqoaJeFiMIewngZjPWa8a' id='temp:C:VbXbdb3befd0fdb4bf5a96e2984c' width='800' height='194' alt="Screen Shot 2024-06-19 at 8.17.29 PM.png"></img></div>12 is promoted. Note how each child sit less than, between, or greater than or parent data.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ZTAdoD6nZTtgH2fwvOSxSA?a=swDvyWWEJ7tkFX3AAZTAA7BdudE0vjE344Ey5JykPIIa' id='temp:C:VbXa61a0a0b15b64eea8f8a55740' width='800' height='192' alt="Screen Shot 2024-06-19 at 8.18.08 PM.png"></img></div>Overflow occurs.  Third data value (45) is promoted<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/JZVgE0NtjsAeYEsbgjLLTg?a=yIjamCaGlpIvRlPQ7jlSFbhLyUJVjbObKxnahJ2LqkMa' id='temp:C:VbX3b4194cd94844a589a2db4839' width='800' height='184' alt="Screen Shot 2024-06-19 at 8.18.36 PM.png"></img></div>Overflow when 36 is added.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/aoYyK007XBdUN35-JRf-_A?a=FcGK3xz8ZdWxNNK5LUiHfXfG54aE7y2Ncnah3bWveQQa' id='temp:C:VbXaf74ac22f91f44df8fd150f84' width='800' height='187' alt="Screen Shot 2024-06-19 at 8.18.59 PM.png"></img></div>36 is promoted.  Root now hits overlow.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9ZfgpFoc-BSk3e2KwqZMhw?a=lQpROZp5LmatepylXcD6qxIeT5OjucGOda1EWUUNzAEa' id='temp:C:VbX4fb3be0f00d5410e9d6003b56' width='800' height='192' alt="Screen Shot 2024-06-19 at 8.19.29 PM.png"></img></div>Second promotion occurs for 36 and left right sets are split.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/1iT_vb3e4q2B7AajyODQ7w?a=0enOKKEJ2t7jjQLrdegthaFlmDWH8XNmy1XAjeHh4zAa' id='temp:C:VbXc7b8ddcb78484b2680247262a' width='800' height='270' alt="Screen Shot 2024-06-19 at 8.20.01 PM.png"></img></div>Add the data 1,2,…,10 in sorder order.  Used the 2nd data to promote. How much of each node is filled? What do you notice about the balance of data (in terms of fill percentage)? What will happen as you continue to add in sorted order?<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/_W13fww2pKE9cxdTEjnWFA?a=qtlktL3ePHfMCYGHaDkgkyNx8QSp1X6R1rNyDIaRaR0a' id='temp:C:VbX714f9d5266b64bada5b84ccdb' alt="Screen Shot 2024-06-19 at 8.22.18 PM.png"></img></div><br/>

Use 3rd data promotion to add the final 10:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/d6tv-VxjPzuQtexukIqfZQ?a=6B994HAfHaN7PmiBL0dujsK1tIzixrLRf0siPspubDoa' id='temp:C:VbX72ba717b6967473eabb74e4a0' alt="Screen Shot 2024-06-19 at 8.25.06 PM.png"></img></div><br/>

<h2 id='temp:C:VbXd58abee6f4cb4f59998b08525'>Removing and Underflow, Example 1</h2>

The most complex remove of all data structures presented thus far is discussed in this lesson. We will examine how removing works in a (2, 4) tree and the complications that occur. Just as there was overflow when adding, we have <b>underflow</b> conditions when removing. Underflow is remedied by two operations, <b>transfer</b> and <b>fusion. </b> Transfer is the easier remedy of the two and it is always preferred, if possible. The remove procedure can appear very complicated, so take time to look at the process one step at a time. This is where you will see the value of the vistool. Spend lots of time playing with the vistool in the lab for this lesson to get a handle of what is happening.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sOXizXqoWKKg93LfLZr7Uw?a=OPH9XX2ZFKs4pXYImXkLja00QaxN4sxoyxbt8TEZqXsa' id='temp:C:VbXa91ca022c8fc43da8a1f2603a' width='800' height='362' alt="Screen Shot 2024-06-19 at 8.30.16 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mKTnanADJvC0HCOuJAnVrA?a=iqtQIxp2FNKBDFuSqNPS4QLYNtBWnZn5GH6DncvfVIwa' id='temp:C:VbX52e0ec2ac40342fdb33212203' width='800' height='321' alt="Screen Shot 2024-06-19 at 8.30.57 PM.png"></img></div>No underflow, just remove value.<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/AKHSEpKaJyps7tRXAWCpxw?a=J3tYqxrh6Fo8FG8LpBDRNGaSwtI0ctwCxh3NiWPUt2Ea' id='temp:C:VbXf400e012229e47a0bebcb4844' width='800' height='287' alt="Screen Shot 2024-06-19 at 8.31.15 PM.png"></img></div>Depending on implementation, use successor or predecessor to fill remove data.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/hKhTbA54Uhy6Ob6CozhJqQ?a=AHddkTSoa4r9Q4ucQo0Jh2uuG9DgJvEm0xfZdCBqtVQa' id='temp:C:VbX1f536da4d0664264ac4a4a2fa' width='800' height='299' alt="Screen Shot 2024-06-19 at 8.32.14 PM.png"></img></div>Successor replaces removed data. This causes underflow (*).  In an underflow state, the empty node checks whether adjacent nodes have more than 1 data in it. <br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nNFOIqEmvG9O_xa0ko41oQ?a=xIxg4gUvItNKBTwqrS7U3QVmfQIbtIbOa09gakU8GMoa' id='temp:C:VbX5ed3c07b9a9d4a61a54aa9beb' width='800' height='299' alt="Screen Shot 2024-06-19 at 8.34.02 PM.png"></img></div>To preserve order of values, data is rotated from adjacent node to parent, and parent data moves to empty node.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/6hV0pqC1hni77BOXn92WhA?a=1roxUImqRQwKRhIACKGY8JrR1UM5TNzya8KAw1grNQQa' id='temp:C:VbX3de1168b9119454989448ff42' width='800' height='280' alt="Screen Shot 2024-06-19 at 8.35.22 PM.png"></img></div>Removing 31 triggers underflow, but adjacent node only has one entry.  This triggers a <b>fusion</b>: parent node’s data and adjacent node’s data is fused to empty child node.  <b>Note: Fusion can potentially cause a chain of events.</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SoPsHXXpYj4IybkgGeLfmw?a=1M0WkHkIHwHBqgRgB6aRAjqD9UfMXNcO12P6OUKqxZka' id='temp:C:VbX34c579ee3fcf40eb8095f5b9b' width='800' height='286' alt="Screen Shot 2024-06-19 at 8.37.41 PM.png"></img></div>Removing 49 triggers underflow; adjacent node only has one and parent only has one data.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qMSn74147MI5NnCDN2LgOQ?a=NukFzwJgN1eOqIiTus6M4EbIabD1HOShaJuZXQa5Pboa' id='temp:C:VbX7d0e3cd9874d45bdb8a52a311' width='800' height='279' alt="Screen Shot 2024-06-19 at 8.38.50 PM.png"></img></div>In this case, we demote the parent node data to empty child node.  Parent node is now empty.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9JEl2v0XqGXMvCStfRHriQ?a=P2G0OEsXoKeFdmQyWWGthFEUg8jEhBWj5i4QbinA5Uoa' id='temp:C:VbXf88a2d3a2de446ea80e75c85c' width='800' height='293' alt="Screen Shot 2024-06-19 at 8.39.24 PM.png"></img></div>Child nodes are fused together, and empty parent node is collapsed.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/VrEYpl3DVU4kCZvlBL9cLQ?a=sPLYpIcoXSBJBBmuDpuL1lGoWbQZMao0OBJBqi1Iir0a' id='temp:C:VbX96e57e1dd918452592a30b4ab' width='800' height='285' alt="Screen Shot 2024-06-19 at 8.41.04 PM.png"></img></div>This triggers a chain of events where root node must handle underflow.  36 is demoted and adjacent nodes are fused.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/R-Efa3gpcFj3Gm6C3esr1A?a=7GLHG4yI31ILkcBveJYPx5SsETIitarS3B9kGuRX7xwa' id='temp:C:VbXa783cedd1c024465916881ddf' width='800' height='286' alt="Screen Shot 2024-06-19 at 8.41.54 PM.png"></img></div>Root collapses, and [5,36] now becomes the root.  We end with a valid 2-4 tree.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Zq6fRDnNHxD53a3JC_bN2g?a=asHr1k6W9DjKx6CjhZttVDOWKXaJiU6YWc3JEpj3BgYa' id='temp:C:VbX556f663b865e4fbd8be8cdf20' width='800' height='301' alt="Screen Shot 2024-06-19 at 8.42.30 PM.png"></img></div><h2 id='temp:C:VbXf08d6fe2fbba4e4dbc9766b75'>Removing and Underflow, Example 2</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QIo5BYaM3P__k5IYTpfhag?a=dHidU8EnmGG8FUfcovKLBPflUfiCkcrfwyyQ6N0Mm8Ya' id='temp:C:VbX963fe274110d44909727a5943' width='800' height='311' alt="Screen Shot 2024-06-20 at 9.43.42 PM.png"></img></div>Replace with successor, triggers underflow (empty former 32 node).<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/PAOF77QJ_w_SX9iTos4FNA?a=FpnNeFuLNqDMmF8J2aHZHMu5aj96exjSC59JOrNSiaIa' id='temp:C:VbXfe479e09bb4443148e924357e' width='800' height='307' alt="Screen Shot 2024-06-20 at 9.43.58 PM.png"></img></div>Fusion: Bring down 36.  Fuse 36, 40 together. Parent node is now empty.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9YPLUrwiR0lhtja8oUPapA?a=7MIssVXsa2UxBUaaJVtRfa5mcWLUSMG2ar0DwiXga0Ua' id='temp:C:VbXfd4e7f8912e448abb0bf0385e' width='800' height='300' alt="Screen Shot 2024-06-20 at 9.44.21 PM.png"></img></div>Root node (32) moves down to empty node.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/kX2klcYhDHB0VT9VGLu7Mg?a=JNGTc0t6Qa730NFHi0eOF1c3BayiWIHKZKUcqlsEhdEa' id='temp:C:VbXf55ada65311c4b55bb38ea58a' width='800' height='288' alt="Screen Shot 2024-06-20 at 9.45.19 PM.png"></img></div>Bring up sibling data that’s closest to the (former) parent (32), which is 20.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/FL9eik8D37zldFdjV7i44A?a=rz6QdHhvcaq56GVegB7adaFJTe2m198CQ2gJfMdZqvsa' id='temp:C:VbX3a72717ead284f609e9535a19' width='800' height='294' alt="Screen Shot 2024-06-20 at 9.46.24 PM.png"></img></div>Child leaf of 24, 28 transfers to new parent (32)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Uhuy-29Ra-rRONY7VoDjNQ?a=yJJm63vda7EGrDfbRr4kOmvV2c7ITBpQ0i13GjabWTEa' id='temp:C:VbXc0b4864bb021487cb07dda1de' width='800' height='303' alt="Screen Shot 2024-06-20 at 9.47.16 PM.png"></img></div><h2 id='temp:C:VbXe00a30147ba64ef7940b63ee5'>2-4 Removing Flow Chart</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/KRtnb4tNcMNWFbRqx8wxsQ?a=9ujqsRDDSRAGvaDCEppakaWql7M0gp2avF28puPoxvYa' id='temp:C:VbXd7c1851ca5194642b3cbb98ba' width='800' height='304' alt="Screen Shot 2024-06-20 at 9.46.56 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BnSpK8UFSjkg6Bd29-tf2Q?a=z7QZagEw5awsiuG2a6JS9E27ja4puEb40sqyWtdJJE4a' id='temp:C:VbX314f6065eab0484494a9d1f06' width='800' height='329' alt="image.png"></img></div><h2 id='temp:C:VbX9cf2d6aabf0d419c8c7679c96'>Food for Thought - Link between (2, 4) Trees and Red Black Trees</h2>

In an optional section of the previous module, we discussed the advantages and disadvantages between AVL trees and <b>Red Black trees</b>. We also promised a brief discussion on the workings of a Red Black tree, which we will resolve here. As it turns out, (2, 4) trees and Red Black trees are intimately linked (this is in fact by design by the creators of Red Black trees). So much so that often, when students learn Red Black trees, they will first learn (2, 4) trees as a primer to ease them into it. We will discuss briefly the relationship between the two here, and we'll leave the inner workings/rotations of a Red Black tree for you to learn on your own.<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/91xCcFa6d489MGz9aXVTmg?a=Ibgx7DQa7B7Du8MYaCAJoO5vG0fV3g1DgSsOLBxJ9HQa' id='temp:C:VbXea68dabfb86c49b78f70298e3' alt="image.png"></img></div><br/>

So, what exactly is a Red Black tree? A Red Black tree is a BST that keeps track of the <b>color</b> of a node, allowing it to be red or black. These colored nodes must satisfy certain properties to be a Red Black tree, which we state below. These trees are often taught using <b>sentinel/phantom nodes</b>, which are nodes that have null in them. With this in mind, <b>all leaves are sentinel/phantom nodes</b>.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX6b421fe8e2a644838b4961c7f'><li id='temp:C:VbXffac631510654d17b66d6f233' class='' value='1'>Each node must have a color, either red or black.

<br/></li><li id='temp:C:VbX0a5c829ca0d74d6289283da7b' class=''>All leaf nodes (sentinels) are black nodes.

<br/></li><li id='temp:C:VbX333aec29edee46c69c6d902fd' class=''>If a node is red, then both of its children must be black.

<br/></li><li id='temp:C:VbX4b37a000a47041a6991ab1503' class=''>Every path from a node to one of its descendent leaves (sentinel nodes) must have the same number of black nodes.

<br/></li></ul></div>Notice that there was nothing in the requirements about the tree being balanced! Unlike an AVL which derives its logarithmic height from a definition of balanced, <b>Red Black trees derive their logarithmic height directly from (2, 4) trees</b>. For every (2, 4) tree, there are multiple Red Black trees that are equivalent to it, and for every Red Black tree, there is a single (2, 4) tree that it corresponds to. Roughly, each black node and its red children form a node in a (2, 4) tree (there is some nuance to this, which we omit for brevity). This relationship is what guarantees that every Red Black tree has height at most 2 log⁡(𝑛). In a sense, the add/remove operations of a (2, 4) tree are also very much related to the operations of Red Black trees.<br/>

<h2 id='temp:C:VbX273defe8d4d34a3f889c4fe22'>Food for Thought - Splay Trees</h2>

For many data structures, we study how they perform in the average case when the input distribution is uniformly random (each ordering is equally likely). However, this is almost never the case in the real world. A very good example of this is <b>caches</b>.<br/>

<br/>

Here's an example of a cache, a <b>web cache</b>. When you want to go to a webpage using your computer, your computer must somehow get your request to see the content on that page to its destination. This is not done magically, your computer forwards your request to a router first. (<b>Disclaimer:</b> This is a simplification of how this works. Networking is a vast topic, and you could take several classes learning how computers communicate to solve tasks like this one!) This is done by that router as well; each router forwards the request until we reach the final router, which has access to the destination.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/cEFSgwmX0HUGA_V0cvGjbw?a=mXc0qIkrCLFudqpexauG7D2wKyvoMQ5cY6XJkbgdW4Ia' id='temp:C:VbXd9e2ed092a1245fab53f36b5a' width='800' height='236' alt="image.png"></img></div>  <br/>

This process is generally pretty short (to us), but it can actually take a while in computer time, long enough that we can notice the delay. Web searching is something that we expect to be instantaneous, so we want to minimize this as much as possible. This is where a web cache comes in.<br/>

<br/>

A web cache keeps track of content from websites that have been requested previously. If a request is made for new content, then the web cache has no choice but to go through the standard forwarding process. However, once it's received this content, it can store it in case another request for the content comes by later. This is obviously a lot of data, so web caches will only keep track of recent data.<br/>

<br/>

So, now if we request something, the first router will check the web cache to see if it has what we're looking for. If it does, then it can just immediately give us what we're looking for. This on average saves quite a lot of time!<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qs_JHWu7suirPTvwkVcZIw?a=P3NIPOCa77BS4bbx03sl9R7IczjqWeftj7w9gp9W5ZMa' id='temp:C:VbX59b4b6c71c9a4a6bbfb908857' width='800' height='404' alt="image.png"></img></div>So, now that we have an idea of what one type of caching is, let's look at one potential data structure.<b> Splay trees</b> are another type of BST that performs rotations to maintain its structure. However, unlike AVL trees and (2, 4) trees, it doesn't attempt to maintain a strict balancing scheme. Instead, it works under the following principle: "If data is queried in the BST, then we want to perform a series of rotations so that the data is now at the root." These rotations are referred to as <b>splaying</b>, and the different types are <b>zig</b>, <b>zig-zig</b>, and <b>zig-zag</b>.<br/>

<br/>

So, what does this accomplish exactly? <b>Over time, data that is queried often (popular data) will be kept closer to the root, while data that is queried very rarely will sink to the bottom of the tree.</b> Data kept closer to the root have shorter search times, so popular requests will be answered quickly. In other words, if there is a bias in the input distribution (how often something is queried), then splay trees will do very well.<br/>

<br/>

What about if the input distribution is drawn uniformly at random? Then splay trees won't do as well as their balanced counterparts since splay trees don't have strict balancing (the degenerate tree is still possible). However, while the worst case of a single search operation is 𝑂(𝑛), we can show that <b>any sequence of search operations will average𝑂(log⁡(n)) time</b>. So, it does have a worst case of <b>amortized </b>𝑂(log⁡(𝑛))! We haven't seen amortization outside of the context of array resizing, so if you want to see amortization in action with a more complex procedure, then look into splay trees!<br/>

<br/>

<h1 id='temp:C:VbXdeaca73c67f84998b523c6e40'>END OF PROBLEM SET 2</h1>

<h1 id='temp:C:VbX385e433045a8438794984cecb'>Module 10 - Sorting</h1>

<b>Module Overview</b><br/>

This module marks the start of the second half of the course sequence, algorithms! An <b>algorithm</b> is a finite procedure/mechanism used to solve a problem or perform some computation. In a sense, much of this course sequence has already been about algorithms; however, we have only encountered algorithms with respect to data structures. Now we are flipping perspectives, where we will examine how to solve problems using all of the tools (data structures) that we have added to our toolbox.<br/>

<br/>

Our first meeting with algorithms will be <b>sorting algorithms. </b> Sorting algorithms will span both module 10 and 11. In this module, we cover the more simple, "naïve" sorts to get our feet wet. We will refer to these sorting algorithms as <b>iterative sorts</b> since they all inherently rely on making multiple iterations of the data, fixing unsorted pairs. Once you're familiar with basic sorting algorithms, we'll dive into more complex and efficient algorithms in the next module.<br/>

<br/>

<b>Learning Objectives</b><br/>

Students will:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX22443e8146e344ecbc9bd5b49'><li id='temp:C:VbX923cf8ef0c4b43068874701fd' class='' value='1'>Encounter the naïve 𝑂(𝑛2) sorts: bubble sort, insertion sort, selection sort, and cocktail shaker sort.

<br/></li><li id='temp:C:VbXd723c99494a747c687f5f1928' class=''>Understand the inherent limitations of the iterative strategy used by the naïve sorts with respect to their time complexities.

<br/></li><li id='temp:C:VbX340f166cc51140a48fdda6c05' class=''>Reason about properties of sorting algorithms beyond time complexity: stability, memory placement, and adaptability.

<br/></li><li id='temp:C:VbX752b026424ec40579deccc93f' class=''>Learn about the idea of algorithms as solutions to problems in their own right, rather than details of data structures.

<br/></li></ul></div><h2 id='temp:C:VbXe64823a2a031481e800f41dc4'>Introduction to Sorting</h2>

<h3 id='temp:C:VbXcb3984bec09645f1bb0523508'><b>Algorithmic Problems and Solutions</b></h3>

Now that we've begun our journey into the algorithm half of the course, it's worth the time to take a moment and consider what is the goal. For the first half of the course sequence, we built up a large toolkit of techniques and data structures that could be used in a variety of contexts.<br/>

<br/>

In this second half of the course, we turn to solutions for <b>specific problems rather than general data structures</b>. As such, for each problem we try to solve, it's a good idea to formally state the format of the problem. For example, when we say "sorting," we're referring to the following goal:<br/>

<br/>

<b>Input:</b> An array of 𝑛 data that have some predefined consistent ordering (i.e. the data is Comparable).<br><b>Output:</b> The same array of 𝑛 data that has been permuted to be in ascending order as determined by the predefined ordering.<br/>

<br/>

This specification may appear unnecessary, but it is essential to understand the nature of the problem. For example, we have specified that the output array is to be the same array in memory as the input array, or that we have specified the sorted order to be ascending. Neither of these specifications make the sorting problem more difficult than before, but we must be sure of what exactly is the goal and how the input is specified. For example, if we require that the input is an array of integers instead, then the problem becomes easier (in a sense) as we'll see in module 11.<br/>

<h4 id='temp:C:VbX283d77dff8a1483d80c2d6713'>Analyzing Sorting Algorithms</h4>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa4bc19f0aec1487bbd15fb407'><li id='temp:C:VbX2caa7f7da61f4734bfe5b0613' class='' value='1'>TIme Complexity

<br/></li><li id='temp:C:VbXc3ec1d18d8c4478384f4de96b' class=''>Stability

<br/></li><li id='temp:C:VbXcb729f4714fa4e259f4c975bd' class=''>Adaptivity

<br/></li><li id='temp:C:VbX45aba647b74240ad8a817c125' class=''>Place

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5tYF1u4b2COmEO0-SKZ6RQ?a=sad13cs0zszJICt95FrqPlPoXZaoCDgXOYK3JLpYH4Qa' id='temp:C:VbXdef98e55fef44f45922a2a18e' width='800' height='248' alt="Screen Shot 2024-06-29 at 6.19.41 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CvfkB2xeMJuAJYKqb4WwTg?a=EkBt2qEaLWnW2gHaWCAl6P9j9zf63lELdZOUqCnUXYka' id='temp:C:VbX31f63baca9fd409681293a7fb' width='800' height='201' alt="Screen Shot 2024-06-29 at 6.19.59 PM.png"></img></div>To become a problem solver, there are core skills one needs to develop. This development in skills comes from taking the time to understand<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX8a3d38d12ee74a7baf5ad3fa9'><li id='temp:C:VbX888c4090db974cb6b2cac9fe0' class='' value='1'>the general behavior of an algorithm

<br/></li><li id='temp:C:VbX546ccc548aeb446d832588f31' class=''>the edge cases that the algorithm must solve

<br/></li><li id='temp:C:VbX77b6719701ba4278b80451693' class=''>the issues that arise during the implementation

<br/></li></ul></div><h2 id='temp:C:VbX492eaab632bd43239b5fb05e7'>Bubble Sort</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Zp44dG2bhZlC8AKrlcSE7g?a=jq8ZElNcgtFDNf2R8Km7IbsaVTaffphweZ12kBR3Ujga' id='temp:C:VbX52ef5e04f32c4fd3ac76c6143' width='800' height='379' alt="Screen Shot 2024-06-29 at 6.21.57 PM.png"></img></div><span style="color:#218118" textcolor="#218118"><b>Key Idea: Start from front and compare first two items. If they’re in wrong order swap, if not move on.  Keep looping in incremented index until reaching end of array.</b></span><br/>

<h3 id='temp:C:VbXc2a73ca7a045483f8c16850c8'>Optimizations</h3>

Optimization: If swap is made boolean is set to true<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Sp-SrYeyEmtgO5F2gLGARg?a=0qWp5yNZv4eMbQLOGsGaEpDV0V53U1LvReIhGv0JxK4a' id='temp:C:VbXa48d1d5639144741b14731a22' width='800' height='305' alt="Screen Shot 2024-06-29 at 6.23.00 PM.png"></img></div>Optimization: When the last swap has occurred.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ARraCw8wP6tL9p1lKmtVKQ?a=fRgESFh79sG8gM8Tx59gn6pUB9TP5631my5HClQa2HYa' id='temp:C:VbX99459ea16f7b401aa1ad63f37' width='800' height='284' alt="Screen Shot 2024-06-29 at 6.23.36 PM.png"></img></div>From Sarakrishna slides:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/IcPLrsvPWCrAnFW08chYgA?a=TQdDiSim8wO5BcsJyp9dFyjG4OaH2SLXdrQJaJuxQCIa' id='temp:C:VbXc324e51d607f4be99f23472bf' width='800' height='501' alt="Screen Shot 2024-06-30 at 10.03.02 PM.png"></img></div><h3 id='temp:C:VbX42ba0f2d7c1e40ee9ba54f82c'>Time Complexity of Bubble Sort</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Eoy0WjkjfmMvPUPiyOELPA?a=pgUGjuDYqEqQa28ID9GnoqnLXUVnGpdlxuaA4mqk7ZYa' id='temp:C:VbXd55f82a58b4140c9bf83cc44c' width='800' height='369' alt="Screen Shot 2024-06-29 at 6.25.09 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX1bfc56ecb425402e889f68f1b'><li id='temp:C:VbX8f38ea2fc87d45da8a5c826b7' class='' value='1'>Best case: Array already sorted.  Just loop once.

<br/></li><li id='temp:C:VbX48ebe0c6d9264b0c816e81608' class='parent'>Worse-case: Reverse sorted array.  

<br/></li><ul><li id='temp:C:VbX79a4ea6d8abc4214ae5001654' class=''>Double-nested loop must run all the way through, O(n) * O(n) = O(n^2)

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/yugy75HIXpOvLTvBWqbbkw?a=mr4tNNFctOlUFCJmAjDsczwkFSo8sHFiKbcmVpBBXZIa' id='temp:C:VbX411c5d242194418689aa35300' width='800' height='107' alt="Screen Shot 2024-06-30 at 10.03.55 PM.png"></img></div><h2 id='temp:C:VbXe37ce4846848424ea232e041c'>Bubble Sort Example</h2>

<h3 id='temp:C:VbX266bf1eb92734fe7910a4ac15'>Example 1</h3>

<h4 id='temp:C:VbX8492cca7fcd34671adaf1ce51'>First outer loop</h4>

Orange: Cells swapped<br/>

Blue: Sorted cells<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1b597bac60e24ce688040c47a'><li id='temp:C:VbX1ac223476dbe43d395969c72a' class='' value='1'>At end of while loop, everything after cell 5 is in order, so we set stopIndex at cell 5.

<br/></li><li id='temp:C:VbX870abbe8c466404b971741e9f' class=''>Outer index is still set to 0

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oaWBT-XHEvaLslPS7u4D5Q?a=ubsaOvLAMxpkgJqYe9nLDX6syLibNCglud5UEpD7ulAa' id='temp:C:VbX2f9f69161ab34752871c66138' width='800' height='360' alt="Screen Shot 2024-06-29 at 6.28.09 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SL88jP_CAlitq0RjIJsX8g?a=u5yrSWrqvoZsq8jwaJPkIhzOcY2iQ7qOqe2C4BbPak0a' id='temp:C:VbX0ee24d064f44441ba81f2acbc' width='800' height='313' alt="Screen Shot 2024-06-29 at 6.30.04 PM.png"></img></div><h4 id='temp:C:VbX233e054c912446a1a88a2887e'>Second outer loop</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb33d91290bb349f790cae7aeb'><li id='temp:C:VbXdb449eb9e41d4b4b9109753fa' class='' value='1'>stopIndex is set to 3

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qQE1pJUh4QAVEYFiOuZb3A?a=f1mQIa3jEKwQTzaP6ux0tHVzqjsgF7dZGwsvvSywA0ca' id='temp:C:VbX47225c95ae644441a96127838' width='800' height='319' alt="Screen Shot 2024-06-29 at 6.30.58 PM.png"></img></div><h4 id='temp:C:VbX1f8e15a6f91a4080bb83729f5'>Third + Fourth outer loop</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/anOQ7q3JFEm6tP1976k3aA?a=r8IEiA1Rh603cBBx0m7avl6dv64l9yeajC65OzG4SToa' id='temp:C:VbX28b2d4d3bc31488b82d1baa06' width='800' height='322' alt="Screen Shot 2024-06-29 at 6.32.14 PM.png"></img></div><h3 id='temp:C:VbXd6cb42603c01478f91f07c480'>Example 2</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX82abf8f716d348b3b9442e62e'><li id='temp:C:VbX141b441a4e914324a4fd03d0b' class='' value='1'>No sorting necessary, but still needs one full iteration to determine that array is sorted.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nRRz9DHsSlSrif-6_npAyw?a=3i3WElE4mb26hnjMu4p0Gha5jCabITvRlDbNG4Jn1uQa' id='temp:C:VbXb44f0a2a86b74f07b0ea93162' width='800' height='363' alt="Screen Shot 2024-06-29 at 6.33.38 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LQlvT0b7rrBA_q7AYRid-A?a=gKHwZOpECaIo3nQiVGAsyB0xrCmdrnZiIr9B9qnninYa' id='temp:C:VbX8378b4ad750d4ac0ba31efc25' width='800' height='310' alt="Screen Shot 2024-06-29 at 6.33.44 PM.png"></img></div><h2 id='temp:C:VbXb557e7fc606a4d34af1ca7520'>Insertion Sort</h2>

<h3 id='temp:C:VbXa50fa37f088f4a35a3da16bf3'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/MVaVWQ4RHV9t4ys7uYCBfw?a=Aba1DrMnkxXeqY7Vrv8lgRqe8owFlfs7apRSk8ybPjAa' id='temp:C:VbX32505c59f2a44f03a6a99fac5' width='800' height='314' alt="Screen Shot 2024-06-29 at 6.46.51 PM.png"></img></div>From Sarakrishna slides:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dG0bKY7Lxu20cmi7hrWXfw?a=5AzdbWeacFhFmNELgRiawQr4KIHFQ4aC2eBRTVZDp8ca' id='temp:C:VbX22499b37abe5442ab5977af6d' width='800' height='332' alt="Screen Shot 2024-06-30 at 10.05.37 PM.png"></img></div><span style="color:#218118" textcolor="#218118"><b>Key Idea: Sort of reverse of Selection Sort, start from front and push minimum to front.</b></span><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX23f77c20f8a648799281837a0'><li id='temp:C:VbXd04ea1d4ac90485e9f33821b3' class='' value='1'>Assumes first item is sorted.

<br/></li><li id='temp:C:VbX90d83d556cb140539b0bf2318' class=''><b>Unlike bubble sort, a fixed number of iterations are done for insertion sort.</b>

<br/></li></ul></div><h3 id='temp:C:VbXdf71ee3f94b44f59a8d17936f'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/jmDmh_QqeyKZHzZboxWemA?a=mz0qaaGnqX6A1aPghWZe0xpH97SrAQah4Gq1Erbz5D8a' id='temp:C:VbXb60af234ffa244a08705aea88' width='800' height='375' alt="Screen Shot 2024-06-29 at 6.44.35 PM.png"></img></div><h2 id='temp:C:VbX17a45bb497954cb58e379d239'>Examples</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/DyvCR6e1i1nmZKD8ZSJsag?a=akGGNfVaOoapGAxzZdWO1I91CPrHxDpgUDvkgULeypoa' id='temp:C:VbXc36ad5ffa54749c49a42e897f' width='800' height='313' alt="Screen Shot 2024-06-29 at 6.48.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Afl6XbffxATOizP2eTI43g?a=olh1Zh83eEX1gLXFw3OZfYrrXN7zJ8D60p4znNSEo6ga' id='temp:C:VbXa0b18cd24c994e9b84886671e' width='800' height='310' alt="Screen Shot 2024-06-29 at 6.49.05 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9Kx8ft1IHUBwx61rXdtLJQ?a=14jvam22OY0Ra8wDoWn1Cme6E2QLngHlzdU2R6D34yIa' id='temp:C:VbX4eea32b17b1241a5b323a8f21' width='800' height='311' alt="Screen Shot 2024-06-29 at 6.50.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/KG4Gww5NJSI8Jzom1JHgzw?a=sVFf9964ksGeI2ppbK9d8dRBlddHZzNbn5aFUamWuo4a' id='temp:C:VbX19b94ba68416468fbc5dfd064' width='800' height='310' alt="Screen Shot 2024-06-29 at 6.50.21 PM.png"></img></div><h2 id='temp:C:VbX436fdba5af0847cc9278e0ef1'>Food for Thought - <b>Beyond Traditional Computation: Streaming Algorithms</b></h2>

Insertion sort has a somewhat interesting property that we'd like to point out here. In the modern world, datasets are starting to become very large, to the point that it might not be realistic to expect a machine to be able to store the entire dataset in active memory to work with. So, rather than being given all of our input all at once, we instead received data in a <b>streaming</b> fashion? There are various proposed models, but we give one below.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8bpz7-Zt3s_zS6bxrLnjjw?a=vKYiiiy7DjZ4a4Q7yCwsHd8TPyZnnUFFQwaFXMUCP8sa' id='temp:C:VbX48c6e27c4db94fd881a221964' width='800' height='331' alt="image.png"></img></div>It's worth taking some time digesting the streaming model and the nuances involved. To reiterate, the input size might be very large, so even storing it is prohibitively expensive. So, the best that we could hope for is to "summarize" or "sketch" the important characteristics of the data as we receive the data in the stream. Ideally, the computation time for each item (the update time) should be small too, hopefully not much more expensive than 𝑂(1). Then, at the end of the stream, we use our sketch to finish the computation and solve our problem. If you reflect on various problems you know how to solve, then you'll soon find that this model is very difficult to work in and is an active area of research!<br/>

<br/>

For example, suppose the problem is "How many <b>distinct</b> items are in the dataset, assuming there can be duplicates?" In a traditional model of computation, we can solve this in 𝑂(𝑛) on average (you have the tools to solve this problem if you've completed courses I and II, so try to think of a solution!) As it turns out, if we want to solve this problem exactly, then we need Ω(𝑛) memory too, which is no good in the streaming model! We can do better, but only if we allow some error in our answer. Giving approximate answers and using randomization are common occurrence in the literature of streaming algorithms.<br/>

<br/>

Let's circle back to insertion sort, which is what triggered our discussion of streaming algorithms in the first place. In this model, the problem of "Sort the dataset." doesn't make too much sense anymore since we can't store the entire dataset anyway. Instead, let's relax our problem to answering the question "Is the dataset in streaming order sorted?" This is a significantly easier problem, we just store the maximum item seen so far. If the next data is smaller, we know the dataset is not sorted. This is reminiscent of insertion sort, except that we don't bubble backwards to insert the data in the correct position. In fact, if we remove the space restriction and only look at the data stream portion of the model, then insertion sort is the only algorithm we'll see in the course that can sort the data as the stream progresses.<br/>

<br/>

To the best of our knowledge, streaming algorithms were first discussed by Munro and Paterson in 1978, but the idea and model was popularized in 1996 by Alon, Matias, and Szegedy. We'll cite these papers in the module review section later if you're interested in taking a peek, though keep in mind that they are rather theoretically-oriented. Streaming algorithms have many applications, but they are often useful for networking applications, in monitoring network traffic for abnormalities or other properties of interest.<br/>

<h2 id='temp:C:VbXda06817332604eb387085d79d'>Selection Sort</h2>

<h3 id='temp:C:VbX68c0383376c246628a2ca2e37'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/U-HRPbDkh0YD_TOzn4PvKw?a=sUcrOaXmvrf7HMX9bnPmH0xf2wwLqv6kbVA6QNksd2wa' id='temp:C:VbX79351b2310644f5191796591e' width='800' height='323' alt="Screen Shot 2024-06-30 at 9.22.06 PM.png"></img></div>Max approach<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BAA8ProquPeMp6rHfL6ZQQ?a=XtRivartJW6c2WUNVdbyyZ7QxmiAQZuqt4mpScNoseAa' id='temp:C:VbX6aade8ab15c146e2bbf9393e7' width='800' height='261' alt="Screen Shot 2024-06-30 at 9.23.31 PM.png"></img></div>Min approach<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/cpcMa-tqpnEp0oPT33Kwkw?a=EFWOSQMKH0xEfrKKk7F23lQwTTkGhyVrcOyCnbeiaI8a' id='temp:C:VbX2ed8974c77f14583937796388' alt="image.png"></img></div><br/>

<h4 id='temp:C:VbX61d04f06755f41a5a1cef5e2d'>Saikrishna slides</h4>

(Uses minimum index approach)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nsXpXGrE8oAXArEQz6aX-Q?a=4PIZUsSpjSgsK3j0a0OV7wY9PNMweaaR7Ta330J9Hcga' id='temp:C:VbXb2f454478be44cd9b6c1c45ba' width='800' height='413' alt="image.png"></img></div><b><span style="color:#218118" textcolor="#218118">Key Idea: Start from back and push max to the end.</span></b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXbc4d97d4f00c49ddaa5bf7732'><li id='temp:C:VbXef71f705a5fd4c3883ddb661f' class='' value='1'>outer loop goes backwards from the end

<br/></li><li id='temp:C:VbX59d74014daaf46ecbfa10c1c0' class=''>inner loop starts from index 0 to n

<br/></li></ul></div><h3 id='temp:C:VbX52edb7e26fa54366aec1ccc99'>Time complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sNlNZ4HUOCMFLuzZ21uhOw?a=c1JBZmjszHswh9mqfgfptzapVxlsWOy1iUyOZklpzYga' id='temp:C:VbXf08111bd14b443889fcf4deb8' width='800' height='325' alt="Screen Shot 2024-06-30 at 9.24.14 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX601c413c88a944a9872cc6467'><li id='temp:C:VbX02afe53bab4940978cb80f682' class='' value='1'>Best case is NOT O(n)

<br/></li><li id='temp:C:VbXdbad8160cb554b86b5a265c3f' class=''>Unstable: No previous information about the array is kept.  This is why its always a double nested loop thus O(n^2).

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/S_JQOhPKOZZvC_CCWde8Xg?a=aaqfH6AaUFRnrnbr69E1Ted7qhq81qc4SfojpC2Ectka' id='temp:C:VbXb41f6e8963f2496b89b8fc6ee' width='800' height='148' alt="Screen Shot 2024-06-30 at 10.06.57 PM.png"></img></div><h3 id='temp:C:VbX2d2dd0ee7ea942d6bb7151656'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/xR5zXq6zOOo8-SV5HBsigQ?a=NASGl6ewPv9LFbowZzPJhirvMV7qT62Cof9u4zSIEFMa' id='temp:C:VbX4e3a4e01c4844963bfcc1868b' width='800' height='307' alt="Screen Shot 2024-06-30 at 9.25.18 PM.png"></img></div>Example of long-swaps - why this algo is <b>unstable</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/U9_7i1rQ23hnp6U68aHHAQ?a=1yCAnZhaQa6P4IaNKlP2sosokaXBQI9xLihSaOpiVrQa' id='temp:C:VbX4961c166043c4618a81c3fdca' width='800' height='243' alt="Screen Shot 2024-06-30 at 9.29.08 PM.png"></img></div><h3 id='temp:C:VbXae14b029e74a4f6f8ac590b65'><b>Food for Thought - Beyond Traditional Computation: Sublinear Algorithms</b></h3>

Selection sort is the first sorting algorithm we've seen where the best case is not <br>𝑂(𝑛). In a sense, bubble sort and insertion sort have optimal best cases because it takes <br>Ω(𝑛) to read the input! We've seen some operations that do better, but that's only if we assume strong things about our input (for example, binary search takes 𝑂(log⁡(𝑛)), but a sorted input is a rather strong assumption). Like in streaming algorithms, this lower bound based on reading the input is only true in the traditional model of computation. What if our data set is large enough that even reading the entire dataset is too expensive? Then, we need to look at <b>sublinear algorithms</b>, which have time complexity smaller than 𝑛. In this note, we'll be looking at a specific class of sublinear algorithms, known as <b>property testers</b>.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LcNd-dCehb5fg1Nlw39GRg?a=oB9cfRATU9mgMFJRwetQltOX8aImbTlyga5BEFvwnawa' id='temp:C:VbX9b57b010596d4ddb90930d654' width='800' height='397' alt="image.png"></img></div>A property tester is an algorithm that checks if the input satisfies some property. For example, we may ask whether our array is sorted or not. Since we're not even reading the entire input, we cannot hope to answer correctly for every possible input. So, we need some parameter <br>𝜖 to quantify what inputs our property tester should work well for as well as some metric for how "far" our input is from satisfying the property. For example, our distance function might be "How many swaps are needed at a minimum to sort the array?" and 𝜖=12 would be saying our algorithm should be able to distinguish a sorted array from an array that requires half of all possible swaps to sort with high probability.<br/>

<br/>

Similar to streaming algorithms, this is a very difficult model of computation to work with, and it is a relatively newer area of research. After all, we are only reading a small fraction of the input and trying to determine whether the input satisfies a certain property from that small amount of information. By the nature of things, many properties seem to require reading the entire input to test for them well, though research is actively working to better understand where this line in the sand is. This answer is rather unfortunate, but it is not entirely unexpected. There are many properties out there where there is no "locality" information; learning about data in one location may tell us very little about the rest of the data.<br/>

<h2 id='temp:C:VbX49171aa51c1942e6ad1bb315f'>Cocktail Shaker Sort</h2>

<h3 id='temp:C:VbX847c7221ed3a4888823414661'>Pseudocode</h3>

(With last swapped optimization)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/TpiGm53wESyWc1liPO-U7Q?a=OqeObzAmaLXTELHGGOWfTaKe4m0avCdEtWtXyAtatfsa' id='temp:C:VbX6c4f9681e99d4cdab2782b788' width='800' height='384' alt="Screen Shot 2024-06-30 at 9.34.30 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/X06j8UxI3ciqFZXQCiVWlw?a=NWPUOO5Uz3FlHMlClliZauaTfagpVmYq7BZxa5VOhdka' id='temp:C:VbX1dbafcf37eda48c4bc324b479' width='800' height='419' alt="Screen Shot 2024-06-30 at 9.35.48 PM.png"></img></div>Key Idea: Modification of bubble sort<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXd7d575f8ba374150b734a2cd0'><li id='temp:C:VbXadf3613470484f7887ce00cce' class='' value='1'>Two iterations of bubble sort each iteration, one bubbling the maximum to the end of the array, and one bubbling the minimum to the front of the array. 

<br/></li><li id='temp:C:VbX60ca112d42234c6699894e33e' class=''>By doing so, we mitigate some of the more pathological cases of bubble sort.

<br/></li><li id='temp:C:VbX152345622d81485f8f3239ec6' class=''>Outer loop <code>end &gt; start</code>

<br/></li><li id='temp:C:VbX9685c8e846f04a988f03178e5' class=''>Inner loop - 2 loops, front to end + end to front

<br/></li></ul></div><h3 id='temp:C:VbX0b8a3395521a42388061bee5a'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dju9YcQAgJT7-osYwB-DxQ?a=n4RnRmi2EMYBOKqBew44RNIDAYjWaFyK1K5ZfnKuW8Ya' id='temp:C:VbXa3fdc12425814af09db768645' width='800' height='349' alt="Screen Shot 2024-06-30 at 9.37.39 PM.png"></img></div>Best case: Already sorted array, O(n) - one iteration and done.<br/>

Worst case: Reverse sorted array, O(n^2).  Same as bubble sort.<br/>

Benefit to bubble sort: Sorted array except last index which is minimum.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa3c6d598b78e432b90335aa13'><li id='temp:C:VbX2ba14403ff0a44f289ec938c7' class='' value='1'>Bubble sort will have to O(n^2)

<br/></li><li id='temp:C:VbX3f89bf61b64746eeaeb360cbd' class='parent'>Cocktail shaker will get this done in two iteration, since it goes forward and backwards.  

<br/></li><ul><li id='temp:C:VbX1ee514b37801429881ce7b681' class=''>First iteration - Backward swap will continually move the min to the front of array.

<br/></li><li id='temp:C:VbX7e16dbdc3b6241b89406a0ff1' class=''>Second iteration - check all is sorted.

<br/></li></ul><li id='temp:C:VbX7c8ad62fdb9647268cacb6f89' class='parent'>Example: Array size of 5 (2,3,4,5,1)

<br/></li><ul><li id='temp:C:VbX36773f55e7c043d382b6044c3' class=''>Bubble sort: comparison count = 10

<br/></li><li id='temp:C:VbXf486ec4134354448b4a2f25ac' class=''>Cockatil sort: comparison count = 9

<br/></li></ul></ul></div><h3 id='temp:C:VbX284e5d3c77444b6abd18b102a'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/DRdt0k1lD5VgHw70w_GaSA?a=c89oXA0r0NM3THzNaW2CW3JbL9baaaWbOgwkuwX64joa' id='temp:C:VbX5ec0e34cc618449f80c6d09a2' width='800' height='307' alt="Screen Shot 2024-06-30 at 9.40.19 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SFP1CZWy6LRAV6zrypBKbQ?a=Z9vYaSlm13hWLTIKjrSwWzVP4JKozKr7GB4jHRcL570a' id='temp:C:VbXe21eccbb31124a14a26981513' width='800' height='313' alt="Screen Shot 2024-06-30 at 9.41.09 PM.png"></img></div>2nd nested loop starts from index 7 (where swap occurred)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eULZ3VeNTJjbmcyne8OIHg?a=xoqsVNaQigaiySUirPfjp7z3uoshwVKEa6rhop7yEIQa' id='temp:C:VbXd396cf89710b455a806330e45' width='800' height='309' alt="Screen Shot 2024-06-30 at 9.42.21 PM.png"></img></div><b>End of iteration 1 - last location of swap is index 4.  2nd iteration’s start index is 4.</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ar5tjWzYoDTZ5okb3K3ozQ?a=0wlh1scvauafRaRFzWqrQygWkut32thqUW4qeNab5RYa' id='temp:C:VbX03f4852cfc954b3bbfdb6bc9d' width='800' height='305' alt="Screen Shot 2024-06-30 at 9.43.47 PM.png"></img></div>Last swap was index 6 so backward starts there.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/iCsiCJ_pJlVtCvyIlBHHWg?a=q8SpqxAnwCwivUbh2YUc9PQdVsyatnekYkejWeeWPMQa' id='temp:C:VbX71b38597c4d945f4866d65293' width='800' height='305' alt="Screen Shot 2024-06-30 at 9.44.29 PM.png"></img></div>Can set a terminating condition, or just let it run to its end.<br/>

<h2 id='temp:C:VbXaeff81d7a88f4072aec8f8c80'>Iterative Sorts: Review</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/z-UX9lgQbK2LENqz4B9mPA?a=zbBKh3kdQYxvyCIngIrqlTneJoOAtKwWjSXRSFMDK0Ia' id='temp:C:VbXe1423d226271447c84ec64a05' width='800' height='171' alt="image.png"></img></div>Bubble sort bubbles the maximum item to the end of the subarray. The subarray's search space decreases based on where the last swap occurred.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/bxpaFxsDnELGthnhEBPhxw?a=RjqaauVpP6AREDBOghXyVNatEIBmAujoOZhbW2quBJca' id='temp:C:VbXd8984ecca8ea4449a4a2786bc' width='800' height='223' alt="image.png"></img></div>Insertion sort maintains two parts, the left part is relatively sorted, and the right part has not been looked at yet. The border between the two sections moves rightward in each iteration, and the item that has switched sides is inserted into its correct relative position in the sorted part.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GpcN6Jp0ZfQhhmKCidKfJw?a=8UzobQR2XTzb6LMvkGQYRYsa3ihRU1gcmzuO2Zwft8ga' id='temp:C:VbXc2c14f3f51d04a608aab48c2f' width='800' height='199' alt="image.png"></img></div>Selection sort looks for the maximum item in the subarray and swaps it into its correct position. The search space decreases by 1 each time.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/B_cxNj4O3XfCYdgQgXqseA?a=2ahDvJ4SJaDsT5246Dug3utejvHetKpacoaPlL5aTAwa' id='temp:C:VbX6d6f0c57ff1241188a5a38a05' width='800' height='246' alt="image.png"></img></div>Cocktail shaker sort is a modified bubble sort, where each iteration is composed of two bubble sort iterations in opposite directions. The first iteration bubbles the maximum to the end, and the second does the opposite. The search space's bounded are modified based on where the last swap occurred in each half iteration.<br/>

<br/>

<h3 id='temp:C:VbX35697b3deb6b4972ab96e8597'>Takeaways:</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX7818e7342dce4e3797a2da587'><li id='temp:C:VbXa78eba90841b4273b31b72573' class='' value='1'>Bubble and Insertion Sorts are considered adapative, in that the algorithms will recognize if the array is already sorted and terminates early.

<br/></li><li id='temp:C:VbX0cdb20b5355043f782765c6e5' class=''>Selection Sort perfectly demonstrates how inefficient an algorithm can be.

<br/></li></ul></div><br/>

<h3 id='temp:C:VbX69052350d3924e54ab7e1ac9e'><b>The Usage of the Iterative Sorts</b></h3>

The four iterative sorts that we've covered in this module are more demonstrative than anything else. They are rarely ever used in practice because <b>quadratic performance on average is expensive for sorting</b>. There are <b>two cases where they might be used</b>.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX2267b86f628c4cd09bb7ca0de'><li id='temp:C:VbXb784fcbdaf4743b28b5a32e13' class='' value='1'>We need a simple implementation of a sorting algorithm, and the <b>amount of data is small enough that quadratic performance isn't bad.</b>

<br/></li><li id='temp:C:VbXd4d927cb5c3d439d8e5f5fb92' class=''>The <b>size of the data is small enough</b> that the overhead of implementing more complex sorting algorithms is not worth the asymptotic performance gain.

<br/></li></ul></div>In most cases, one of the sorts in the next module (or a variation) are used instead since they are more efficient. However, it is worth it to take the time and see why the iterative sorts don't perform very well. Each of them are simple and intuitive, but it's very common that the first ideas you come up with that are clean and simple will be inefficient and naïve. It is as important to see algorithms with instability and quadratic efficiency in order to recognize these characteristics in other algorithms and avoid them.<br/>

<br/>

<b>Each of these algorithms have the problem that in the worst case, the search space decreases by 1</b>. In other words, we sort everything together, meaning that each iteration must go through (most) of the data. So, what if instead, we tried to split up the data, and sort the smaller parts? This way, while we'll have to sort multiple parts, these parts will be smaller, so each sort will have to inspect less data. Then, we can combine the sorted parts together in an efficient way. This is precisely a divide and conquer approach, which we'll be exploring in the next module!<br/>

<br/>

<h1 id='temp:C:VbX42e6cde3f09343a2a3395cca0'>Module 11 - Divide and Conquer Sorts</h1>

Key Idea:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe7fe8f4666754273894013354'><li id='temp:C:VbX4b8182b3b68e43cea9f0c2304' class='' value='1'>Use recursion to tackle sorting (instead of iterative)

<br/></li><li id='temp:C:VbX581aede443c044f1aeb667c24' class=''>Recursion avoids looking at the same data too many times.

<br/></li></ul></div><b>Learning Objectives</b><br/>

Students will:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5c0904d1d22742d7b3af30934'><li id='temp:C:VbXa2acce74e2cf4121bcae7c4f7' class='' value='1'>Apply the divide and conquer paradigm to develop sorting algorithms that beat the quadratic time complexity of the iterative sorts.

<br/></li><li id='temp:C:VbX8648209424b44d07b11a1ee01' class=''>Learn about a host of more advanced sorting algorithms: Merge Sort, Quick Sort, and LSD Radix Sort.

<br/></li><li id='temp:C:VbX6afbfe6a7b62414e9066229b0' class=''>See how algorithmic techniques for one problem might be flexible enough to apply to others (Quick Sort v. Quick Select).

<br/></li><li id='temp:C:VbX30d6f343435047068174e70b9' class=''>Realize the limitations of comparison based sorting and how other ideas might aid us in getting more efficient algorithms.

<br/></li></ul></div><h2 id='temp:C:VbX355f882634de4e03a75bfe6bd'>Merge Sort</h2>

<span style="color:#218118" textcolor="#218118"><b>Key Idea: Break up problem into halves recursively, then merges them back together as it bubbles up.</b></span><br/>

<h3 id='temp:C:VbX79821744eec14bdda09bb17fd'>Pseudocode</h3>

Part 1: Partitioning<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0wL_BYzBnnPt88e9pC00sQ?a=yrE724II54wiR9zHHlgSBFL98tmxtuMMRXqjaCOCUhYa' id='temp:C:VbXda64445a072c442fa61ad9dd9' width='800' height='372' alt="Screen Shot 2024-06-30 at 10.16.43 PM.png"></img></div><div class="" data-section-style='6' style=""><ul id='temp:C:VbX5a87e5a0e20f463a96c204e55'><li id='temp:C:VbXe41fbb8154c54668b8a0d9683' class='' value='1'>Base case: Length = 1.  Just return.

<br/></li><li id='temp:C:VbX69fbd625b01442bf8c60cd003' class=''>Find midpoint

<br/></li><li id='temp:C:VbXcc3d43662dff4d3d83ad486e3' class=''>Split array into two halves

<br/></li><li id='temp:C:VbX430cefc442204b3789b7012d8' class=''>Apply same method on two halves

<br/></li></ul></div>Part 2: Merging<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nQfFPz_bC55sh9IpayPsIQ?a=0r4lUcQzloRViErE9MIY0TleXdNXLEyQpadZkgoI8zQa' id='temp:C:VbX03f2dc4408d34c47ae0044646' width='800' height='377' alt="Screen Shot 2024-06-30 at 10.18.31 PM.png"></img></div><div class="" data-section-style='6' style=""><ul id='temp:C:VbX2d737d1df4324eb79d19368df'><li id='temp:C:VbX404c5f0247c44a8396f25c106' class='' value='1'>Set pointers for subarrays (highlighted)

<br/></li></ul></div>Part 3: Emptying one of the subarray when the end of the other subarray is reached.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CrfhdzGUn-afQa5eca7jiQ?a=ntUeBBrRepTnpw3GSlaBSOjvW0ngeD0IROB4PuPi8NAa' id='temp:C:VbX2c9cc5fb9dae4795bdc66b61b' width='800' height='338' alt="Screen Shot 2024-06-30 at 10.20.21 PM.png"></img></div><h4 id='temp:C:VbXc91618307043411dbf897ed2d'>CSVizTool:</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/jxYzkQBZAx2AW7JDBxFkBg?a=PM64ioCUka7QkhTr1Tby9HECxnbLOECXqgCbdGo8EjQa' id='temp:C:VbX308e2168cc314a5699c07d312' alt="Screen Shot 2024-06-30 at 10.23.40 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/fcD4o0cqyzk2rY1vxf2RRA?a=33z3ULPtyaPFkYKQzJadLjQLarEvhsFr17MW9zQl99ga' id='temp:C:VbX444f16e4a2c04611b9526ef41' alt="Screen Shot 2024-06-30 at 10.24.05 PM.png"></img></div><h4 id='temp:C:VbXe63abecfd1d14a23b62b02402'>Saikrishna Slides</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qvOAJF5Id6iUYkV_isvN7g?a=UbDKbIEQhJVafIDkLFecSh4ecVUUl5ntZJdJJJ0tjZMa' id='temp:C:VbXa5ed08b747064433a7ef68ede' width='800' height='340' alt="Screen Shot 2024-07-03 at 10.18.23 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5mvnT6SaRJbDj7VVV5bagw?a=9jk3c7pmXkrFUk7WNwQzjGsfWhoB0yv5R5jvNa2igxsa' id='temp:C:VbXdb8ef85167044e4787716e056' width='800' height='369' alt="Screen Shot 2024-07-03 at 10.18.41 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/n861sFsUMTFXaw6DwUKvLQ?a=GFl4INZX5aMoP95OOv9AFWd914bWi391dMnCAsbM4KUa' id='temp:C:VbX422837d49a394fd59733abfca' width='800' height='356' alt="Screen Shot 2024-07-03 at 10.19.06 PM.png"></img></div><h3 id='temp:C:VbXa5a2adffdea3492b8cbd16859'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/M2sWjvrmjva8oVej4dASBA?a=CIaawxa91GSvGwAoFpMnsYoU2fEUJeNYWYKPFmrQYgYa' id='temp:C:VbX9f14d000eca9456f8e7aaff75' width='800' height='289' alt="Screen Shot 2024-06-30 at 10.22.14 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX05e22234172343a6946cf2e6e'><li id='temp:C:VbX0375791896a041a0bf16c7076' class='' value='1'>Non-adaptive: No way to detect if array is already sorted

<br/></li><li id='temp:C:VbX8cad5958e9e142e38131f6795' class=''>Out-of-place: Data is being copied over to new array.  Not good if low memory or accessing memory is slow.

<br/></li></ul></div><h3 id='temp:C:VbX87ecee2b727041ddb4c662af6'>Example</h3>

Left side:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/9d3sExzdd0AGzXkAPzY9Pw?a=psyeAOCabaw25OPjD8zbW9vaTejQntboOQgZWAKMwZUa' id='temp:C:VbX3c46e7f80e7c4ae68881f9929' width='800' height='306' alt="Screen Shot 2024-06-30 at 10.26.03 PM.png"></img></div>Right side:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nS7iO6GG4znMRSGJz6pAZw?a=RLMqamva2PLYdiKm42kVURB6a48qHKqBvy7Sf5Taf9Aa' id='temp:C:VbX40b0f743965e4f289f104e80e' width='800' height='251' alt="Screen Shot 2024-06-30 at 10.29.13 PM.png"></img></div>Merging example using i and j<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oU6lCcoHmjgXQ-VWjXl0lA?a=sisqpxpz0DFwzq75EafR688K39emQI0DARmlv7dwFM0a' id='temp:C:VbXa2631a6970d0465d865e3de77' width='800' height='312' alt="Screen Shot 2024-06-30 at 10.31.03 PM.png"></img></div>another example one level above<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/6n2RvVq47GeYTf771p4JEA?a=iGQ8Rid1ozlQvi4UtxTKaJNZyjUHUnk5umh3LIcY3M8a' id='temp:C:VbX9b022f6afc114f12b3abffb43' width='800' height='237' alt="Screen Shot 2024-06-30 at 10.31.42 PM.png"></img></div><b>Example from CSViztool (2,3,4,5,1)</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe33a579764d04e36a60518b17'><li id='temp:C:VbXadaa74a6ef3f4e2991b8b8e58' class='' value='1'>See how it handles sub-array that are out of order (2,3 &amp; 1,4,5).  It essentially moves i, j pointers and does comparison.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qV3_RT7RWVP93mHJv-OuUQ?a=fCHgzJTgpqOQZKeaxuKkGsLg9keNU9L8sUJN0eXkKpka' id='temp:C:VbX0d0183f7f9c04e6e95ab81af5' width='800' height='425' alt="Screen Shot 2024-06-30 at 10.38.09 PM.png"></img></div><h2 id='temp:C:VbX84ad16228c4f4727ad1193967'><b>The Efficiency of Merge Sort</b></h2>

An O(𝑛log⁡(n)) time complexity is a bit difficult to visualize, so let's take a closer look at where this time complexity comes from.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dcoJut2vzNYTCVFwdphseA?a=WkPQQCIFtMAsLqSSByFNs36EyvUzK70lcDKjqEVgda0a' id='temp:C:VbX754344eef99a4de796916d375' width='800' height='424' alt="image.png"></img></div>Merge sort has two phases per recursive call, the <b>splitting</b> and <b>merging</b> phases. Splitting occurs before we make the recursive calls, while merging occurs after recursive calls end, which is the "unraveling" of the structure. When analyzing the time complexity, we are interested in the entire tree. Each "node" in the tree contributes a cost to the time complexity, and our job is to do the bookkeeping of summing it all up.<br/>

<br/>

In the splitting phase, suppose we're working with a subarray of length 𝑚. Then, we take 𝑚/2 time to copy the left half of the subarray into a new array, and we take another 𝑚/2 time to copy the right half. In total, this is m time for a length 𝑚 subarray. However, if we sum the total lengths of subarrays on each level, this total is 𝑛. So, <b>each level of this tree contributes 𝑂(𝑛) time to the total cost</b>. There are <b>𝑂(log⁡(𝑛)) levels to the splitting side of the tree</b>, so this becomes <span style="color:#218118" textcolor="#218118">𝑂(𝑛 log⁡(𝑛))</span> for our total time complexity. <br/>

<br/>

In the merging phase, it's very similar in analysis. For a length 𝑚 subarray, it takes 𝑚/2+𝑚/2=𝑚 time to merge the left and right halves together since they're already sorted. Once again, there are 𝑛 data on each level, and there are 𝑂(log⁡(𝑛)) levels, giving a time complexity of 𝑂(𝑛 log⁡(𝑛)). <b>Summing these two phases together just increases the constant factor</b>, giving an overall <span style="color:#218118" textcolor="#218118">𝑂(𝑛 log⁡(𝑛)).</span><br/>

<br/>

What about the space complexity? We can actually get away with having one extra length 𝑛 array as a buffer to copy elements into/out of. This gives us a <span style="color:#218118" textcolor="#218118">space complexity of 𝑂(𝑛)</span>. In fact, even if we had allocated two new length 𝑚/2 arrays at the splitting step of a length 𝑚 array, we'd still only have 𝑂(𝑛) space complexity. There is a bit of nuance to this, so we will defer this discussion to the quick sort lesson, where it will be more meaningful.<br/>

<br/>

<h2 id='temp:C:VbX8b5175c7e7784e6aba94512c5'>In-Place Quicksort</h2>

Note: Version taught in course: <b>randomized inplace quick sort</b> using the <b>hoare partition scheme</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXf5b6071cddca42e09ed2da57a'><li id='temp:C:VbXfe14b9c20b924b8ab73ee1817' class='' value='1'>Rather than explicitly splitting into halves and merging afterwards, quick sort picks a <b>pivot</b> element 𝑝. Then, it partitions the array so that all data 𝑑&lt;𝑝 is to the left of the pivot, and all data 𝑑&gt;𝑝 is to the right of the pivot.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/u-eAtKFMgSUHvZ518U8uBg?a=iJRoanwtDk93Lq7aZr9SaxduFshH4fzTmAYj1kWacU8a' id='temp:C:VbX233468a770b846b18b1ece7c5' width='800' height='314' alt="Screen Shot 2024-07-01 at 9.41.57 PM.png"></img></div><h3 id='temp:C:VbXb2a55fb4a31c4e59b2565d232'>Algorithm</h3>

<b>Part 1: Pivot Selection</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LwCd1ZpNyJRlEuHiV4nb9g?a=fPBkHLiQDKzHAvhhJ2GixachgUbWR4aQrIqDRD7B2eoa' id='temp:C:VbX98e085c85c9f43b8b495755cd' width='800' height='291' alt="Screen Shot 2024-07-01 at 9.42.28 PM.png"></img></div>Base case: length is 1 or less<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX12586fbc91364b6eb0a7adea5'><li id='temp:C:VbX6cb197a2c0f14f0cb188eb077' class='' value='1'>End index can be inclusive/exclusive (course teaches inclusive)

<br/></li><li id='temp:C:VbX58f9a7ea8d214be4bce229be8' class='parent'>Pivot - element to sort the array by

<br/></li><ul><li id='temp:C:VbX1f9183c289eb44919e4b025bf' class=''>Selected by random index between start &amp; end.

<br/></li><li id='temp:C:VbX8977575d1701440d951fba47c' class=''>Auto swapped with element at front of array.

<br/></li></ul></ul></div><b>Part 2: Partitioning</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sZo7P9G0pax5L9ergiBD6g?a=HXuM0helIUkAmI1HOp7HaQv01HrO3tboC4PV4N06B5Qa' id='temp:C:VbXf06197e504374363b1589c1a9' width='800' height='365' alt="Screen Shot 2024-07-01 at 9.44.21 PM.png"></img></div>Takeaway: Move items greater than pivot to right of array, smaller items go left.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX91d0caa4a3ac4be7b9be6dcca'><li id='temp:C:VbXdcd3f6a97fd74e958f3a94c4c' class='' value='1'>“crossed” i moves <i>strictly</i> past j

<br/></li></ul></div><b>Part 3: Placement of pivot and recursive calls</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/zwexwNs701FJD0wfiklYcw?a=mHbCw1GAecEVUyWrmqKpHjP0fpaRWgwuIvjPIugTykca' id='temp:C:VbX3f61050403c148db9a66fac8c' width='800' height='222' alt="Screen Shot 2024-07-01 at 9.46.40 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXb897ebe566234a149ea3a79c8'><li id='temp:C:VbXdecd88cecfaf4d0b8f966c2a0' class='' value='1'>Recursion excludes the pivot

<br/></li></ul></div><h4 id='temp:C:VbX72b8e62c041947aab3f4a2296'>CSViztool</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/32_nQR142QKRNEFhsOvS2A?a=dN9FDjoREWPOe858Z1aXYU5gYvVl3bvAKS5hV52yt38a' id='temp:C:VbXee8142a935414aefb6762d46e' alt="Screen Shot 2024-07-01 at 9.49.59 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5L5pqswiqFqtMPfHey2c6g?a=WjL0G4ftxY0mx7BJGY3t3TaQSeeSQLaIBq6o1auTS2wa' id='temp:C:VbX1aa2d274ecaf4390962acb137' alt="Screen Shot 2024-07-01 at 9.50.20 PM.png"></img></div><h4 id='temp:C:VbX3f9b1be5796a4704866d0d7b0'>Saikrishna Slides</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/1OlTK_5KoiFgPuI8ycQlOw?a=zUczMTCiDAzUtOmznXWdBB2bjrjJ7ucsgfz34VoaoPca' id='temp:C:VbXfb7406e051614fda957ce5f82' width='800' height='328' alt="Screen Shot 2024-07-03 at 10.21.10 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BoJ8xQjnyt9754O-f0VQlQ?a=ieffa7Ff7S4lxz9JIRtvSoujQ58Pqx2SVGtfOQAlGaYa' id='temp:C:VbXc5c279f72556411aafb9a4a5b' width='800' height='323' alt="Screen Shot 2024-07-03 at 10.21.17 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LNoCVp0l5INunOOoEzZ49g?a=Sm98k0GLsavsfTdScarWiPfIQt9KSansDvT4YwlqZZUa' id='temp:C:VbX8f3c31fbebf6409985b58bf38' width='800' height='352' alt="Screen Shot 2024-07-03 at 10.21.28 PM.png"></img></div><h3 id='temp:C:VbX624edd75fa0d44d5b8ca5301f'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/RyteBTqqbkEiB49h1ypWbw?a=vitSU5XFTKHZUyBtKb22gpW6H3H8HAVwKHwfbrv4Uaka' id='temp:C:VbX230b115d9089439db5ac8c00c' width='800' height='272' alt="Screen Shot 2024-07-01 at 9.49.06 PM.png"></img></div>Best case: Array cut in half<br/>

Worse case: Pivot always min/max value of subarray.  Degenerates into selection sort.  Fixed by randomizing pivot selection.<br/>

<h3 id='temp:C:VbX9a143fc9444346d4be2005918'>Example</h3>

(Complicated, refer to <a href="https://csvistool.com/Quicksort">CSViztool QuickSort</a> to understand)<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX417d8198137f4a51ab528c2fc'><li id='temp:C:VbXa7fcd4ae533b47f1abe12a44e' class='' value='1'>How many comparisons are made on the input array [1,2,3,4,5,6]?  <span style="color:#218118" textcolor="#218118">10</span>

<br/></li><li id='temp:C:VbXb5b96521624b47ffb68743ade' class=''>How many comparisons are made on the input array [6,5,4,3,2,1]?   <span style="color:#218118" textcolor="#218118">11</span>

<br/></li><li id='temp:C:VbXb02aa1e127dc448cae8003c3a' class=''>How many comparisons are made on the input array [4,3,6,5,2,1]?   <span style="color:#218118" textcolor="#218118">12</span>

<br/></li></ul></div><br/>

<h2 id='temp:C:VbXa25eb111198248f6a988298d5'><b>The Space Complexity of Algorithms</b></h2>

Space complexity is a bit more nuanced when we discuss algorithms rather than data structures. Generally, when people talk about the space complexity of an algorithm, they are talking about what is called the <b>auxiliary space complexity</b>. This is the space complexity of an algorithm if <b>we don't count the space needed for the input and also don't count the space needed for the output</b>. So, in other words, we're looking at the working memory for the algorithm to work beyond the necessary input/output.<br/>

<br/>

This may seem strange at first, but there's a very good reason for this distinction, one we can see looking at the various sorting algorithms. If we included the input and output, then all of these sorting algorithms would have space complexity 𝑂(𝑛), which is quite a heavy price. This measure doesn't distinguish between sorts like bubble sort which have minimal memory footprint and merge sort, which uses a lot of memory due to the extra space needed for array copies. There would also be no way to talk about algorithms that use sublinear space if we didn't make this distinction.<br/>

<br/>

Another nuance that might seem strange is that the space complexity is <b>the maximum amount of space used at any given time during execution of the algorithm</b>. The other option would be to consider all space used throughout an algorithm. We define space complexity this way because from the computer's perspective, if memory is not being used by the algorithm, then that memory is "freed" for the rest of the system to use. This means that the space complexity of merge sort is indeed 𝑂(𝑛) rather than 𝑂(𝑛log⁡(𝑛)) since the maximum memory used at any given time is<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YMuKyAF2dzb-d0_SOYJAoQ?a=QmbH356GfdTz0FWqcArWXg08m2y76fx5VXsI4qKG3VAa' id='temp:C:VbXf1e42ecd54ba45e2ab4fbaddb' alt="Screen Shot 2024-07-01 at 10.09.29 PM.png"></img></div><br/>

Finally, there is one other nuance that has to do with lower level details. <b>Recursion and method calls in general are not a free resource in terms of space</b>. The program needs some way of remembering where execution stopped when a new method call was invoked, so it stores whatever state information is necessary to remember this on the call stack. So, the recursion depth of an algorithm contributes to the space complexity as well. In the case of merge sort, the max recursion depth is 𝑂(log⁡(𝑛)), which is much smaller than 𝑂(𝑛), so we didn't need to worry about it.<br/>

<br/>

However, quick sort is inplace, so this recursive cost is non-trivial. On average, quick sort's recursive depth will be 𝑂(log⁡(𝑛)), and in the pathological worst case, it will be <br>𝑂(𝑛). So, the space complexity of quick sort is on average logarithmic, and in the worst case linear.<br/>

<br/>

<h2 id='temp:C:VbX62e9a8e3544a4150b219bfa7d'>(New) HeapSort</h2>

<b>Key Idea:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX37b797c832974dcda2159180c'><li id='temp:C:VbXf4badf632610499daac16a24b' class='' value='1'>Build a min heap (either by adding naively one by one or by using the BuildHeap algorithm).

<br/></li><li id='temp:C:VbX2ae4b28f42854be79fdf7f232' class=''>Remove (dequeue) from the heap until the heap is empty, which gives us the smallest item remaining in the heap after each call to remove.

<br/></li><li id='temp:C:VbXc313ae2bbd2e45ee8582af2d4' class=''>Building heap: O(n) using BuildHeap

<br/></li><li id='temp:C:VbX0c11a71cad8e422792b9edf73' class=''>Time complexity: O(n log (n)) for all cases.

<br/></li><li id='temp:C:VbX6d3f8dce7eae4337a5d661884' class=''>Adaptive: No

<br/></li><li id='temp:C:VbX5854f7e709544fb988205abd0' class=''>Stable: No (can’t guarantee relative ordering)

<br/></li><li id='temp:C:VbX53e2b18f606449b7bcd8d1677' class=''><b>Significance: A lot of sort algorithms are O(n log(n))</b>

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mLPlOvk87FwDX_YzWVCqGQ?a=6iwaBFJH1r8SydYc8aHlo7FxrzNuBi9FnariMFSMbfka' id='temp:C:VbXa6a5e67d0f9d4ef2837095ed5' width='800' height='298' alt="Screen Shot 2024-06-30 at 10.09.25 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GY44lJFnoYiRnwocIg89WQ?a=5Q1j7BswdGzaqTllZaQB2daCyni9o4BbtNVkCD87jEga' id='temp:C:VbX90615ff6cd914ca7b381fc61d' alt="Screen Shot 2024-06-30 at 10.09.41 PM.png"></img></div>Class implementation uses PriorityQueue (MinHeap) to sort the data.<br/>

<br/>

<h3 id='temp:C:VbX08dce8730e304fe8bb4f5fd55'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ozfLUh9WfsvmdlRfV7udgA?a=0H75oFJGFay0nTdv6vNYgaymoKFPK8U7juS8OvrkCuAa' id='temp:C:VbXba7060f7dc7a4692981b1fbad' width='800' height='327' alt="Screen Shot 2024-06-30 at 10.10.48 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/IC106pefoAeeoEVUZcfQAQ?a=iXskNtdLboYY2IbC9OEnPSG2xwDY1JBKHOwcDajUcsQa' id='temp:C:VbXeec84f544a2f42a99d1d0c68a' width='800' height='263' alt="Screen Shot 2024-06-30 at 10.10.59 PM.png"></img></div><h3 id='temp:C:VbX81f4b05edba44301b0304b5fd'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Ahy5a7G4eaBehcRDFWn2AA?a=tHkGpWCoYcJtWhey5OtJOTKRSbk1q45gvHae6CEfEwca' id='temp:C:VbXb5c8e32397b048c399501f103' width='800' height='354' alt="Screen Shot 2024-06-30 at 10.11.59 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Kp9NGXJVSSUkI6-AqvJrDA?a=DtqRJUENJrOSjxhd72f5L5O8V3hW4ggA9Zy6LalMENca' id='temp:C:VbXbd8b9f0633dd4eed97a5930cf' width='800' height='308' alt="Screen Shot 2024-06-30 at 10.12.06 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/quHLIm4UHvQZa9hJlpn6BQ?a=hycAbIfH4PwCXB7xanQiOYo0ONA20EOwxsZHRaqaniEa' id='temp:C:VbXa5c37e38b552497284b915eb2' width='800' height='310' alt="Screen Shot 2024-06-30 at 10.12.18 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Ha7bR59W4vtkIW4vLPfWKA?a=xabeDd9kmySHVzaoVEgtcw9xeVrQZWh3xRkUxmNlVBoa' id='temp:C:VbXf7bbbd3f3f204b0d8ad05a773' width='800' height='313' alt="Screen Shot 2024-06-30 at 10.12.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QdcgHn5yrvCKb8oOcrHOJg?a=yLnmYaDbvGMQtO9FvOaKaY2uxfH5x3uOTQPJQ6UOeyca' id='temp:C:VbX1a7c7e8939c1450aa95e00b06' width='800' height='314' alt="Screen Shot 2024-06-30 at 10.12.43 PM.png"></img></div><h2 id='temp:C:VbX936cb2dad8f34c2985598767a'>Limits of Comparison-Based Sorting</h2>

<b>Key Idea:</b><br/>

<blockquote id='temp:C:VbX3c5754d45fc047e4a9aca17bd'><i><span style="color:#218118" textcolor="#218118"><b>"For any deterministic, comparison-based sorting algorithm A that is always correct, there exists some input x such that A(x) takes <control data-remapped="true" id="temp:C:VbX5715c1a5ba19460095971ab57">Ω(nlog(n))</control> comparisons to execute, and therefore its worst case time complexity is <control data-remapped="true" id="temp:C:VbXb9d04a18e23347b68bb110b81">Ω(nlog(n))</control>."</b></span></i></blockquote>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd84cfe88ad1a42239f494ce97'><li id='temp:C:VbXa0781b72d174414ca7ee9e63e' class='' value='1'>Statement applies to any deterministic, comparison-based sort, and always successfully sorts the array.

<br/></li><li id='temp:C:VbXe59b8d3393f94ac79b56d5cb5' class=''>Not about the algorithm, but the fact that there is always going to be some input that will result in<b><i> <control data-remapped="true" id="temp:C:VbX41cd25cd47794e088444f4b5d">Ω(nlog(n))</control></i></b>

<br/></li><li id='temp:C:VbXce3cbdde6aa14044a98b0d520' class=''>This is called a <b>lower bound </b>statement about a class of algos.

<br/></li></ul></div><b>High-Level Idea Summary</b>:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX27daf8c9c02a4228a15135451'><li id='temp:C:VbX6d927d27541b4afe9c0ecb791' class='' value='1'>Each comparison provides limited information about the input's configuration.

<br/></li><li id='temp:C:VbX62c88d9209c24289a953e54ed' class=''>The algorithm must distinguish between all possible configurations to sort correctly.

<br/></li><li id='temp:C:VbXfb46b441ed9f4de88c671f731' class=''>There are (n!) possible configurations for (n) distinct objects, due to (n) choices for the first position, (n-1) for the second, and so on.  This results in a significant number of configurations.

<br/></li><li id='temp:C:VbX94d2ec0923604568aafb8a2c4' class=''>Each comparison contributes a small amount of information.

<br/></li><li id='temp:C:VbXce94c00e2b4f418a862b1b506' class=''>It requires at least <b><i><control data-remapped="true" id="temp:C:VbXdb2c6015783a442d992cbf157">Ω(nlog(n))</control></i></b> comparisons to identify the input configuration and sort correctly.

<br/></li></ul></div><b>Final takeaway</b>: We can prove a stronger statement.  Highlighted part is important.<br/>

<blockquote id='temp:C:VbX97f944918ecb4bec84966f393'><i><span style="color:#2cab21" textcolor="#2cab21"><b>"For any (potentially <u>randomized</u>) comparison-based sorting algorithm that is always correct, the number of comparisons it must make <u>on average</u> is at least <control data-remapped="true" id="temp:C:VbXa4534cb866f8464bafef1439f">Ω(nlog(n))</control>, meaning the average case is <control data-remapped="true" id="temp:C:VbXa6434065bab44e89b0837e0f1">Ω(nlog(n))</control>."</b></span></i></blockquote>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe75474fa27e341abb9e254558'><li id='temp:C:VbX47a7d88636f94876b9a003bab' class='' value='1'>“Randomized” - allows inclusion of quicksort

<br/></li><li id='temp:C:VbX42d0fe6e9b324fe4b89cb2276' class=''>“On average” - not just worst case.

<br/></li></ul></div><h2 id='temp:C:VbXcf283aac82424a81a0af5d13b'>LSD Radix Sort</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/DEg3DdF0HL1zfuOHvADjHg?a=BBgtWAMfAeoOPJ7QjkqzIG5RyL4YWHhEaq2wyIFVCpka' id='temp:C:VbX62c0c69bf4c14dfdb901041e6' width='800' height='247' alt="Screen Shot 2024-07-01 at 10.46.24 PM.png"></img></div><h3 id='temp:C:VbX44268dcff02a493a81bf971bb'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CSao2UCSb6v9QBYTPT1QDA?a=WadLuPTUWqIMUH63dGtzy7t7cFnuY8tCVftIougDKHga' id='temp:C:VbX47e21f56cd7243fba4d5a4376' width='800' height='359' alt="Screen Shot 2024-07-01 at 10.46.36 PM.png"></img></div>(Designed for sorting numbers in base 10)<br/>

<h4 id='temp:C:VbX770acc89eab74e328b7083116'>CSViztool</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/WfoQyYXnY7JxZCy1K_TDMw?a=fdXRXY7rL8GlTpAs4tZB8kfOcZnezrXIdZ9B07qvcmQa' id='temp:C:VbX97e6df3c2060450a91648907b' alt="image.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/y-iZHE3gYa_SEaFOgkH0Dg?a=fawrGOoDYNyhrJveBGTa3bME5LzXPabHEuNryDnEVkwa' id='temp:C:VbX2f723d29744e497e96224eba2' alt="image.png"></img></div><h4 id='temp:C:VbX219f1b62e7a549ebbd7b24964'>Saikrishna Slides</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/cELBYCvJmW45Ba7DBQIv7w?a=L0kOwE4CJnfBnLLu1rCr7IjH25oa09I1r2mMYzsZ7Osa' id='temp:C:VbX7bbb003206f148e8855082e5c' width='800' height='330' alt="Screen Shot 2024-07-03 at 10.23.07 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/4es7Gnh-ZgnzXdgUEKwQ4w?a=QVVXNWvGB0UHSKj7ahUVAf8J1S17rOp9YaafzP1MmXQa' id='temp:C:VbX81fe8f96d37a41c593230c2b4' width='800' height='282' alt="Screen Shot 2024-07-03 at 10.23.16 PM.png"></img></div><br/>

Notes:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXcdc58266aab74c2e85eca15f0'><li id='temp:C:VbX98682e556b3444a587ef8865a' class='' value='1'>Buckets: If sorting only positive integers, there’d only be 10 buckets.  If including negative, it is 19 [-9 to 9]

<br/></li><li id='temp:C:VbX354633fda1a0442f97551c31a' class=''><code>for iteration &lt;- 0, k</code> : <i>k</i> = count of digits in longest number (largest magnitude)

<br/></li><li id='temp:C:VbXabd298a64ab44f6c9af99f601' class='parent'>1st loop: Iterate through data in array and adds each to their respective buckets based on <i>current digit</i>.

<br/></li><ul><li id='temp:C:VbX3df8b3854af846eca4c63de8d' class=''>Calculating digit (base 10): 1st digit is the <i>least</i> significant digit (one’s place).  Buckets sorted by ones place, then ten’s place and so on...

<br/></li><li id='temp:C:VbX284c778ed7604fdfa3ea4b9df' class='parent'>How to calculate digit? Use combo of division and mod operators.

<br/></li><ul><li id='temp:C:VbX1ecfa7bc707a438d9c67985da' class=''>Modding n by 10 = result always the digit in the one’s place

<br/></li><li id='temp:C:VbX5b78fc58e10f4bc781c24472e' class=''>Dividing n by 10 = the one’s place is removed

<br/></li><li id='temp:C:VbX71847c68b86441f88a02b759b' class=''>Dividing n by 100 = both one’s and ten’s places are removed

<br/></li><li id='temp:C:VbXf24efc3f189142d587a0f71c3' class=''><span style="color:#218118" textcolor="#218118">Tip: Creating a power of ten variable outside of loop and incrementing as necessary may be helpful.</span>

<br/></li></ul><li id='temp:C:VbX5df55688b83649c3b04affad6' class='parent'>Once digit is obtained, place data value into the correct bucket.

<br/></li><ul><li id='temp:C:VbXa0e58f2936bc4d498eada0df8' class=''><span style="color:#218118" textcolor="#218118">Tip: Think about why it would be necessary to add nine when determining the bucket...</span>

<br/></li></ul></ul><li id='temp:C:VbX756ea33e8f2a4679882523d88' class='parent'>2nd loop: After placing all value into proper bucket, loop through each LinkedList and add them to the out of place array.

<br/></li><ul><li id='temp:C:VbX5830e3ea438445b29854a35ae' class=''>Inner while loop allows skipping empty buckets.

<br/></li><li id='temp:C:VbX74829ec54b89458c84c227736' class=''><span style="color:#218118" textcolor="#218118">Tip: Make sure to add in the order they were placed into the bucket.</span>

<br/></li></ul></ul></div><span style="color:#218118" textcolor="#218118">Tip: “One common mistake students make with radix sort is the termination condition when implementing base 10 LSD radix sort. Students notice that in many cases, if all items falls into the 0 bucket, then the result is sorted. However, this is not always the case!”</span><br/>

<h3 id='temp:C:VbX1b0e808c79234fac945caa02b'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QH-Ht8DuP-YMvuuRwZdBiQ?a=JAO3S8UsxjvecqQC0aaNP0EhqIWahJ5rafa1YTXC1sEa' id='temp:C:VbXacf71d25409644adbc766bbeb' width='800' height='352' alt="Screen Shot 2024-07-01 at 10.50.10 PM.png"></img></div><b>Take aways:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa3e2e7dbe7944d278f1ac0cf5'><li id='temp:C:VbXe4ab5422e3ad4ea2af2044b38' class='' value='1'>Works best on large arrays of integers where <i>k</i> (count of digits in longest number) is small compared to <i>n </i>(number of integers)

<br/></li><li id='temp:C:VbXdcf52953821241fcb5474c9f9' class=''>Doesn’t work well on small arrays where <i>k </i>is large and <i>n </i>is small.

<br/></li></ul></div><h3 id='temp:C:VbX19b28b5f4ab140ada69d11a22'>Example</h3>

(Note: Example only uses positive integers, so bucket width of 9 is used (use 19 for negative)<br/>

<h4 id='temp:C:VbXca0413a9bb824d35b029db431'>Iteration 1</h4>

Step 1) Put each index item in buckets (LinkedList) according to 1st digit.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/v_pFLdSZXZdlu5FhyLm5JQ?a=hLjSNRsGcdZvU1a5XuwPKJTicq5gmiyqd3c2QpwOlZ8a' id='temp:C:VbXa083d2fdc0264e40b11dc57c5' width='800' height='292' alt="Screen Shot 2024-07-03 at 9.14.15 PM.png"></img></div>Step 2) From 0, overwrite items in original array with items from buckets.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX05c40deae2624669bba66f6f9'><li id='temp:C:VbXa405038513714a6b9b610939b' class='' value='1'>For buckets with more than one item, it acts like a queue and adds to next index in original array.

<br/></li><li id='temp:C:VbX97f03f59fb004927b2eb3b5a1' class=''>Empty buckets are skipped over.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/x8kK05US2NN75dH8XYzMEw?a=b8M4dYmuaQwMK4aJlJQhMPl3CM6NDTOdkvUU7pOYdnsa' id='temp:C:VbXb02982fbf4f7447e90116ec8f' width='800' height='195' alt="Screen Shot 2024-07-03 at 9.17.56 PM.png"></img></div><h4 id='temp:C:VbX9198dd37b32744fa830e366d2'>Iteration 2</h4>

Step 3) Put each index item in buckets according to 2nd digit. <br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa9e80adb1a4a45c0b2656c515'><li id='temp:C:VbX1ffa6e28559f427a9cf2f4520' class='' value='1'>Now each bucket is ordered by up to the 2nd digit

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/3-_xxZfnn2lXfhFxZMV2zg?a=3PAI3PxLYR7Pbjn3PjB0qCHDTQ2KSeMjnnuOQPUabeca' id='temp:C:VbXcce582eaf06d41759ea255b55' width='800' height='282' alt="Screen Shot 2024-07-03 at 9.19.26 PM.png"></img></div>Step 4) From 0, overwrite items in original array with items from buckets.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/fnqaD2EJikKb4_ARbgnkRw?a=aRAriYi5jaKoDIgmWVuznKmk3Fg3fmMzJt7ciYhENZ0a' id='temp:C:VbX6a4fd5f4d2dc4b088070f5990' width='800' height='205' alt="Screen Shot 2024-07-03 at 9.20.40 PM.png"></img></div><h4 id='temp:C:VbX063c563413324658b9a261e09'>Iteration 3</h4>

Step 5) Put each index item in bucket according to 3rd digit.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/IZubh9ImhBL2H4etSy4pWw?a=jXeICISax5R5urlRqvQMnMimWWLWnzuyyfSy6fgkEEUa' id='temp:C:VbXc76f3413a5974a90a6ff35926' width='800' height='289' alt="Screen Shot 2024-07-03 at 9.21.16 PM.png"></img></div>Step 6) Empty buckets.  Array is now sorted.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/D8794nFNr6QblzR5WEZ9Kw?a=IWNtiuLZfXSTEJfy82jjjpV3BOwTISAiVD4FrCOrt6Ia' id='temp:C:VbXb6447d9e7bfc4ad2bfd47339b' width='800' height='203' alt="Screen Shot 2024-07-03 at 9.22.19 PM.png"></img></div><h3 id='temp:C:VbX9b548e8aaa174312986f191a6'>Food for Thought - MSD Radix Sort</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb2e214941d6144dc8949274ed'><li id='temp:C:VbX6497a9d05e3842fdac6abc3b7' class='' value='1'>MSD = Most significant digit sort; Starts from left side of integers.

<br/></li><li id='temp:C:VbX4cba20f5d61047afa2c7ea001' class='parent'>Applied recursively - For each iteration <i>i</i>:

<br/></li><ul><li id='temp:C:VbXb94f436e41ac4ce0b75e94954' class=''>From left to right in our array, move the integers into our buckets based on the digit value of what's in the 𝑖th position from the left.

<br/></li><li id='temp:C:VbX59df439d18844298921460e72' class=''>For each bucket, recursively call MSD radix sort on that bucket for iteration 𝑖+1.

<br/></li><li id='temp:C:VbX17bdd322b3914b13b089f88ce' class=''>Take the sorted data in each bucket and dequeue all items like in LSD radix sort from left to right into our array.

<br/></li></ul><li id='temp:C:VbX8e2cd6ef48e544ebba7e3ce6a' class=''>Higher footprint than LSD because buckets need to be created for each stage of recursion.

<br/></li><li id='temp:C:VbXffc95b38ee6e470588589eb82' class='parent'>Properties:

<br/></li><ul><li id='temp:C:VbX34f3837758f046ad8ec179a31' class=''>MSD is somewhat adaptive - It can stop sorting early if the numbers are of varying lengths.

<br/></li><li id='temp:C:VbX2340ac4124b94d57a4142b334' class=''>MSD radix sort can give you an "almost sorted" array by doing a few iterations. Helpful if we only need a rough sort based on order of magnitude.

<br/></li><li id='temp:C:VbXa31d41b5734543bf8fa122e15' class=''>This version of MSD radix sort is stable, though there are other variants that use less memory at the cost of stability.

<br/></li></ul></ul></div><h2 id='temp:C:VbX7c856976225041ce829abf08d'>Quick Select (Kth selection problem)</h2>

Key idea: Use a derivative of an algorithm that solves one problem in order to solve a different problem.<br/>

<br/>

K-th selection problem:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa7f4abc248d646bcaa8bae92c'><li id='temp:C:VbX5b4d15fa00864aa1b9fc20411' class='' value='1'>Input: An array comparable data of length <i>n</i>

<br/></li><li id='temp:C:VbXeab2b20a79914777b520a903c' class='parent'>Output: k-th smallest data in the array.

<br/></li><ul><li id='temp:C:VbX3f44cb5ef51b449ebbebf44b0' class=''>If duplicates present, they count in the numbering.

<br/></li><li id='temp:C:VbXe8e224fad84249fabd2897c5d' class=''>Input array may or may not be modified.

<br/></li></ul></ul></div><h3 id='temp:C:VbX54a51b37b3ec48fb920f01272'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8-tVAAPp6g61ZGC1LHxPNA?a=BZdgqqWflIZNkLtlaqEtTqfhnahtVa0PHQqQYibfecka' id='temp:C:VbX1cbbb246a6dc40eea6ffcd2ef' width='800' height='372' alt="Screen Shot 2024-07-03 at 9.48.22 PM.png"></img></div>Base case: If recursion goes all the way to base case of QuickSort (k-th smallest element)<br/>

<h3 id='temp:C:VbX6222becd45f048bb91c055a56'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/2ydqTT6ghnqfCJYHXXiR5w?a=5f0RQHUgdHStnMzHbAd6QrmWnO7Dr9JE9x5OOi60KCAa' id='temp:C:VbX79e465a3aa074fee81d0c4454' width='800' height='330' alt="Screen Shot 2024-07-03 at 9.50.25 PM.png"></img></div><h3 id='temp:C:VbX189913020aea41a4815d5fd94'>Example</h3>

Goal: Find 3rd smallest item<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/bMd_Ay_vts-szPhruMgskg?a=dKZ4axmFx6wy9a9Ak8Tsjhf8YlFc3OXv0SngmZoAA38a' id='temp:C:VbX40b7604c8149449986582cec7' width='800' height='118' alt="Screen Shot 2024-07-03 at 9.53.23 PM.png"></img></div>Iteration 1:  First do same process as QuickSort<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/JfQoAqM7PhClI8yEiV8sLw?a=OZ1UF4pabaXeszwNOiiaFOIQr9rSwm054vIGUgrT02wa' id='temp:C:VbXc7720d5d02444209ad1f86042' width='800' height='328' alt="Screen Shot 2024-07-03 at 9.55.54 PM.png"></img></div>Once i and j cross, QuickSelect deviates:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa9f9ebe97c684b8595d55fec6'><li id='temp:C:VbXc92d6962e671403eb87432627' class='' value='1'>Compare j to k-1.  If k-1 &lt; j recurse left.  If k-1 &lt; j recurse right.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nVDfRilUSDF3aZ64_iPuvA?a=u5YsHKWdKqJ4E9QXaAWvlaFaZleLSmwUlaZL7cmb6kYa' id='temp:C:VbX29383212f8164ae2a9c26ba3a' width='800' height='324' alt="Screen Shot 2024-07-03 at 9.58.25 PM.png"></img></div>Once k-1 is found (e.g. 3 - 1 = 2), we terminate.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/lIyWMgBviscE_xd5jgiyLg?a=nhxy9m17dj2CNHuC0slpII9C9GOeB3SaBU8nAiqPN9ka' id='temp:C:VbX8edcdc036cb043e9b31141838' width='800' height='212' alt="Screen Shot 2024-07-03 at 9.58.47 PM.png"></img></div><h3 id='temp:C:VbX088adee47f5344e6861a9e1b0'>Food for Thought - Deterministic Pivot Selection</h3>

Q: Instead of random pivots, why not deterministic.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1b7e56aa1f8b409da1bd06697'><li id='temp:C:VbX1cbeb2a73a7442daa5ac619c7' class='' value='1'>Example: Last item in subarray - if sorted, we will encounter worst case.

<br/></li><li id='temp:C:VbXe7ccbb16663142529d496201e' class=''>Example: “median of 3” - take first, last and middle item of subarray, calculate median.

<br/></li><li id='temp:C:VbX02e09f66ca2e4967821eb3334' class='parent'>Example: “median of medians”:

<br/></li><ul><li id='temp:C:VbX494992d28ce9491c9dec70e96' class=''>Group the <span style="color:#2d3b45" textcolor="#2d3b45">𝑛 </span>elements of the subarray into groups of size 5. There are roughly <span style="color:#2d3b45" textcolor="#2d3b45">𝑛/5 </span>of them.

<br/></li><li id='temp:C:VbX92d02693f3464493b51a17dea' class=''>Find the medians of each of these size 5 groups.

<br/></li><li id='temp:C:VbX7cffec4200194275950214b57' class=''>Compute the median of these <span style="color:#2d3b45" textcolor="#2d3b45">𝑛/5 </span>medians computed from those groupings. This part is done recursively.

<br/></li><li id='temp:C:VbXdc0a2e12ae054486a25797fa5' class=''>Use the computed "median of medians" as the pivot for the next iteration of quick sort / quick select.

<br/></li><li id='temp:C:VbX233eadf47ae342ff9d52bcbdc' class=''>Pros: Worst case is only O(n).  Cons: High overhead

<br/></li></ul></ul></div><br/>

<h1 id='temp:C:VbX264de70eeee54798b52e7b920'>Module 12 - Pattern Matching Algorithms</h1>

<h2 id='temp:C:VbXf707347a9f434bd3a0d633b62'>Problem Statement</h2>

<b>Input:</b> A small string that is called the <b>pattern</b>  and a longer string called the <b>text</b>. The pattern is of length 𝑚, and the text is of length 𝑛. In some special cases, we may also receive the <b>alphabet</b>  with which the characters in the pattern and string are drawn from of size 𝑠.<br/>

<br><b>Output:</b>  There are two primary variations of this problem. For the <b>single occurrence</b>  version, we output the location (text index) of any occurrence of the pattern as a substring of the text. In the <b>all occurrences</b>  version, we output a list of all locations (text indices) for occurrences of the pattern as substrings in the text. These occurrences can overlap, so if the pattern were 𝑎𝑏𝑎, then the text 𝑎𝑏𝑎𝑏𝑎 would have two occurrences to output.<br/>

<h2 id='temp:C:VbX817f3daf29b14c1cac511aa56'>Brute Force Algorithm</h2>

<h3 id='temp:C:VbX0829314300954f569dd92f914'>Pseudocode</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX6a73a3118aac4de3b180e9ef1'><li id='temp:C:VbXc56f48bab24241c684206ff44' class='' value='1'>Align the pattern

<br/></li><li id='temp:C:VbX9ed02d0259ce40f5b569fba90' class=''>Compare characters

<br/></li><li id='temp:C:VbX72082b1961f9468c89d159f10' class=''>If no match, shift

<br/></li><li id='temp:C:VbX925956da65684e3797b08de71' class=''>If match, compare next characters

<br/></li><li id='temp:C:VbX66fea2930f434db1acc1962d1' class=''>If all characters match, pattern is found.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/W1Np0RAolw_bav7bpFUscA?a=Td5b9ezaa4gclaDcUm95vkozi9LWEiNNIFhObz4aU2Ma' id='temp:C:VbX11c412753f2341b49243f8dcd' width='800' height='304' alt="Screen Shot 2024-07-07 at 2.02.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/B1eR3Ogb_qKXhYoRUvYgOg?a=IHuUYv53leXJLDzNmajFa1NwHhoLnChVXDlqpRSa9oEa' id='temp:C:VbX7367969c37b245a3bda02b2d5' width='791' height='477' alt="Screen Shot 2024-07-07 at 6.07.14 PM.png"></img></div><h3 id='temp:C:VbX53459d8aefb9469b9fd96bae0'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/K7KT2gPjic2lQj9qfzzGOQ?a=ekHvuZoa0OBsaLPCSsHciaxBfw3ZamAxKjrcBNuqfsIa' id='temp:C:VbXc923957f0a664cf0aa0d945a9' width='800' height='411' alt="Screen Shot 2024-07-07 at 2.05.30 PM.png"></img></div><h3 id='temp:C:VbXeacf84b1e2934a77b1073f66f'>Time Complexity of Brute Force</h3>

Note: Main cases covered in course:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXb070bdf129e7487784cc6d399'><li id='temp:C:VbXd6592aeed5c2417585a143a02' class='' value='1'>Pattern doesn’t exist in text

<br/></li><li id='temp:C:VbXff3dd4a5c94f4dcca5850e7f6' class=''>Pattern exists in text + we want to find a single occurrence

<br/></li><li id='temp:C:VbXb6834bb01edf4dbb91bc0c1f5' class=''>Pattern exists in text + we want to find all occurrences

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5ottOhpPIunuA2d35AHZ_w?a=pc4LLrxaOTE7TLGavUaNIQO1syXdDy9RPHtOGadAoAIa' id='temp:C:VbXa0ec758b736c45ecaeef4b38c' width='800' height='199' alt="image.png"></img></div>(Course does not focus on average case)<br/>

<h2 id='temp:C:VbX1e61486334124d75bb2f2625e'>Boyer-Moore Preprocessing</h2>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5c34b3c87f754f538e83cab83'><li id='temp:C:VbX9019843843944a81929dab6a7' class='' value='1'>Key idea: Preprocesses the pattern, but not the text

<br/></li><li id='temp:C:VbXcd72cac2e15642e2a15f77a27' class='parent'>Pro: Performs best when there are many characters in the text that do not occur in the pattern.

<br/></li><ul><li id='temp:C:VbX0fffb18181df4d1daf775b11e' class=''>Boyer-Moore uses “<b>bad character rule</b>” - Skips past character not found in pattern.

<br/></li></ul><li id='temp:C:VbX2833d8a021ae4f13953636333' class=''>Course covers the “simplified” BM algo.  Skips over “good suffix rule”.

<br/></li></ul></div><h3 id='temp:C:VbXcc5be941466c4005a8b632346'>Last Occurrence Table</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SD2xVLd4WGUzHcgRvttFNQ?a=gECVe3jAKqa9FbuhumAwAiqeZa7XhrmandmCxhlSa04a' id='temp:C:VbXdfe00797be47492c8382bbf97' width='800' height='166' alt="Screen Shot 2024-07-07 at 2.12.45 PM.png"></img></div>Diagram Example:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GbZU1zoWa1QCK_bO0l3v4Q?a=tjaiXY0Jx6e8EOt9StDBOjenafzUavIqf5asYGl9hcUa' id='temp:C:VbX745765397571421f8a0f384ce' width='800' height='228' alt="Screen Shot 2024-07-07 at 2.16.50 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX398cc5672e2749b081940c1cd'><li id='temp:C:VbX15a45c415d224d59bad2802c6' class='' value='1'>Hash map contains index of index of last occurrence of each character

<br/></li><li id='temp:C:VbXb1fa62ebf1b44e2c9aa3c06c5' class=''>Asterisk represents all characters not in pattern

<br/></li></ul></div><h4 id='temp:C:VbXd6b35b1add9945fda40297199'>Pseudocode</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/zr0T9dnbsg3YQimf13waAg?a=FyH9FqhDvKjy6kuavyCKmaWXcyGuoLW01mgjsUKSWrIa' id='temp:C:VbX63d80a066984487786363d1f2' width='800' height='249' alt="Screen Shot 2024-07-07 at 2.13.32 PM.png"></img></div><h4 id='temp:C:VbX9d3cdd266da34ec7b05ccc56b'>CSVizTool</h4>

<b>Building Last Occurrence Table:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nXDBO5nPKJOXPNkFmUWckg?a=9FVBOVowpyPh7KN3gJL70gSTtKOPLBg1saJl49abVHIa' id='temp:C:VbXe1a801c01254493a8f356ec60' alt="Screen Shot 2024-07-07 at 2.15.21 PM.png"></img></div><br/>

<h2 id='temp:C:VbXa2a120e022334c0bb61bdfbbb'>Bayer-Moore Tracing</h2>

Key Idea:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXb6d0f4beff39490bb9749b80f'><li id='temp:C:VbXdf56c4456bbe4f25bb9a401eb' class='' value='1'>Create last occurrence table to optimize shifts past mismatches.

<br/></li><li id='temp:C:VbX804f50d1258441ad8841b9e23' class=''>Moves right to left in the pattern.

<br/></li><li id='temp:C:VbXb8fb1648f1cb4b439cf94e01d' class=''>If there is a match, continue comparing text and pattern.

<br/></li><li id='temp:C:VbXc4d9f4a6d0fd4f7e931bfd06d' class='parent'>If there is a mismatch:

<br/></li><ul><li id='temp:C:VbX0a8f44d6c44b4292ace4ae3b6' class=''>If character is in the last occurrence table, shift to the right to align the pattern with the text

<br/></li><li id='temp:C:VbX364a9e3c1570439f86dada6db' class=''>If character is NOT in the alphabet, shift pass the mismatched text entirely

<br/></li><li id='temp:C:VbX5479d841ec40404086224e60f' class=''>If aligning the pattern results in a backwards shift, just manually shift forward by 1.

<br/></li></ul></ul></div><h3 id='temp:C:VbXa6ad7e1051f04ea2821012f54'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/4UgypjkFc8TifhNVDeV7VA?a=f8RCoMeNNctQtUYgajorux28AWauNmFG9Sai3YIqOFQa' id='temp:C:VbXba1c3fa3f8a744fca72adbb63' width='800' height='373' alt="Screen Shot 2024-07-07 at 2.22.14 PM.png"></img></div><div class="" data-section-style='6' style=""><ul id='temp:C:VbX6399b4a3d2c44daa958d00c72'><li id='temp:C:VbX6fc00dad3b9e4426b5a69fcb0' class='' value='1'>Instantiate last occurrence table

<br/></li><li id='temp:C:VbXb0ff729d152a405ca768b9e2e' class=''>Align index 0 of pattern with index 0 of text

<br/></li><li id='temp:C:VbXc98fbc2fa6d94c24a70c14f3b' class='parent'>While loop: Start comparisons from index m-1

<br/></li><ul><li id='temp:C:VbXa712ee48d250457fa39d50e1a' class=''>Keep decrementing j.  If j less than 0 a pattern match is found.

<br/></li><li id='temp:C:VbX55033d763aee42c8aca330460' class='parent'>If no match, query last occurrence table with char in text that mismatched.  

<br/></li><ul><li id='temp:C:VbXc195f6f50ff84f5188d334a01' class=''>“shift” indicates index where shift should take place, then set i to shift

<br/></li></ul></ul></ul></div><b>CSViztool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/6Dd0ld8ZmgcAncC7LgYh_Q?a=95FdKos4EQWqKIpyREjsVj8P3lEFzHdvkWolgskHUfka' id='temp:C:VbX9ce956ee666141a6b27d9addc' width='800' height='556' alt="image.png"></img></div><br/>

<b>Pattern shift cases:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/97m9Qmu21ytXVgvxtwnifQ?a=5OrVMgCqGI6IhmlzfPfMH8b8NrTcu3BRSQ1vml85oTga' id='temp:C:VbX41f6eb0c8f7b4b7387c6388a3' width='800' height='256' alt="Screen Shot 2024-07-07 at 3.01.59 PM.png"></img></div><h3 id='temp:C:VbX072a2e2f7cda4c88be8b698e0'>Example 1</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/D3-mwuyqkPbVpE4HegguAw?a=ta1iWsOpBFR9tT4PSfBQM1KAX19jw0PZxxyVJyPtViwa' id='temp:C:VbX708be4539c8e4acfb742df3a9' width='800' height='378' alt="Screen Shot 2024-07-07 at 3.04.01 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX42b473c9bf3946b48e72d8ed4'><li id='temp:C:VbX8af092719272478d813957180' class='' value='1'>Example of case 3 shifting: If text contains character not in pattern, shift the length of the pattern to the right.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/wvZI0gG0J_BTbrewHnLltw?a=aMNsawy3Ofc3FaDKBvdoGWu9XuyZlahTa3xs4MaSLtIa' id='temp:C:VbXf4d628abd3844955937fdf6a7' width='800' height='276' alt="Screen Shot 2024-07-07 at 3.04.53 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX83d13c9a58514cf4b200c8ba0'><li id='temp:C:VbX1dafb7bb3111464bbff85deb8' class='' value='1'>Reaching index 0 means a pattern match is found.

<br/></li></ul></div><h3 id='temp:C:VbXbaac2bdf6ad349cf8b2da0a77'>Example 2</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/SvsR6WOI9YN_egP5I4sg6g?a=M2VClDBltl60awjexii0lnADzCFDIlRIlXHLBHiVVhoa' id='temp:C:VbX9421b4c261a8414eb9b039df8' width='800' height='356' alt="Screen Shot 2024-07-07 at 3.08.16 PM.png"></img></div><h3 id='temp:C:VbX2e0c19ca0e994c02a8f1e0e7f'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QSmnXT0N9fyRENp0aZFy9g?a=bzlKkYJUCbdAubk2pjlq3lpfQdIwBThVKigW5umsJhUa' id='temp:C:VbX73b4fb388e384c7587f37a853' width='800' height='199' alt="image.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX043204a2b271498faaecd423c'><li id='temp:C:VbXc3de61e7b79641c1bd6f09f80' class='' value='1'>Works well with large alphabets.  Increases chance of case 3 shifts.

<br/></li><li id='temp:C:VbX56f40f756fa8413895d33e515' class=''>Best case (all occurrences):  Scenario where we are making lots of case 3 shifts.

<br/></li><li id='temp:C:VbX1dc62300265f4f509a7d30224' class=''>Worst case: Need to shift by one each character in text.

<br/></li></ul></div><h2 id='temp:C:VbXfbfe6ec72d034ce8a84270147'>KMP Preprocessing - Failure Table</h2>

Key idea: Preprocesses pattern AND text<br/>

<h3 id='temp:C:VbXa12192d96fe3455fa7f633c35'>Failure Table</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Mo4CGtknrGJbH-MVU-X7vA?a=mVCxnoSjK5yzmFrpCn8nfi69ZAcAqrZWP0PDvthkLHoa' id='temp:C:VbX915d933188f24fa4ab86c918c' width='800' height='215' alt="Screen Shot 2024-07-07 at 4.26.13 PM.png"></img></div><h3 id='temp:C:VbX0c68c02c5e7a442f8ef361385'>Creating Failure Table by Inspection</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/_KlhY3nfqv8OZKNQL-LNWQ?a=zNWD3x02332afoWDskDPviGf8UTTaaI9QD2Iz21NFCIa' id='temp:C:VbX2541b97825c74166b4b7d34ea' width='800' height='247' alt="Screen Shot 2024-07-07 at 4.32.55 PM.png"></img></div><h3 id='temp:C:VbX42b8fc90dc994ea9aaac0f38d'>Pseudocode - KMP Failure Table</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CDFFqAZQBFrtayVtAJVCiQ?a=DKVCgsAzVa8LgXXX5aQj4TXaePq1owhLvDkQjb8PMCAa' id='temp:C:VbXd42204b2eb3045a095381bf0b' width='800' height='316' alt="Screen Shot 2024-07-07 at 4.33.23 PM.png"></img></div>3 cases in while loop:  Compare pattern at index <i>i</i> to pattern at index <i>j</i><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXf9a80e39add84767b65993805'><li id='temp:C:VbX325a36443cdc4f4982d462149' class='parent' value='1'>Case 1: Character in p[i] equals p[j]

<br/></li><ul><li id='temp:C:VbXc8bd63446efa4f838cf4b5b98' class=''>Set f[j] to i+1 (length of prefix)

<br/></li></ul><li id='temp:C:VbXef22b6cae6eb4cf9818ab26d7' class='parent'>Case 2: Character in p[i] doesn’t equal p[j] and i at 0

<br/></li><ul><li id='temp:C:VbX9581899695aa4583b4ec42f73' class=''>ie. Character don’t match, no prefix built

<br/></li></ul><li id='temp:C:VbX89a67b9283404b20b68656f46' class='parent'>Case 3: p[i] does not equal p[j] but i is not at 0

<br/></li><ul><li id='temp:C:VbXcd70ce66eeb7405b9b1a1a7bd' class=''>i.e. Characters don’t match but already building up a prefix

<br/></li></ul></ul></div><h3 id='temp:C:VbX8c4750af3e0144df8cab869fe'>Example</h3>

Complicated, watch video: <a href="https://gatech.instructure.com/courses/406950/pages/kmp-failure-table-algorithm?module_item_id=4026224">https://gatech.instructure.com/courses/406950/pages/kmp-failure-table-algorithm?module_item_id=4026224</a><br/>

<br/>

<b>CSViztool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/MIcMaVrtP-1C9uD_O7PMNg?a=deQMDLNUnxUY6eykIzHUJxONp7Gmxanc1AGavtNyg8ga' id='temp:C:VbX7144e641b3e240369367696c1' alt="Screen Shot 2024-07-07 at 4.45.36 PM.png"></img></div><br/>

<b>Tip</b>:<br>The example presented in the video, the case where 𝑝[𝑖] !=𝑝[𝑗] and 𝑖 !=0 may not be useful. The pseudocode tells us that in this case, we set 𝑖←𝑓[𝑖−1], but why is that? This is because there can be sub-prefixes that may be a potential match. To see this in action, try to compute the failure table of the pattern 𝑎𝑏𝑎𝑎𝑏𝑎𝑏 by the algorithm. Your final result should be [0,0,1,1,2,3,2], which you can confirm by inspection using the definition of what the failure table entries should represent.<br/>

<h3 id='temp:C:VbX4bc39b419cc3488db860cad2f'>Time Complexity</h3>

<b>Efficiency</b>: <br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXbea9358c7e894cd79cd5229a5'><li id='temp:C:VbX619ddd9bd1014bdabc68ef75c' class='' value='1'><i>j</i> moves forwards <i>m</i> times

<br/></li><li id='temp:C:VbXce98bc9e81504a5dae8afaf43' class=''><i>j</i> stays in place at most <i>m</i> times

<br/></li></ul></div><b>Big-O: </b>Failure table construction is O(m + m) → O(m)<br/>

<br/>

<h2 id='temp:C:VbX41f117f57f43440791609da4f'>KMP Search Algorithm</h2>

<h3 id='temp:C:VbXa87b262edc9f425aa56493950'>Comparing Boyer-Moore and KMP</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/4kRDddpj11C-Waf4xFT_TQ?a=2UaC8WyrySy2qAYarDquh2L1GknAOeB6YEg5DN4JJ7oa' id='temp:C:VbX4c3275e23e6c41b7a34f25e8b' width='800' height='250' alt="Screen Shot 2024-07-07 at 4.47.54 PM.png"></img></div>(Errata: “To clarify, the first bullet point on the right should read <code>pattern index - 1</code>”)<br/>

<br/>

<h3 id='temp:C:VbXa610d946c2314d6ea1669acd1'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CifSI-dZ7x_bBTHO_U4I5A?a=45e9qBM5K2fGbm6FxnsEmkSdDuIQQi82qa9dr1Rz2FUa' id='temp:C:VbX16915ed21cca4fc7bf86283ed' width='800' height='309' alt="Screen Shot 2024-07-07 at 4.48.22 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/iu3ZopdIvY7kf4EsIdntxg?a=SFLnQTOH9N76QCrGrmEH32H17cRl9BQxr4uvwajuJEAa' id='temp:C:VbX760c5f5d35bf4609b76160ba6' width='800' height='442' alt="image.png"></img></div><h4 id='temp:C:VbX9529bfebbdf44cd28b84f1223'>Handling multiple matches</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX56ef97c8de14466fbf467834a'><li id='temp:C:VbX82685f4525f3430781de52216' class='' value='1'>If we want to modify it for all occurrences, then upon finding a match, we set patternIndex←𝑓[𝑚−1]. 

<br/></li><li id='temp:C:VbX856302ac8e5c45b987dffb091' class=''>The reason for setting it to 𝑓[𝑚−1] is that a match for the entire string can be thought of as a mismatch at the imaginary pattern index 𝑚 since we know indices 0,…,𝑚−1 all match. This just extends the final case in the pseudocode with 𝑗=𝑚.

<br/></li></ul></div><br/>

<b>CSVizTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/xIMVy64X-VOSM0bVOsbNmg?a=JjMrxFswsv0XBYJ4povpWjaKZ2o1zMrRrWiNA9wt4nAa' id='temp:C:VbX98f4cfaa614341d8920513747' alt="image.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/w2LrHr3Ng4lvfUDtBsZf8Q?a=6eehEGfdSh9Ggr5tFgcHubTqw6OVia3jWwyLkJemPS0a' id='temp:C:VbX8c945e69d40d4796859eab6d6' width='800' height='519' alt="Screen Shot 2024-07-07 at 4.45.19 PM.png"></img></div><h3 id='temp:C:VbX5e28ef1663fb4f90a011afe5a'>Example</h3>

Complicated - watch video: <a href="https://gatech.instructure.com/courses/406950/pages/kmp-tracing-example?module_item_id=4026230">https://gatech.instructure.com/courses/406950/pages/kmp-tracing-example?module_item_id=4026230</a><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Jgs_DdVyEQgVT6C2ihmPVQ?a=WjafazuJ3ZYsDsatliUUNmqda30s29zwxH8ung65uHga' id='temp:C:VbX7a897e0f68c7410e98dfb6714' width='800' height='376' alt="Screen Shot 2024-07-07 at 4.56.12 PM.png"></img></div><h3 id='temp:C:VbXf3dc154e39e04cfea345bb206'>Time Complexity</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/94lHeZW-jr_rF1bvbxzN9g?a=KTkPiW1HUhSEcrp2rMV6wwxWlEJkKEai7EUMDtW7tuUa' id='temp:C:VbX0d8dbcb64b8f47ac9f94f2028' width='800' height='234' alt="image.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/T52jrBb7vK5vYHed5gkg7Q?a=b17plALwjfL49DrKb02J3WnXNtttCbK9vExD0q4gS1Ya' id='temp:C:VbXea20bcd3d7344902a608434b6' width='800' height='240' alt="Screen Shot 2024-07-07 at 4.57.05 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXda2eef31937f453198312e68c'><li id='temp:C:VbX437b715ba7764d759e26437df' class='' value='1'><span style="color:#2cab21" textcolor="#2cab21">KMP is <b>linear</b> in worst case</span> (unlike Boyer-Moore)

<br/></li></ul></div><h2 id='temp:C:VbX967543c6cd42495f97c7aef27'>Rabin-Karp</h2>

<span style="color:#2cab21" textcolor="#2cab21">Key idea: </span><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX9e11b8e5c3bc4315bb8474c9e'><li id='temp:C:VbX508e9ca75c014d57ba6138da2' class='' value='1'><span style="color:#2cab21" textcolor="#2cab21">improving the brute force algorithm by adding a "screening" step to decide if we should do a brute force comparison or not between the pattern and text window.</span>

<br/></li><li id='temp:C:VbX2258172da40a406783a87faba' class=''><span style="color:#2cab21" textcolor="#2cab21">This is accomplished by comparing hashes of the pattern and the text window. In particular, the algorithm uses a very robust hash function known as the <b>Rabin Fingerprint rolling hash</b>, which can efficiently update the hash along the text as the window moves along.</span>

<br/></li><li id='temp:C:VbXbd1909ed88c647eaa142bffb5' class=''>Used to detect plagiarism

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/YBbuJo5uhPsKcJ92BspDYw?a=EIaBnJvkSi6YSR70frcJstnRnVh893iAOdK4aZD4o9Ya' id='temp:C:VbX5ebb6fd406344e23bd4557ebc' width='800' height='279' alt="Screen Shot 2024-07-07 at 5.39.19 PM.png"></img></div><h3 id='temp:C:VbX11f88555fca94066bf70e506a'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/PHiaq2NR0MekkVQAm-Lciw?a=gZG7vE3Qfwj7517bymmoWhazIYNWQgnkv2u4vhsrdaAa' id='temp:C:VbXd68d17785cd847bfbded0d2a9' width='800' height='216' alt="Screen Shot 2024-07-07 at 5.39.46 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/mkgkNBpbzgT1Tdt8aaUCNg?a=I374wtHh9EWOI73JGOi1TglWDcaJqHHNn8StMMjZOqwa' id='temp:C:VbXd6e6ac8322e6403289394cbac' width='800' height='456' alt="image.png"></img></div><h3 id='temp:C:VbX4fab2e2d9e9645f1898a1bb09'>Rabin-Karp Rolling Hash</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/RelLvE5UkOr36ZBWTZE19g?a=lFFuZiR3hkCEZizv43jnfFbFsaEFSkEG3P0jpFQ0FOAa' id='temp:C:VbX4ccfcc71907d47279b6d455e9' width='800' height='291' alt="Screen Shot 2024-07-07 at 5.42.20 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX4fbcd10fd77e46ddb4bdaab3f'><li id='temp:C:VbX956d60e77adc48bb927da7371' class='' value='1'>h(x) - Typically use ASCII value for hashing

<br/></li><li id='temp:C:VbX8a7fda61026c412c8a0731ed0' class=''>3rd bulletpoint - used to prevent collisions

<br/></li></ul></div><b>Example:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/sxSUPuqfndOVuyW6bvdIUw?a=F0a0Gf4SLFRsBR2KS2lC45SqMaKKqeYledeNV0EAxBca' id='temp:C:VbX949a59c4c4e44e6e9b36ddbc2' width='800' height='285' alt="Screen Shot 2024-07-07 at 5.45.08 PM.png"></img></div><b>Updating the Hash:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/kN1CuFLwoOH3kAJeTLbyiQ?a=HsnSnIAJWwB9BvTold13zS5hD5FlyXR24ywUXGWf66Ya' id='temp:C:VbXde990c7646b34ee68238cf93b' width='800' height='220' alt="Screen Shot 2024-07-07 at 5.46.22 PM.png"></img></div>Example:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0ErOq1Xv6PfaDbPkhCMdaA?a=6NxRJrtXL0CiuXbFLsqajFvJaAt2MR5LQjAs8Kc3IVYa' id='temp:C:VbX3253d7a9efa243b99d8a6ce42' width='800' height='341' alt="Screen Shot 2024-07-07 at 5.46.52 PM.png"></img></div><b>Summary:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BdOFZTlROu2q_AjyhiwWNQ?a=axJ5XJPp3PmaFP1ebUDFYUaXY6g0kCywEFT03jwN1jAa' id='temp:C:VbX888880cafd9c42bf91a1ee322' width='800' height='251' alt="Screen Shot 2024-07-07 at 5.49.31 PM.png"></img></div><h2 id='temp:C:VbX1b7cc058595d4b36baf6cc2b0'>Rabin-Karp Tracing</h2>

Key Idea: Rolling has, if hash matches (e.g. “cab” vs “acb”) do a inner brute force loop.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oUFT1rS57gMnJ4o2e3htPw?a=d9ff1CR7j4BuFIi31Kz9sRTPnB6wIiz5Jhh2OakPyOEa' id='temp:C:VbXee8c9d5a85264c67aa06a5ac0' width='800' height='350' alt="Screen Shot 2024-07-07 at 5.50.34 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/WmHaCitMQbOIvLT8pGPMZw?a=TbTarp1aabi2gce7heQGBb1OQxTCaaB0q5Sa3RWY3Jka' id='temp:C:VbXf5f37522e44c4ea985a6c838c' width='800' height='369' alt="Screen Shot 2024-07-07 at 5.52.47 PM.png"></img></div>(To record all occurrences, just store the indexes where a match occurs while looping)<br/>

<h3 id='temp:C:VbX73bbbadbd5294d43a445e1c5f'>Efficiency</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GBnp4SWMY0HYPmFypy9ywg?a=cUA5yo6EEaVXanHlbvQyBuBvIA7Q0Cw5y5seoku8vkYa' id='temp:C:VbXf383e01e0bf84da7a87163afc' width='800' height='263' alt="Screen Shot 2024-07-07 at 5.54.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Xwm7w0Q4Ps4_vGl9dfLVVg?a=pix7hCmKZBSxZkHw1ciPdvUIGPTpSLMWH8vwHFdwtwsa' id='temp:C:VbX12b2cdf796e3448984721e813' width='800' height='234' alt="image.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX0f5226d2d3824e3190840b310'><li id='temp:C:VbX16b459e292c9469a877364519' class='' value='1'>Assumes that computing the hash for a single character is O(1)

<br/></li><li id='temp:C:VbXb6dbc786601c417ab93d87dee' class=''><i>“We should also note that though the Rabin-Fingerprint rolling hash is a very good hash function, there is still the problem of integer overflow, so there can still be collisions. They would be extremely unlikely, but that is why the worst case is as stated. In most contexts though, the average case would instead be linear. In fact, the original paper was in reference to the uniform average case, which they did show was indeed linear.”</i>

<br/></li></ul></div><h2 id='temp:C:VbXbeac26660eff43948718d0bbf'>Pattern Matching Summary</h2>

<h3 id='temp:C:VbX096284913a344ecf9a21ac127'>Boyer-Moore</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc6748ddeaca34f38b6b7ad691'><li id='temp:C:VbX740d8f8f42b74168be07b3596' class='' value='1'>Industry standard

<br/></li><li id='temp:C:VbX6d04fd17a59e4e299717ce63c' class='parent'>Efficient for most cases, O(m+n / m)

<br/></li><ul><li id='temp:C:VbXe047ad3a84f14318b6adc1c78' class=''>This is sublinear in the length of text

<br/></li><li id='temp:C:VbX753e27a719dd4318a5b8ac0fc' class=''>Degenerates toward brute force for smaller alphabets

<br/></li></ul><li id='temp:C:VbX96d9fd38b29441a9a791d2aa6' class=''>Versatile (lots of mods and variations)

<br/></li><li id='temp:C:VbX9ae6b94a8fb94fe6acea076e8' class=''>Works best in scenario with large alphabets where we can skip a lot of them (e.g. finding a word in text for a language with a large alphabet)

<br/></li></ul></div><h3 id='temp:C:VbX0548696a56ca4086aa7e5ebb5'>KMP</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXf87e9aaca1f1445d9d3c25d90'><li id='temp:C:VbXd75d05db64154889b40a22a38' class='' value='1'>First worst case linear time pattern matching algo.

<br/></li><li id='temp:C:VbXeb053ef0e06848719bc9ffa98' class=''>Works better than BM if alphabet is small.

<br/></li><li id='temp:C:VbX06e77c3ee6d34854bd176b22f' class=''>Can be used in streaming since it never goes backwards

<br/></li></ul></div><h3 id='temp:C:VbX2a7d16b874b0486c95cbd0750'>Rabin-Karp</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX288c92387942445580e67acc1'><li id='temp:C:VbX996ac641b49b4963ba9284f16' class='' value='1'>Efficiency: Worst case O(mn) but generally linear using a good hashing algorithm

<br/></li><li id='temp:C:VbXc95a4c6719b04c04af07badbc' class=''>Space: Small memory footprint.  BM and KMP require storing tables of length O(m) or O(s)

<br/></li></ul></div><h2 id='temp:C:VbXd56d32072adc43c5a2784f612'>Module 12 Review</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Hzof8f5q-5raRYJXPIiuKw?a=4sQ9oBtKQRraazwKsT9VnFNy93DFJtzqaWkBdBbqpGca' id='temp:C:VbX9853fbbb24d949429b58c77d2' width='638' height='588' alt="image.png"></img></div><h3 id='temp:C:VbX0d913abcd3db4dd0807fb93d1'>Big-O Summaries</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5ottOhpPIunuA2d35AHZ_w?a=pc4LLrxaOTE7TLGavUaNIQO1syXdDy9RPHtOGadAoAIa' id='temp:C:VbX4e90f94bc364417ea8344740a' width='800' height='199' alt="image.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/QSmnXT0N9fyRENp0aZFy9g?a=bzlKkYJUCbdAubk2pjlq3lpfQdIwBThVKigW5umsJhUa' id='temp:C:VbXe43ef0bf991b4061a60978249' width='800' height='199' alt="image.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/94lHeZW-jr_rF1bvbxzN9g?a=KTkPiW1HUhSEcrp2rMV6wwxWlEJkKEai7EUMDtW7tuUa' id='temp:C:VbXf9bdc136b2494ce49379bbe03' width='800' height='234' alt="image.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Xwm7w0Q4Ps4_vGl9dfLVVg?a=pix7hCmKZBSxZkHw1ciPdvUIGPTpSLMWH8vwHFdwtwsa' id='temp:C:VbXa7cc8845e7f246e39ac8a57f3' width='800' height='234' alt="image.png"></img></div><h1 id='temp:C:VbX59841bad0ff64dcfa7abd7d09'>M13 Graph Algorithms</h1>

<h3 id='temp:C:VbX5ea0cce9baa34a2891ed6e99d'>Terminology</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX05abce3039514042a2445506a'><li id='temp:C:VbX7d95031618b84eb1b52c5d260' class='' value='1'>Binary trees and LinkedLists are graphs

<br/></li><li id='temp:C:VbX59b2ed16e00c4b60803589a22' class=''>Graph: G = (V, E)

<br/></li><li id='temp:C:VbX5662f6fa9b3f47e99552afb07' class=''>Order(G) = |V| .  Number of vertices

<br/></li><li id='temp:C:VbX3068e9d97a1b42b5ab60a08a5' class=''>Size(G) = |E|.  Number of edges

<br/></li><li id='temp:C:VbXcf3791dc48e84733b9140612e' class=''>Degree of a vertext: deg(v).  How many edges a vertex has.

<br/></li><li id='temp:C:VbX06635857cdbc4899aa978f3e0' class='parent'>Edge: e = (u,v) where u, v are vertices

<br/></li><ul><li id='temp:C:VbX6b36041b96e44e0b895b2b5c1' class=''>“Incident on a vertext” , directly connected

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/UhzG-YdZPUpclXQDM0ToVw?a=RoIYeqaimWHOgZnnA7LnPfokdYVv3DCeBCthJRlUaCEa' id='temp:C:VbX7a663a975b9a43f4aa475c613' width='800' height='389' alt="Screen Shot 2024-07-13 at 6.03.04 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX37b4da65cef447759a709ff15'><li id='temp:C:VbXcc3c7cac1a974edab0b38a0e3' class='' value='1'>Directed: All edges are one-way

<br/></li><li id='temp:C:VbX220f59ad8d794951bab209d49' class=''>Undirected: All edges are two-way

<br/></li><li id='temp:C:VbX4e9760a8a03346ac91a5effa5' class='parent'>“Path” - set of edges that connect a pair of vertices

<br/></li><ul><li id='temp:C:VbX0447aee5d66c43b6897ff1248' class=''>“Length of a path” - number of edges traversed

<br/></li><li id='temp:C:VbX98b479632f694297942bb01bb' class=''>“Simple path” - path does not repeat vertices

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oVd7bI_GNyxnKWHUPfUgUw?a=bRs5lXN9O4UFZFE3CrxWFGSy4XfmaaJVIuNF2D1V1A8a' id='temp:C:VbXabd34bbfc7dd4f91b36c8b9f5' width='800' height='367' alt="Screen Shot 2024-07-13 at 6.05.14 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXcddb075f48c7498e9eba00ee5'><li id='temp:C:VbX74238ee7f700468aac2f2c792' class='' value='1'>Edge weights: Quantify cost of traversing an edge

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Yx0qKU9sKwr2jcXd4A2StA?a=wkUH1RvbAfResQyFPjkqB2pJb6HFMIpmLIGHFyQYaEga' id='temp:C:VbXe526693dc76a4ff0a244a7a42' width='800' height='335' alt="Screen Shot 2024-07-13 at 6.05.48 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXb3d2b7b584624b5a83c01945b'><li id='temp:C:VbXed10ee5ff6fb47b0a5e21801d' class='' value='1'>Dense - number of edges is close to maximal number of edges

<br/></li><li id='temp:C:VbX9a957ff0617e4d2d88647cf34' class=''>Sparse - number of edges is minimal

<br/></li><li id='temp:C:VbX62b1e31e557e4d5097ca3855e' class=''>Disconnected - a vertex is disconnected from rest of graph

<br/></li><li id='temp:C:VbX48b036ddb05848aba3e8d4d1e' class=''>Connected - all vertices are connected.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Pk24cVUfFi-fMz3B4_3jBA?a=PtHUmWYMEc6CnqBMRtkwCaEgXm9oaIUlCkfoTO31Qg8a' id='temp:C:VbXa64a12b81a63483cbba6d7654' width='800' height='328' alt="Screen Shot 2024-07-13 at 6.06.54 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXc13795860a0748f98727a6006'><li id='temp:C:VbXbfe45b126ba04f1fb32887121' class='' value='1'>“Simple” - doesn’t have self-loops or parallel edges

<br/></li><li id='temp:C:VbXf8dc32386ad547e881c609988' class=''>“Non-simple” - has self-loop, parallel edges

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0nyQrobhrQ6GnCqoX5WLlA?a=LGaKkHTm6doxcawNnaHs1aYlAkfLuFZ65CyXZv718TIa' id='temp:C:VbXea815942b2504c18933e49757' width='800' height='353' alt="Screen Shot 2024-07-13 at 6.07.53 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXf0eceb69ac0a408a990006e00'><li id='temp:C:VbX6b88868b9972440c8bddb8cbd' class='parent' value='1'>“Cyclic” - vertices are repeated through a graph

<br/></li><ul><li id='temp:C:VbX9b0331cd9e3a4de4b5a31c5a8' class=''>Can go through paths in a cycle

<br/></li></ul><li id='temp:C:VbX7f9185854ad740c9a0554d991' class='parent'>“Acyclic” - path has no cycles

<br/></li><ul><li id='temp:C:VbX89884228e5284617a9adfbfc9' class=''><b>Tree is a connected, acyclic graph</b>

<br/></li></ul></ul></div><h2 id='temp:C:VbX46fe153d9a65494fb3ac84777'>Graph Terminology and Conventions</h2>

<h3 id='temp:C:VbXb298893a61a544628b625fbb1'><b>Undirected v. Directed Graphs</b></h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5a715228fdc94023a309c49ef'><li id='temp:C:VbXf2629620175f4c068dedf76f8' class='parent' value='1'>Undirected: edges in E are defined as unordered pair {u, v} where u, v are vertices in a vertex set V

<br/></li><ul><li id='temp:C:VbX44c2a3c9512a4d1389bfda7eb' class=''>{u, v}, and {v, u} represent same edge object

<br/></li></ul><li id='temp:C:VbXc40cb69d0b714a5ab86982f02' class='parent'>Directed (digraphs): edges in E are distinct ordered paris (u, v) where u is the origin and v is destination.

<br/></li><ul><li id='temp:C:VbXae62962699ad4c67bd65662b8' class=''>(u, v) and (v, u) represent different edge objects

<br/></li></ul></ul></div><h3 id='temp:C:VbX725a8239b97e4feb83268525f'><b>Paths, Trails, Cycles, Circuits, and Walks</b></h3>

<b>Path:</b> sequence of non-repeated adjacent vertices (aka “simple path”)<br/>

<br/>

<b>Trail: </b>repeat vertices allowed, but edges can’t repeat (aka “trail”)<br/>

<br/>

<b>Walk:</b> Trail where edge can also repeat.<br/>

<br/>

<b>Cycle:</b> Path where 1st and last vertices are adjacent (and can connect)<br/>

<br/>

<b>Circuit:</b> Trail where 1st and last vertices are adjacent.<br/>

<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/zuz7GStHKEkQ69nEFv1jCg?a=Rao33vEK0qh41ZLijlW1TR05aY2azJBdmma5EHaXwRwa' id='temp:C:VbX55c482cf92cb4467a9e73fa25' width='800' height='283' alt="image.png"></img></div><h3 id='temp:C:VbX0e99586e214e43588058df40b'><b>Simple Graphs, Self-Loops, and Parallel Edges</b></h3>

Now let's look at different types of edges and see how they affect a graph:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXc2c127b81ad941bc8d1e29b86'><li id='temp:C:VbX36881b9e27d54effa9a9511b4' class='' value='1'><b>self-loop</b> is an edge where the start vertex and the destination vertex are the same. 

<br/></li><li id='temp:C:VbX9c9be2b685b142a3becfede42' class=''><b>Parallel edges</b> are where there exist multiple edges between two vertices with the same orientation. 

<br/></li><li id='temp:C:VbXa2e390a080514b0d9274bc8b5' class=''>A graph is <b>simple</b> if there are no self-loops and no parallel edges, and when we say the term "graph," we are usually referring to a simple graph. 

<br/></li><li id='temp:C:VbX6d744271a84e4b9fbb2c44417' class=''>When we want to specifically allow self-loops and parallel edges, we instead refer to it as a <b>multigraph</b>.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/RdC9TkKgVBl_iOXJe6akVQ?a=AO9y8Wm8D00Vz70ErceGJUzVkrirIXGyQb4Q7L58Kvka' id='temp:C:VbXde5f3c4710db4ab38dfb68af0' width='800' height='370' alt="image.png"></img></div><h3 id='temp:C:VbX51bbe1749fdd4c56b3ca067bf'><b>Graph Complexity</b></h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX547434885c034c70a225ad6eb'><li id='temp:C:VbX032d36d79e7649c1a2639e402' class='parent' value='1'>Growth functions are in terms of |𝑉| and |𝐸| (verex set / edge set)

<br/></li><ul><li id='temp:C:VbX873d7040869b490f8296bb104' class=''>Some sources will forego the cardinality notation and just use 𝑉,𝐸 directly to refer to the number of vertices and edges.

<br/></li><li id='temp:C:VbX00131ab88a7f4514882fd6dc3' class=''>Another common convention is to define 𝑛=def|𝑉| and 𝑚=def|𝐸|. 

<br/></li></ul></ul></div><h3 id='temp:C:VbXb875dd1135cc4fe4991da5485'><b>Connectedness in Graphs</b></h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX67bbc22dc0fe4231a18e9e249'><li id='temp:C:VbXf84f9d40eef54f3e99e8f243b' class='' value='1'>In an undirected graph, the graph is <b>connected</b> if for every pair of vertices, there exists a path between the two. 

<br/></li><li id='temp:C:VbXad517dd98f2e442da635cfe4d' class='parent'>For digraphs 

<br/></li><ul><li id='temp:C:VbXb8c3dbf7292a4a8199d99a2d4' class=''>Path from 𝑢 to vertex 𝑣 in a digraph <i>does not imply</i> that a path from 𝑣 to 𝑢 exists. 

<br/></li><li id='temp:C:VbX4b1aba9f99e94f778694ad422' class=''>If a digraph is connected in the undirected sense, where the edge orientations are removed, then the graph is connected and it is referred to as <b>weakly-connected</b>.

<br/></li><li id='temp:C:VbX5388bc975e0c40289c4be7af7' class=''> If the graph is connected in the sense that every pair of vertices has a path between them, then the graph is considered <b>strongly-connected</b>.

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/7xSj9UtVUKrqp4pl8FAYcg?a=vnAOuFFikxrg2WNLDj0sbmrlSWUew2TX3Iugdabgem0a' id='temp:C:VbX41ab9b5e7804475899d0187a6' width='800' height='213' alt="image.png"></img></div><h3 id='temp:C:VbX56b4253018bb4503b7f86ca67'><b>Dense v. Sparse Graphs</b></h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXf377980f973d452895ffac727'><li id='temp:C:VbX6ef1ae467dbf4d23ab2d929f5' class='' value='1'>A graph is <b>dense</b> if <control data-remapped="true" id="temp:C:VbX99434793a1f1452cb55b44a85">m=Ω(n2)</control>

<br/></li><li id='temp:C:VbX8a6ab06514d245d18a7232a83' class=''>A graph is <b>sparse</b> if <control data-remapped="true" id="temp:C:VbX5d5a34e8191a4c6e9f1ff8d1b">m=O(n)</control>

<br/></li></ul></div>To motivate these definitions, let's first consider a simple graph where the number of edges is maximized, a complete graph <br><control data-remapped="true" id="temp:C:VbX4e1ee90fb095433db549e5a55">Kn​</control>. <br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7726326b6fc84d049195d4251'><li id='temp:C:VbX36a22825d820435fbd62b8b8b' class='' value='1'>The number of edges this graph has is a combinatorial problem. We have 𝑛 vertices, and we need to count how many ways to pair them up, ignoring the ordering of the pairing. <b>This is precisely <control data-remapped="true" id="temp:C:VbXff6b42c366ee49fb85c7a2067">(n2​)=2n(n−1)​≈n2</control>edges. </b>

<br/></li><li id='temp:C:VbX1b089f8a62a041e3beae6ecef' class=''>The sparse definition gives us a way of determining whether the number of vertices is the dominant growth term or the number of edges is.

<br/></li></ul></div>Putting this in the context of graph complexity:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX4511782446734569a09c87583'><li id='temp:C:VbX9d260030e1074aa99fdf60769' class='' value='1'>When the graph is not simple, then 𝑚 and 𝑛 can be independent from each other since we can always add parallel edges or self-loops to increase 𝑚. 

<br/></li><li id='temp:C:VbX0697b82790a4463fa60c921f2' class='parent'>When the graph is simple, there is in fact a hard combinatorial relationship between the two, namely that in general, <control data-remapped="true" id="temp:C:VbXf45ebe684abf40c0a5ff70801">m=O(n2)</control>. 

<br/></li><ul><li id='temp:C:VbX1c7612fd1785442b910eb24bd' class=''>If graph is dense, then we have that <control data-remapped="true" id="temp:C:VbXe1210091255b4e87b537e9053">m=Θ(n2)</control>

<br/></li><li id='temp:C:VbX684ffc3e16394922b07633bae' class=''>If graph is sparse, we have that <control data-remapped="true" id="temp:C:VbX95b5b69465864dc2869e0f182">m=O(n)</control>. 

<br/></li><li id='temp:C:VbX65ab0a13075643bea13ed4279' class=''>A disconnected graph is always sparse.

<br/></li></ul></ul></div><h3 id='temp:C:VbX360927b855c54bdbb64b38587'><b>Common Graph Families</b></h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/llE3P2dKNsyAYgDsXNS21g?a=RgfgkKj3MMDTa6UfqdixSpk21ARL6wRfIiRg7U4oQ0Ea' id='temp:C:VbXcb35b64ff9bf433a81df1a861' alt="image.png"></img></div><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX49a20ea1ce9d4fddb285beee0'><li id='temp:C:VbX236843f16a324508a2edd2f2a' class='parent' value='1'>Top-left: <b>complete graph</b> (also called <b>clique</b>) 𝐾𝑛 on 𝑛 vertices. 

<br/></li><ul><li id='temp:C:VbXded46f6bf21740ab9677b9cb9' class=''>The complete graph is just an undirected graph where every edge is present.

<br/></li><li id='temp:C:VbX371687cfd3364817bc1dc47e4' class=''>If directions are added to each of the edges in the complete graph, then the graph is called a <b>tournament</b>. 

<br/></li></ul><li id='temp:C:VbX3badef0f668f4c27b1707621e' class='parent'>The upper right graph in the figure below is a <b>cycle graph </b>𝐶𝑛 on 𝑛 vertices. 

<br/></li><ul><li id='temp:C:VbXaad30acd170c40d7becf00fe5' class=''>In the video, we defined a cyclic graph as a graph allowing a cycle, a very loose definition. However, in other areas, the term "cyclic graph" is interpreted as the cycle graph specifically.

<br/></li></ul><li id='temp:C:VbX34f84c0e1125440c8de7350cc' class='parent'>The lower left graph in the figure above is a <b>tree</b>

<br/></li><ul><li id='temp:C:VbX5be729f1eb7b4725baf4613d6' class=''>In graph theory, a <b>tree</b> is an acyclic, connected graph.  

<br/></li><li id='temp:C:VbX92fcb1db02ae4f1ab6f3a00ca' class=''>In a sense, a tree is a graph for which we've maintained connectedness with the minimum number of edges. One can prove that any tree of 𝑛 vertices will have 𝑚=𝑛−1 edges. 

<br/></li><li id='temp:C:VbX39cddb1bbc134c1391859b32e' class=''>If we drop the requirement of connectedness and just maintain that the graph is acyclic, this is also called a <b>forest</b>. 

<br/></li></ul><li id='temp:C:VbXb16208ce66554f24897280314' class='parent'>Lower right graph in the figure is the <a href="https://en.wikipedia.org/wiki/Petersen_graph">Petersen graph</a>. 

<br/></li><ul><li id='temp:C:VbX0130925bb51d480dace2798bd' class=''>The Petersen graph will not be important for this course, but if you're a theory student interested in learning graph theory, this graph is a nice small graph to have around because it serves as a counterexample for many graph problems. The Petersen graph has multiple copies of <control data-remapped="true" id="temp:C:VbXf7281b3f32034cf49a713b84c">C5​</control> as <b>subgraphs</b>; try to find them!

<br/></li></ul></ul></div><h2 id='temp:C:VbX114c8f0302b6425a86a46dc67'>Graph Representations</h2>

<h3 id='temp:C:VbX83052f76a15f49d6ba5ade0d1'>Graph ADT Procedures</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/di0_AgJIsndJCIeNmbvMFg?a=aOAMhQwLRbVd6ArCLHYsBxd1nyOY3DZpv4nik9SSY1ca' id='temp:C:VbXa9eacdb32b8c4bc8870ac9841' width='800' height='218' alt="Screen Shot 2024-07-13 at 8.09.17 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/LehmoMhXHONhXMfHsp0E2Q?a=adKxusbdtHA8TCeyNyBEpwFlkHZYxL10g7wfwR02vHMa' id='temp:C:VbX1a311f5e02e045349d6feac7a' width='800' height='271' alt="Screen Shot 2024-07-13 at 8.09.31 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/1M5SyqUG0L2vb-5bBXJ3mA?a=Zafp4X8j6LfiIxvNITe2OYatRJVBoLGHDkdmGnH5egwa' id='temp:C:VbX76b316792ad04cb0ab4be6e76' width='800' height='265' alt="Screen Shot 2024-07-13 at 8.09.47 PM.png"></img></div><h3 id='temp:C:VbX089b2079fbc44dcbace137199'>Graph Representation - Considerations</h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX4862c50663d546abaa5ade656'><li id='temp:C:VbX9a9fee3012eb40efbd90fbf29' class='' value='1'>Efficient data storage - need auxiliary data structures when adding / removing vertices and edges

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HfcBoewVjjRVQKwI4tnsZQ?a=oU35S8NfyVS0C5WNWOtLk47aTErgxaxMutpo9yyHmtMa' id='temp:C:VbXdbcdfcd7ed3f4d31a2d600338' width='800' height='321' alt="Screen Shot 2024-07-13 at 8.12.08 PM.png"></img></div><h3 id='temp:C:VbX31777f42303a4ecea07207f7d'>Adjacency Matrix</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/vzBHeYEJcke2AI-onfvqRw?a=uf3zUhk5f2QCmltia9OQoRyUOjaBBXZRXzVM3P6XtdMa' id='temp:C:VbX5be62cad96e645aba74811392' width='800' height='380' alt="Screen Shot 2024-07-13 at 8.12.32 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX6aeebb2b2e464baab67d394b2'><li id='temp:C:VbX884f34fece9a4c4681299b429' class='' value='1'><b>Space Complexity - O(|V|^2)</b>

<br/></li><li id='temp:C:VbXacbe63831e0f468688f167556' class=''>Not efficient if vertices added

<br/></li></ul></div><h3 id='temp:C:VbX3555c1a8bfe44508a32f3a66d'>Adjacency List</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ODZ2JOsbbpAxV_42LGryTA?a=pCTkCoSoG6xJ7ZfmIf5mBxFsLV7hrH49dOk3AgXKkY0a' id='temp:C:VbXc6e211d262464f5681658a155' width='800' height='385' alt="Screen Shot 2024-07-13 at 8.14.11 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXea966513848d486f9c7c0aa0a'><li id='temp:C:VbX28699a0daba04c8cb9151159c' class='' value='1'><b>Space complexity: O(|V| + |E|)</b>

<br/></li><li id='temp:C:VbX5740bd4312ed4508961f24f7c' class=''>Works well when graph is sparse

<br/></li><li id='temp:C:VbXf2b601a074a947dd8a639a38a' class=''><b>(Type used in this course)</b>

<br/></li></ul></div><h3 id='temp:C:VbX70ef5e368665454082abc10af'>Edge List</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/3NoOtNLZ26wNgxC8fFkeSQ?a=922dZyTC7Zomf9WUfpD0wwmr44mKmH1IYyHChvamBTMa' id='temp:C:VbXae12f2985c1a483b8d44fa580' width='800' height='356' alt="Screen Shot 2024-07-13 at 8.14.39 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX753fddab87584660a7309fde0'><li id='temp:C:VbX748386d880b642e39e8b50d99' class='' value='1'><b>Space complexity: O(|E|)</b>

<br/></li><li id='temp:C:VbXf334079162c94360877bc3710' class=''>Efficient way if only edges need to be considered.

<br/></li><li id='temp:C:VbXcb619dc53f30418cb421218bc' class=''>Completely omits isolated vertices

<br/></li></ul></div><h2 id='temp:C:VbXe40a56a176514d90b9e0e44ef'>Depth-first Search (DFS)</h2>

Implementations:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXc9f30526f3b2484c86491d13f'><li id='temp:C:VbX761b251e2f9d4aab9956fb23e' class='' value='1'>Non-recursive - similar to BFS

<br/></li><li id='temp:C:VbX54c2ba5d34e64232a292bc170' class=''>Recursive

<br/></li></ul></div><h3 id='temp:C:VbXc45c68a7b9b0468faa6ce695f'>Non-recursive DFS </h3>

(algorithm not covered in course)<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/GNmjDCgTPuXD3dOlSzmmCQ?a=j5HPyjHoljMetwE7SFgcx7TZTtHHZDe9hfyRa00hlksa' id='temp:C:VbXb4ee58396fe141bb88d4c7be5' width='800' height='300' alt="Screen Shot 2024-07-13 at 8.24.29 PM.png"></img></div><b>CSVizTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/oOJ_7bYKnBDKGHRbABSSvw?a=VJtwrIepmkXjIqGfCsi6D70YgDuR2wvYEfoVGGA2dVYa' id='temp:C:VbX802a11cf6ce9475da44d99884' alt="Screen Shot 2024-07-13 at 8.40.51 PM.png"></img></div><br/>

<h3 id='temp:C:VbX6b4167111e284cc59dadcce28'>Recursive DFS</h3>

<h4 id='temp:C:VbX16ca16be31114ad4858831ca1'>Pseudocode</h4>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/TRDUvucs7mvZCA71ct_FYw?a=dp2bliQk5qaJVzOzfdTD1VDxajaVk1W7WktlHRomfLca' id='temp:C:VbX7d1c0efd96f640eabff1cd0d7' width='800' height='239' alt="Screen Shot 2024-07-13 at 8.24.59 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX40bcbd0b41f24fe7a68cf44c8'><li id='temp:C:VbXda141d9445b94137a7f702ac9' class='' value='1'>Uses a wrapper method that calls the above

<br/></li></ul></div><b>CSVizTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/iFPSbcOlWA-GQzViyyjTzg?a=lSqoXsae1cqMkGemQajBHWoja5ru1lSIALzRDiaZOLwa' id='temp:C:VbX6fc352b5f95c41c6b23615171' alt="Screen Shot 2024-07-13 at 8.36.47 PM.png"></img></div><br/>

<h3 id='temp:C:VbX07e2d816536b411980c1b01b2'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eYPLgkVQAlcFzZ9bmIeyEg?a=a3oi7H1UOgIQh3Ji5aCXmWoO5ZXDh1wGhJopNGmtEaUa' id='temp:C:VbXb52aebfdef1b4677ae25c73c7' width='800' height='345' alt="Screen Shot 2024-07-13 at 8.34.06 PM.png"></img></div><b>CSVIsTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Rpot4tsixQnDoxF1YzUgnQ?a=8SMIPh7DableWQ5NM8Ry6YYdEEHNYQmFoeqIUX4Aay0a' id='temp:C:VbX328f710e67294d898f048bb59' width='800' height='347' alt="Screen Shot 2024-07-13 at 8.35.20 PM.png"></img></div><h3 id='temp:C:VbXc4f408a78e7547208c48f2701'>Efficiency</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX52925f386d5a45759ca91ceaf'><li id='temp:C:VbX2397e74ce97e481d902028f68' class='' value='1'>Dependent on data structure used

<br/></li><li id='temp:C:VbXe4cdc583c4324a7193cec15c8' class=''>Assume that the visited set and recursive call stack implemented in the algorithm have <br>𝑂(1) standard operations.

<br/></li><li id='temp:C:VbX60c3754f11a44c21bea76f634' class='parent'>Actions in DFS:

<br/></li><ul><li id='temp:C:VbXbda6f619bbbe43a99fc2f9c79' class=''>Visit each vertex <i>V</i>

<br/></li><li id='temp:C:VbX56b3a1e4780b46e5b8a96243c' class=''>Consider all edges <i>E</i>

<br/></li></ul><li id='temp:C:VbX8d946e8259234867afd18e012' class=''><b>Efficiency: <control data-remapped="true" id="temp:C:VbX8262f6fbd97b4c388c9d7214f">O(∣V∣+∣E∣)</control></b>

<br/></li></ul></div><h3 id='temp:C:VbX9928f48505584cd5921f1928f'>Notes</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd2ddbb1f18bc4e09882a5514c'><li id='temp:C:VbX2809ecec22da4f4987e6e13c7' class='parent' value='1'>Suppose that we are given the following vertex list that is the output of DFS on some unknown, undirected, connected graph: [𝐴,𝐸,𝐹,𝐷,𝐻,𝐵,𝐶,𝐺]. Briefly describe how the graph <b>could</b> look like. Note that there may be more than 1 possible graph. <i>HINT</i>: What data structure would the graph resemble?

<br/></li><ul><li id='temp:C:VbX4b95faca1d504bff99cc714b6' class=''>A: Graph would resemble a tree

<br/></li></ul><li id='temp:C:VbX913351510e4341f0970745607' class='parent'>Recursion vs Stack method - Given same starting point yields different order of retrieved lists

<br/></li><ul><li id='temp:C:VbX264b4923e88c47ec9cfd2ff1f' class=''>Why? Because stack method places vertices onto a stack and popped from the end (LIFO style).  The last neighbor pushed will be the first visited when the stack is popped, which can lead to a different visitation order.

<br/></li><li id='temp:C:VbX6cb22f349a88493aab02dce5a' class=''>How to keep same order: When using a stack, push the neighbors of each vertex in the reverse order of how you would explore them recursively.  Ensure that the order in which neighbors are considered is consistent between both implementations.

<br/></li></ul></ul></div><h2 id='temp:C:VbX72ce29645a1a4b8aa6f605d22'>Applications of DFS</h2>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXb3f7247d07db4192bd1b4e63c'><li id='temp:C:VbXfb60f2312691472b86b255f6b' class='parent' value='1'>Use to detect if a graph is connected.

<br/></li><ul><li id='temp:C:VbXa11ebf069f1c40c98e79bb1e8' class=''>If a graph is connected, DFS can find if there exists a path from one vertex to another

<br/></li></ul><li id='temp:C:VbX423b2e7748304fbeb98274629' class='parent'>Use for cycle detection.

<br/></li><ul><li id='temp:C:VbX38be0fdf99d4488a9d7c6be5b' class=''>Mixed with no.1, can detect if graph is a tree.

<br/></li></ul><li id='temp:C:VbX7b91db4fb2d64a86a68fc88ec' class=''>Obtain a <b>spanning tree</b> of the graph, ie. a subgraph of the original for which all vertices are connected with the smallest number of edges.

<br/></li><li id='temp:C:VbXfa00de0725164f34b6f0da7ee' class=''>Detect if a graph is <b>bipartite</b>, ie. we can partition vertices into two sets where there are no edges between vertices in the same set.

<br/></li><li id='temp:C:VbXd9eefaa5065c4e64860a47e4d' class=''>Simulate decision for AI for games with structure.

<br/></li><li id='temp:C:VbXaf752032dfed45a3817abdc27' class=''>Topological sorting on <b>directed acyclic graphs (DAGs)</b>.  Can use DFS to get ordering of vertices based on edge orientations.

<br/></li><li id='temp:C:VbX7fc38131f6cd486693f3bde75' class='parent'>Obtain a meta-graph of strongly connected components in a digraph.

<br/></li><ul><li id='temp:C:VbX48413f61d8ef4ee38335527de' class=''>We can treat each strongly-connected components as a single vertex of a new meta-graph.

<br/></li></ul></ul></div><h2 id='temp:C:VbX504843c0cfdc4617931ff7160'>Breadth-first Search (BFS)</h2>

<b>Key Idea</b>: Visit all vertices reachable through connections from some indicated start vertex.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb2634f13bb5e47a49aa019abe'><li id='temp:C:VbX577a5083d4fa4a8aa8e1fa3cc' class='' value='1'>Both DFS and BFS are exhaustive search algorithms. If there exists a path to a vertex, both BFS and DFS will find it.

<br/></li><li id='temp:C:VbXabc3017ea81f4dd2a8f1aeb57' class=''>In this course, ties are broken by alphabetical order

<br/></li><li id='temp:C:VbX941c6592829b46dc9c62a987b' class=''>Note: Not all edges will be traversed.

<br/></li></ul></div><br/>

<b>Requirements:</b>   1) Queue, 2) Visited set, 3) Starting vertex<br/>

<h3 id='temp:C:VbX75f0ded1f61344c3a1f3a03ae'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/BDCEsmXqGkzI9eHJ3T9nDQ?a=wKqfPsHw4HH3dKxLRUY7fnXbvLeiG78lmOUuIeMaXCUa' id='temp:C:VbXf98d07405e9d459ba58b613a7' width='800' height='363' alt="Screen Shot 2024-07-13 at 9.11.10 PM.png"></img></div><b>CSVizTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/vMumpxFa6daOFIm3glXOmg?a=JKd3yXv93z4WFktZstruYqmjk42WtITDRNqE94ykFGAa' id='temp:C:VbXf75e5154b1d048b3ba6433a5e' alt="Screen Shot 2024-07-13 at 9.13.38 PM.png"></img></div><br/>

<h3 id='temp:C:VbXd63ef99d95d644b4a944166d5'>Efficiency</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX383ddb4984f745bab3229014e'><li id='temp:C:VbX2327da64f9ce4189bffc934c7' class='' value='1'>Assume visited set and queue implemented in the algorithm have O(1) standard operations

<br/></li><li id='temp:C:VbX5e06737a0c8f4e2fab9c39ec4' class=''>Considerations are 1) visit each vertex, and 2) consider all edges

<br/></li><li id='temp:C:VbX0758eb2251f74dd5980efdd4d' class=''><b>Efficiency: O(|V| + |E|)</b>

<br/></li></ul></div><h2 id='temp:C:VbX2564eb0c50804425952af0a6b'>BFS vs DFS</h2>

BFS when to use:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXca16d638807942d5a10e523ff'><li id='temp:C:VbX23f19bb5d5774300b90754acb' class='' value='1'>If it is known that the vertex is relatively close by compared to the size of the graph.

<br/></li><li id='temp:C:VbX23a8c4a6254944ab9f2137132' class=''>If we are doing a traversal of a tree from some root node and the depth of the tree is large

<br/></li></ul></div>DFS when to use:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXa85dc03453744d0fb319c6dbb'><li id='temp:C:VbX78a0ed34a7684d649efeda160' class='' value='1'>If each node has many neighbors, then a BFS will quickly blow up in space usage since we need to store all of these neighbors in a queue.  Relevant to AI where decision space is infinitesimally large. 

<br/></li></ul></div>Summary:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX9d7505b9ba794870a6cc8a4c3'><li id='temp:C:VbXae97220dea4b4bb2ae015e9c0' class='' value='1'>The heuristics we have, may tell us where to search, in which case we may switch between the two strategies depending on the graph's structure.

<br/></li><li id='temp:C:VbX0cb0bee138c745cba07da1d20' class=''>Main challenge with graphs is scale (ie. social networks)

<br/></li><li id='temp:C:VbX4b2ff13e65a544ca8475accd0' class=''>As you learn more about algorithms and graphs once you finish the course and are out the algorithmic world, you may find a slant towards DFS over BFS.

<br/></li></ul></div><h1 id='temp:C:VbX4c04f4fbb2464e3eb2e09ec91'>M14 - Dijkstra’s Shortest Path</h1>

<h2 id='temp:C:VbXca486667d087476b83a10b6ec'>Algorithm</h2>

<b>Key Idea</b>: Solve the single source shortest paths problem in a graph.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa7f8da3ba7634f0eb8dde3d18'><li id='temp:C:VbX48dc8408d012451e8a3537800' class='' value='1'>Dijkstra's algorithm solves the shortest paths problem where all weights are non-negative, and there is a single source.

<br/></li><li id='temp:C:VbX30c20649802146b3b572ec089' class=''><span style="color:#ccb800" textcolor="#ccb800">Warning: Only works on non-negative weights</span>

<br/></li></ul></div>There are variations of the <b>shortest paths</b> problem, based on certain parameters:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXf02deafd90914dcd8cd34984a'><li id='temp:C:VbX6041ef815838491994ddaef90' class='' value='1'>Are there negative edge weights present in the graph?

<br/></li><li id='temp:C:VbX067a90a0a7694ab793a2e03ef' class=''>Are we trying to find the shortest path from a single vertex to another known vertex? (Single source, single destination)

<br/></li><li id='temp:C:VbXdd41a7b687a04fe39be4483c3' class=''>Are we trying to find the shortest path from a single vertex to all other reachable vertices? (Single source)

<br/></li><li id='temp:C:VbX1af5c55f21384a85b231394e1' class=''>Do we want the shortest path for all pairs of vertices? (All pairs)

<br/></li></ul></div><b>Requirements:  </b>1) Priority queue, 2) Visited set, 3) Map, 4) Source vertex<br/>

<h3 id='temp:C:VbX398a7a434f4e475ea0f8f61dc'>Pseudocode</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX98a57a470c6b43b486e1ee7c0'><li id='temp:C:VbX5c462827f60b4598b5f2deabd' class='' value='1'><span style="color:#2cab21" textcolor="#2cab21">Tip: Priority queue always prioritize vertex with shortest path.</span>

<br/></li><li id='temp:C:VbXe26473598c50404d8d3e2c734' class=''><span style="color:#2cab21" textcolor="#2cab21">Tip: If PQ have vertices with equal length, it doesn’t matter which you visit first.</span>

<br/></li><li id='temp:C:VbXfa3f45de2aac45c3914940c43' class=''>Univisited vertex (disconnected) get a distance of inifinity

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8fVobMbpqSZqsNQPq4IJ4w?a=QI9ebIOrqkmHaX5829yrQ49aFrFN2OEQda0Gqn6MwoYa' id='temp:C:VbX653cfaead9304f72a5083d25d' width='800' height='344' alt="Screen Shot 2024-07-14 at 11.25.08 AM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/S43T6-ChW0pHvcYC91GsRQ?a=cjsjH6WJiP9VKU7CAzd7TwzoyGj6sFwe4byp01LLM90a' id='temp:C:VbX928b9c757a4744cb9ec82cc61' alt="image.png"></img></div><br/>

<h3 id='temp:C:VbXad58849f6734456ca817d155c'>Dijkstra's Algorithm: Vertex Distance Updates</h3>

<blockquote id='temp:C:VbXbe4349c4e2cf4bb19187122a8'>Once a vertex becomes visited, is that vertex's distance ever updated again? Why or why not?</blockquote>

<br/>

Key Concepts<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXae9574b44e724e02872809712'><li id='temp:C:VbX91595508aa09457db230b9a45' class='' value='1'><b><span style="color:#cccccc" textcolor="#cccccc">Greedy Algorithm</span></b><span style="color:#cccccc" textcolor="#cccccc">: Dijkstra's algorithm operates on a greedy method, selecting the optimal choice at each step with the goal of finding the most optimal solution to the problem as a whole.</span>

<br/></li><li id='temp:C:VbX2d576196dd5e4350b46ced48f' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Relaxation Process</span></b><span style="color:#cccccc" textcolor="#cccccc">: Throughout its execution, Dijkstra's algorithm maintains and updates the shortest known distance from the source to each vertex. This process, known as relaxation, adjusts the distances based on newly discovered paths that offer a shorter route to a vertex.</span>

<br/></li><li id='temp:C:VbX82de9f3d18044576bc02634bc' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Finalization of Shortest Distances</span></b><span style="color:#cccccc" textcolor="#cccccc">: When a vertex is visited, meaning it is removed from the priority queue, its shortest distance from the source is considered finalized. This is because the algorithm ensures that by the time a vertex is visited, all possible paths to it have been considered, and the shortest one has been chosen.</span>

<br/></li><li id='temp:C:VbXceeaef1893714b27aee89f83f' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Assumption of Non-negative Weights</span></b><span style="color:#cccccc" textcolor="#cccccc">: Dijkstra's algorithm assumes that all edge weights in the graph are non-negative. This assumption is crucial for the algorithm's guarantee that once a vertex's shortest distance is determined, it will not be updated or reduced further by any other path.</span>

<br/></li></ul></div>Why Distances to Visited Vertices Are Not Updated<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc68d97ac2f0a4c4d811772355'><li id='temp:C:VbXb94170fd86f04ebc9a44cd6c9' class='' value='1'><b><span style="color:#cccccc" textcolor="#cccccc">Optimal Path Guarantee</span></b><span style="color:#cccccc" textcolor="#cccccc">: By the time a vertex is visited, Dijkstra's algorithm has already guaranteed that the shortest path to that vertex has been found. This is due to the greedy nature of the algorithm and the process of relaxation.</span>

<br/></li><li id='temp:C:VbX2fbf2d15cb204948b661253f2' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Non-negative Edge Weights</span></b><span style="color:#cccccc" textcolor="#cccccc">: The absence of negative edge weights ensures that discovering a new path to a visited vertex will not provide a shorter distance than what has already been determined.</span>

<br/></li><li id='temp:C:VbX72cf708381b14e2e8d32ab471' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Efficiency and Correctness</span></b><span style="color:#cccccc" textcolor="#cccccc">: Not revisiting vertices or updating their distances once finalized ensures the algorithm's efficiency and correctness, preventing unnecessary computations and ensuring that the shortest paths are correctly identified.</span>

<br/></li></ul></div><h3 id='temp:C:VbXef9498a035684bc1a25abd7d6'>Advantages of Updating Distance Map in Dijkstra's Algorithm</h3>

<blockquote id='temp:C:VbX4e044877d1364c23b5cc153ad'>Dijkstra's algorithm will update the distance map whenever a shorter path is found, regardless of whether or not the vertex has been enqueued or not. What is the advantage of doing this?</blockquote>

<br/>

Dynamic Path Optimization<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7fde49916de8445a8b564bd73'><li id='temp:C:VbX31b56e5df83641d6889003a60' class='' value='1'><b>Immediate Shortest Path Updates</b>: Continuously updating the distance map ensures that the shortest path information is always current, reflecting the most efficient paths discovered up to that point.

<br/></li></ul></div>Enhanced Accuracy<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXf7b16694d0da45f68c967241c'><li id='temp:C:VbXdcb02e08c2a6423c85db7db26' class='' value='1'><b>Guaranteed Optimal Paths</b>: By updating distances whenever shorter paths are found, the algorithm guarantees the accuracy of the final shortest path calculations, ensuring they are indeed the shortest.

<br/></li></ul></div>Improved Efficiency<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX077792cfd3de4cfbac966c1de'><li id='temp:C:VbXeac730ce62f84a6aa197696cf' class='' value='1'><b>Reduction of Redundant Exploration</b>: This approach minimizes unnecessary exploration of longer paths, focusing computational resources on promising paths, thereby improving the algorithm's overall efficiency.

<br/></li></ul></div>Priority Queue Effectiveness<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa28aa1c2bb974f52939e905fa'><li id='temp:C:VbXd59c9dfcd93b482295cd9c2f9' class='' value='1'><b>Optimized Vertex Selection</b>: Updating the distance map enhances the priority queue's ability to accurately prioritize vertices for exploration, directing the search more effectively towards the shortest paths.

<br/></li></ul></div>Algorithmic Flexibility<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa2ddeb61c6e84369a8233a1e4'><li id='temp:C:VbX947962fd64a74fd69265c4dae' class='' value='1'><b>Adaptive Path Finding</b>: The ability to dynamically update path lengths allows the algorithm to adapt to new information, refining its search strategy as it progresses through the graph.

<br/></li></ul></div><h3 id='temp:C:VbX5fdd4e5e6d1c496a805fdb741'>Application on Digraphs</h3>

<blockquote id='temp:C:VbXbc7bacb12916478ebe9fd1a4d'>Is there any reason that Dijkstra's algorithm would fail for digraphs compared to undirected graphs?</blockquote>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX407e433ea09941949f9e90c2c'><li id='temp:C:VbXf2124bbe2a084ee0af92918c6' class='' value='1'>Dijkstra's algorithm is fully capable of handling digraphs, provided that all edge weights are non-negative.

<br/></li></ul></div><h2 id='temp:C:VbXc5633b4a1ea04153ba0b68f91'>Motivating Dijkstra’s Algorithm</h2>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXfe59b2aaeb6347478daac4d1c'><li id='temp:C:VbX03e289bd49cf4d0198a743d79' class='' value='1'><span style="color:#2cab21" textcolor="#2cab21"><b>Assumption</b>: <b>The shortest path between a pair of vertices must be composed of the shortest path to a neighbor plus the incident edge.</b></span>

<br/></li><li id='temp:C:VbXa8523927351544a6b1a8ffdcd' class='parent'>Math:

<br/></li><ul><li id='temp:C:VbX2767e4e5664245b183ce063ea' class=''>Given vertex v1 and vk,

<br/></li><li id='temp:C:VbX02be18bef35c4260b85710959' class=''>Let shortest path distance: <control data-remapped="true" id="temp:C:VbXedcfb777fce04707b1bf55ca6">d(v)=(v1​…vk​)</control>

<br/></li><li id='temp:C:VbX3b31261a119542bfb8b94eae7' class=''>Let weight of edge between vertices if adjacent: <control data-remapped="true" id="temp:C:VbX9d18519768f2403e8a570b5fc">w(va​,vb​)</control>

<br/></li><li id='temp:C:VbX09a3bc3e4f1240a8a802b1050' class=''>Dijkstra’s assumption: <control data-remapped="true" id="temp:C:VbXb258a0b7d89f49c19ed7e7cd0">d(vk​)=d(vk−1​)+w(vk−1​,vk​)</control>

<br/></li></ul></ul></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/daABgLm60azNPk8spJW73A?a=Rx9dmaJLr33bV4QW1hnJpdEFVadG4z19D1bL8tAfX2ga' id='temp:C:VbX2dda0f3e2b914afe9476713f3' alt="image.png"></img></div><br/>

<div class="list-numbering-restart-at" data-section-style='6' style="--indent0: 3"><ul id='temp:C:VbXdf007923954c4558b77501007'><li id='temp:C:VbXaba08ff06eb14c3b9aec1b7d3' class='parent' value='1'>How assumption is used: Processes into 3 subsets, “visited”, “frontier”, “unexplored”

<br/></li><ul><li id='temp:C:VbX0c7eeac99c3742c5903efe81a' class=''>“Visited” = out of priority queue.  Algo guarantees if vertex exited PQ, it found shortest path to that vertex.

<br/></li><li id='temp:C:VbX349c28b346d941a18b0d137cf' class=''>“Frontier” = vertices in priority queue

<br/></li><li id='temp:C:VbXea70df2f38764dadaea6f42f3' class=''>“Unexplored” = vertices that we know exist, but not in priority queue

<br/></li></ul></ul></div><h2 id='temp:C:VbX6b0533f946b646939a322b287'>Efficiency of Dijkstra</h2>

Given assumptions:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXad853f9bb227459291e83dd10'><li id='temp:C:VbX9cfbe3c057254c75a177d0e54' class='' value='1'>Visited set and distance map are backed by a HashSet and HashMap, which have O(1) operations.

<br/></li><li id='temp:C:VbX90ef6fb99a1a4379a88cc3e52' class=''>Priority queue is backed by binary heap.

<br/></li></ul></div>Space complexity:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX2e7697f4c70744b5a43982911'><li id='temp:C:VbX52614178c82540e7a3043d78d' class='parent' value='1'>PQ could contain O(|E|) entries.

<br/></li><ul><li id='temp:C:VbXbde7903b8eee4e318b6f54487' class=''>Each time a new path is considered and added to the priority queue, it is considered a new edge as an extension from the vertex. 

<br/></li><li id='temp:C:VbX7a340f14d70c43c386b8f5396' class=''>No new paths are added to the priority queue, if the vertex is already visited. 

<br/></li><li id='temp:C:VbXb6463a632d9b43009c0ac00f5' class=''>A visited vertex means we found a smaller distance earlier in the search, and it guarantees we do not reuse edges.

<br/></li></ul><li id='temp:C:VbXbcecbe20fe3a45e2aa93407e7' class=''>PQ has add and remove operations.  Add is O(|E|) and remove is O(log |E|).

<br/></li><li id='temp:C:VbX79efa071beff4c6a85b999053' class=''>Thus, <control data-remapped="true" id="temp:C:VbX0d464ed4b2de4c87a464b88f2">Efficiency=O(∣E∣+log∣E∣)</control>

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HkkrsPR5fiVn_8Zpp5uBKA?a=gGBAN9aCW0vKaV6cIaN3CJvmJHaaeR5EBfT2qlagNHwa' id='temp:C:VbXc0da84d3aba8403bb9d364be4' width='800' height='369' alt="Screen Shot 2024-07-14 at 11.46.30 AM.png"></img></div><blockquote id='temp:C:VbXe67831fa2cea4fe9957efa6d8'><span style="color:#2d3b45" textcolor="#2d3b45">Side Note: Some sources may list the time complexity as either 𝑂(|𝑉|2) or 𝑂(|𝐸|+|𝑉|log⁡|𝑉|). The first expression is what happens if an adjacency matrix is used; the cost of going through neighbors dominates the log factors. The second expression is what happens if a Fibonacci heap is used since the amortized cost of adding/updating in a Fibonacci heap is Θ(1). Please keep in mind that Fibonacci heaps are almost never used in practice and are largely for theoretical purposes of bettering the time complexity.</span></blockquote>

<h2 id='temp:C:VbXebfa653cc53c47bfb415231df'>Optimization</h2>

<b>Decoupling “visited” vertices from updates to distance map:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX85a65bec10bc4160bbce89301'><li id='temp:C:VbXc5d5c11d21334871be4f87ba1' class='' value='1'>Rather than only updating the distance map when we visit a vertex and achieve the optimal shortest path to that vertex, we can update the distance map as we find new paths and add them to the priority queue.

<br/></li><li id='temp:C:VbX2ac1cc18367a485e89f07ca05' class=''>This way, we can use the distance map as a criteria for adding to the priority queue to shrink the number of paths we add to the priority queue.

<br/></li><li id='temp:C:VbX21e96b43eefb40f492ef7e197' class=''>This can also let us do away with the visited set if needed, reducing the amount of space by a constant factor.

<br/></li></ul></div><b>Update priority queue updates with a different priority:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX0a40aedfd76544ecaeb98a174'><li id='temp:C:VbX89b584c852ff40bd9542024a4' class='' value='1'>If this optimization is done, then the priority queue's size will never exceed O(|V|), which is ab improvement over the previous optimization.

<br/></li></ul></div><h2 id='temp:C:VbX67b60565d1c2453fa34eac455'>Negative Edge Weights and Cycles</h2>

<h3 id='temp:C:VbX6aedc15edd994f50a54e4bac6'>Negative Edge Weights</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5a6db5a2e01e4979b70372e94'><li id='temp:C:VbXe366db344f404dd8a58377628' class='' value='1'><b>Dijkstra's Algorithm Limitation</b>: Dijkstra's algorithm cannot handle graphs with negative edge weights effectively.

<br/></li><li id='temp:C:VbXdba0f0a50bf74bf6a800267fb' class=''><b>Negative Cycles vs. Negative Weights</b>: It's crucial to distinguish between graphs with negative cycles and those with merely negative edge weights but no negative cycles.

<br/></li></ul></div><h3 id='temp:C:VbX1dc0cefd9ae3417d80590defb'>Negative Cycles</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb245c319d0564744824c1b311'><li id='temp:C:VbX0a33d9f00dc9448bb5a7d1fa5' class='' value='1'><b>Definition</b>: A negative cycle exists in a graph <span style="color:#cc8b00" textcolor="#cc8b00">if there's a cycle where the sum of the edge weights is negative</span>.

<br/></li><li id='temp:C:VbXe559c120165d4f9687c1690a9' class=''><b>Impact on Shortest Path Problem</b>: The presence of a negative cycle makes the shortest path problem unsolvable in a meaningful way, as traversing the cycle can indefinitely decrease the path length.

<br/></li><li id='temp:C:VbX6298e50711754b0185c36bd68' class=''><b>Directed vs. Undirected Edges</b>: Negative edge weights in undirected graphs inherently lead to negative cycles, making them problematic.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Njv4DSxB1P3Q7W0jjumF7Q?a=4ZUaSmAH64o9QbQpDFtRRTebC6pw9iSeXnYeY6E2JnQa' id='temp:C:VbX0a386cbb91af4773bcd84d575' alt="image.png"></img></div><br/>

<h3 id='temp:C:VbXed98c34e1ab34e36977d679fd'>Handling Negative Edge Weights</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX3db4b57bb25a45ad9fc6d3d69'><li id='temp:C:VbXc6aa3bb0833b4da7b639648c2' class='' value='1'><b>Directed Graphs Without Negative Cycles</b>: For directed graphs that have negative edge weights but no negative cycles, alternative algorithms to Dijkstra's must be used.

<br/></li><li id='temp:C:VbXc2e185a47c0c46efb3e0ccbe9' class=''><b>Bellman-Ford Algorithm</b>: Efficient for single-source shortest paths in graphs with negative edge weights, capable of detecting negative cycles. Time complexity: (O(VE)).

<br/></li><li id='temp:C:VbXe67553a8f00246e6b9a8eed40' class=''><b>Floyd-Warshall Algorithm</b>: Suitable for all-pairs shortest paths, works with negative edge weights and also detects negative cycles. Time complexity: (O(V^3)).

<br/></li></ul></div><h3 id='temp:C:VbXb336c0417a3b43d786e2eb402'>Summary</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc356dfd1908d4857838b369ed'><li id='temp:C:VbXe5bf321023a44ea1986a541f5' class='' value='1'><b>Dijkstra's Algorithm</b>: Not suitable for graphs with negative edge weights due to its inability to handle negative cycles and incorrect path calculations.

<br/></li><li id='temp:C:VbX98fb7dde066743d78d800f2b0' class='parent'><b>Alternative Algorithms</b>:

<br/></li><ul><li id='temp:C:VbXf9396db269e84efdb1140f205' class=''><b>Bellman-Ford</b>: Good for single-source shortest paths with negative edge weights, includes negative cycle detection.

<br/></li><li id='temp:C:VbX5d74f5679a764f09926ddd1d5' class=''><b>Floyd-Warshall</b>: Applicable for all-pairs shortest paths, handles negative edge weights and identifies negative cycles.

<br/></li></ul><li id='temp:C:VbX2571f5b9d8d14d708b3781dd0' class=''><b>Efficiency</b>: Both Bellman-Ford and Floyd-Warshall are less efficient than Dijkstra's but necessary for certain graphs with negative edge weights.

<br/></li></ul></div><h2 id='temp:C:VbX923848b5ff7a427980f6d3f35'>Food for Thought -  Heuristics and Search Algorithms</h2>

<h4 id='temp:C:VbX9c02705486344dc5968000819'>Foundations</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe30dc883324a4ff6a8935fad0'><li id='temp:C:VbX5b3adfda4f694842aafa59b39' class='' value='1'><b>Dijkstra's Algorithm</b>: Basis for several search algorithms.

<br/></li><li id='temp:C:VbX954edf2e8d8e46848951742a0' class=''><b>Impact on AI</b>: Influences algorithms like UCS and A* for navigating state spaces.

<br/></li></ul></div><h4 id='temp:C:VbXfa6ca3521e874f108e0a744f7'>AI Applications</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX2175a85abf31425ba958bc409'><li id='temp:C:VbXc9619e6b0f324a9e8642d62d1' class='' value='1'><b>Graphs</b>: Represent AI states and decisions.

<br/></li><li id='temp:C:VbXea9df31fa4dd45459f0863f95' class=''><b>Search</b>: AI uses these algorithms to reach goal states, e.g., maze exit.

<br/></li></ul></div><h4 id='temp:C:VbX2d69cd0ff2e842b59525d2327'>Key Algorithms</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX15ca879710944c91826173b90'><li id='temp:C:VbX7806cfb297dd4ff88617c7794' class='' value='1'><b>UCS</b>: Focuses on reaching a single destination. It's a simpler form of Dijkstra's for large graphs.

<br/></li><li id='temp:C:VbX60d094c7897648879a5ea36b6' class=''><b>Heuristic Search</b>: Uses heuristics to guide the search, notably in A*.

<br/></li></ul></div><h4 id='temp:C:VbX195cf1b1b714450096cf7cbc0'>Heuristics</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1efca17ab23544b4b30b64820'><li id='temp:C:VbXce98a68908764fedab410b39c' class='' value='1'><b>Role</b>: Guide search algorithms towards the goal.

<br/></li><li id='temp:C:VbXe5a42aa1b1704b7984b4b4d31' class=''><b>Example</b>: Manhattan distance helps estimate grid distances by providing general direction of an exit for instance.  Thus aiding A* - It can optimize c(S) + h(S) (cost func + heuristics func)

<br/></li></ul></div><h4 id='temp:C:VbXc6629d3a50e040d78a0e92551'>A* Algorithm</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX49b7ed22ee564f009fa2887f5'><li id='temp:C:VbXc9e479013a3d45d0b9714e59d' class='' value='1'><b>Heuristics</b>: Combines cost so far and estimated cost to goal.

<br/></li><li id='temp:C:VbX08ada6fc5def47cd88e7671a7' class=''><b>Performance</b>: Depends on the heuristic. A* can outperform UCS and Dijkstra's with a good heuristic.

<br/></li></ul></div><h4 id='temp:C:VbXd3f38d2bf87443d0a84241def'>Conclusion</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX6fb51edd85de4a11ba5f6c740'><li id='temp:C:VbX6f03ed3afb4b43dda1e3bd80a' class='' value='1'><b>Evolution</b>: From Dijkstra's to heuristic-based searches like A*.

<br/></li><li id='temp:C:VbXa013f34ced3c4337a1b01125e' class=''><b>Heuristics Importance</b>: Crucial for efficient, goal-directed search in AI.

<br/></li></ul></div><br/>

<h2 id='temp:C:VbX98e9b1f4a0d0472ca85faefe0'>Efficiency in Graphs - Review</h2>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/w9VCWkB9UlkUskGOmKMW-g?a=ElounoZIauDIVANs04kjj1eAbkTfcMYg9a677IXaKS0a' id='temp:C:VbXa26e0d5dc7554d5ebb3f5bb20' width='800' height='348' alt="Screen Shot 2024-07-13 at 9.35.47 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/jjJxdtA4owadGtz6z0YSXA?a=JVnm6Kw8eblguQRB0fPOFHYuZgO8xKoyvSnHsW26ebMa' id='temp:C:VbX92935d5dfac04c56862bbf90f' width='800' height='345' alt="Screen Shot 2024-07-13 at 9.36.28 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/czS0w4MPm3Ea9wHBPJfojA?a=PtlzXTOgOaebBrdFHWTBA59TgTmdB8p9hG0pWrg3f6ga' id='temp:C:VbXed80716d723e45518a69b154f' width='800' height='330' alt="Screen Shot 2024-07-13 at 9.37.02 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Z6FwhB6UPvoUkFnIPxm3DA?a=GeNvw32mwxmXMNZ6WsKvje2r2aHVg7SPyJaOk2FCMLYa' id='temp:C:VbXf04639c2531345ca80e05e822' width='800' height='446' alt="image.png"></img></div><h1 id='temp:C:VbX2e0b31296ce94bda96b567293'>M15 Minimum Spanning Trees (MSTs)</h1>

<h2 id='temp:C:VbXbfd9fb7cebac4f5dab9d114ba'>MSTs</h2>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXe4d44f22095d4956a0a5b9bfa'><li id='temp:C:VbX0270c79326e6411bb9698949a' class='' value='1'>Tree - acyclic connected graph

<br/></li><li id='temp:C:VbX435a8255b77446a1b46d199a8' class=''>Spanning tree - subgraph that is a tree while connecting every vertex in the graph

<br/></li><li id='temp:C:VbX7088b7f200004f9489ff89f34' class='parent'>Minimum spanning tree - spanning tree where sum of edge weights is the smallest possible

<br/></li><ul><li id='temp:C:VbX9e64a74a790b491681f11ab6a' class=''>Can be multiple spanning trees in a graph

<br/></li><li id='temp:C:VbX6323aac97e1742b79b716e225' class=''>(Minimum spanning forest - when MST is applied to disconnected graph)

<br/></li></ul><li id='temp:C:VbXe44fac6731324f85a6bb985c9' class=''>Subgraph - Subset S of a graph G whose V and E are all subsets of G

<br/></li></ul></div><h2 id='temp:C:VbXffedf24b1ed0452e873a73e81'>Prim’s Algorithm</h2>

<h3 id='temp:C:VbX16816b3bfadf478dbe3269d01'>Key Idea</h3>

<span style="color:#2cab21" textcolor="#2cab21">Key Idea: Very similar to Dijkstra, but only considers shortest distance of immediate edge (not cumulative like Dijkstra)</span><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/g7yt1eJ3HTIameZKPM-CkQ?a=HtBd2w84xp7wQfpUx1YO5aASPLLIsmZ74VjDx4hIOoYa' id='temp:C:VbX042d2b247b8c4d7d886244005' width='800' height='368' alt="Screen Shot 2024-07-14 at 2.57.52 PM.png"></img></div>Errata: <br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX4e40fc07a5504d9aade144104'><li id='temp:C:VbXf6e4090fc5124813aba700427' class='' value='1'>The fourth bullet point in the left box should state that the algorithm builds the MST outwards from a single component, one vertex at a time. 

<br/></li><li id='temp:C:VbXbbd0bbc5403f4a95bc7eb7846' class=''>A clarification to the third bullet point in the left box, MSTs in general do not exist for unconnected graphs. The third bullet point in the right box should state "shortest edge," not "shortest path."

<br/></li></ul></div><h3 id='temp:C:VbX70df8c0a5ae4462db130a8f09'>Observing Graphs</h3>

Graph cut - takes a subset of v’s and all e’s connecting them<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/snWqA2mt_PCszrBp-a0zUg?a=7F8noH7E0CxlwgzaAYQPaEVhjIargEhBmsNsXwifayEa' id='temp:C:VbX512000424e4e493b859232f9e' width='800' height='366' alt="Screen Shot 2024-07-14 at 2.56.47 PM.png"></img></div><h3 id='temp:C:VbX714c66990089409cb8006b278'>Requirements for Prim’s Algorithm</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/O274CrGDztZyL5jQaDaisw?a=Du9I2dgs3C9BRT1PGaHlJtIovzNvfK8VzaR9t93KWmsa' id='temp:C:VbXa55b454f10c144428725d39d3' width='800' height='362' alt="Screen Shot 2024-07-14 at 2.58.22 PM.png"></img></div><h3 id='temp:C:VbX5714f325473a406f84cf8abc9'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/Y5Hz_GUu8sG2_kTs13TKfQ?a=zFwUhLcS1KBgNrmo3uECfgxfSDnHcIWTc6gUcXVKy04a' id='temp:C:VbXd2cde8164b934269a197904a3' width='800' height='380' alt="Screen Shot 2024-07-14 at 2.58.44 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/0PYEQ8zFIPA314Gdd0HPKg?a=EXaqo1EkK5cEsTMRANXSJZzatx663aDaFchg7kmoThMa' id='temp:C:VbX9656d44f46a2407c8a5d7ccbe' alt="image.png"></img></div><br/>

<h3 id='temp:C:VbX814ea73b2f474c9d93f9ae788'>Efficiency</h3>

<h4 id='temp:C:VbX481bef19a17446c1a10af5668'>Time Complexity</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXea03e288f80f4619a830a8189'><li id='temp:C:VbXf0d1a05d658a482695aa23827' class='' value='1'><b>Similarity to Dijkstra's</b>: Time complexity for both algorithms will be the same, 𝑂(|𝐸|log⁡|𝐸|). 

<br/></li><li id='temp:C:VbXffa0fdae04f34764bd6a0504d' class=''><b>Priority Queue Analysis</b>: The analysis hinges on the priority queue's implementation, typically a binary heap with O(|E|) entries and removals.

<br/></li><li id='temp:C:VbXcda2d8956c7342af85af032d2' class=''><b>Efficiency with Decrease-Key</b>: With the decrease-key operation, the complexity is <control data-remapped="true" id="temp:C:VbX2025c033685c4f2eb311c6c71">O((∣V∣+∣E∣)log∣V∣)</control>.

<br/></li></ul></div><h4 id='temp:C:VbXddb434ee2aa1474a846e07237'>Java's PriorityQueue</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX59b4bd070bb746b9a8ca8e7a5'><li id='temp:C:VbX79f21b1790694904a4fd43009' class='' value='1'><b>Lack of Decrease-Key</b>: Java's PriorityQueue does not support the decrease-key operation

<br/></li></ul></div><h4 id='temp:C:VbXa1e98bed5ad643358ffa901f0'>Cut Property</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX922211946d47482ebe2990dc6'><li id='temp:C:VbXd3279307182c49d8981d35f0f' class='' value='1'><b>Foundation of Prim's</b>: The cut property states that any Minimum Spanning Tree (MST) <b><span style="color:#cc8b00" textcolor="#cc8b00">must include the minimum cost edge crossing any cut of the graph.</span></b>

<br/></li><li id='temp:C:VbXe397b035eb9a4d218450d996c' class=''><b>Algorithm Mechanism</b>: Prim's algorithm operates by maintaining a set of visited vertices, creating a cut between visited and unvisited vertices. The priority queue, or "frontier," contains edges across this cut, prioritizing the minimum cost edge to expand the MST.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/7v-fhtSVifUyzN-Lsi5hbA?a=5JgdW1zo5wG4ncMZvRn5VDM2JRQt2bQ2xMD11I2h8wsa' id='temp:C:VbX615c68669529439dae1e68afe' alt="image.png"></img></div><br/>

<h4 id='temp:C:VbX7be2f2f730a44ee4808170b66'>Key Points</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXa7acb2a969214fd1b32545d94'><li id='temp:C:VbXc75ba05ac4b64b228ce02a455' class='' value='1'>Prim's algorithm is efficient for constructing MSTs, leveraging a priority queue and the cut property.

<br/></li><li id='temp:C:VbXda87a9e33e9149f4bfe555668' class=''>The algorithm's time complexity is closely related to that of Dijkstra's, with the primary difference being the focus on building an MST rather than finding shortest paths.

<br/></li><li id='temp:C:VbX88c31ffc76ec48ba818611f05' class=''>The absence of the decrease-key operation in Java's PriorityQueue affects the algorithm's presentation and efficiency.

<br/></li></ul></div><h3 id='temp:C:VbX0d05d4b29efc484fa26e457ba'>Example</h3>

Watch video: <br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX6aa3167830ba44d2a61e805bb'><li id='temp:C:VbX7428678fd1c947399ebcb180f' class='' value='1'>Ex 1 <a href="https://gatech.instructure.com/courses/406950/pages/prims-example?module_item_id=4026332">https://gatech.instructure.com/courses/406950/pages/prims-example?module_item_id=4026332</a>

<br/></li><li id='temp:C:VbX84a8d266abf94071b46d8c055' class=''>Ex 2 <a href="https://gatech.instructure.com/courses/406950/pages/another-look-at-prims-algorithm?module_item_id=4026334">https://gatech.instructure.com/courses/406950/pages/another-look-at-prims-algorithm?module_item_id=4026334</a>

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/8im6--xPDECrhrLLcjTgGA?a=DagvH5wD7piBayK7t1ur3A2soatKNRZsgapFuM1aWIka' id='temp:C:VbX54b251388b5c4c6da14c795e1' width='800' height='341' alt="Screen Shot 2024-07-14 at 3.08.05 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5w95T93djdjhXSeKypztLA?a=yDjrZ8jayU5NQTGnSP2nOFqGkKSnIhyl5WdwsIKWC6Aa' id='temp:C:VbXf49d804e4d074225bb2c36ea2' width='800' height='335' alt="Screen Shot 2024-07-14 at 3.08.29 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/pE9R81PfUgN5lfJkM7-t-w?a=ErUpntf0R20teT75OYKQObvabcoLjJNY6QGk5aM7awoa' id='temp:C:VbXd742e94bf5d24c99bd1eb4fe3' width='800' height='350' alt="Screen Shot 2024-07-14 at 6.24.08 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/nL4fNRZDQzcOgT5xgNaYyQ?a=UdMaT3torX7ixc8LzZLmgwKdNlmi2sz75yq6xhoL63Aa' id='temp:C:VbX682e3bf1ad014b63899682c03' width='800' height='375' alt="Screen Shot 2024-07-14 at 6.26.04 PM.png"></img></div>Final MST has minimum distance to get from one v to another v<br/>

<br/>

Warning: There is a point we'd like to make it clear that <span style="color:#cc0300" textcolor="#cc0300">the shortest path problem solved by Dijkstra's algorithm and the MST problem solved by Prim's algorithm are mostly unrelated to each other</span>. Albeit, the pseudocode of the two algorithms appears similar.<br/>

<h3 id='temp:C:VbXc6c9e9c02a8e4814a406af356'>Greedy Paradigm</h3>

<b>Definition</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX72507dbe261e46e098853c14f'><li id='temp:C:VbXc37dade052ab4e36a70fb2fb0' class='' value='1'><b>Greedy Algorithm</b>: Makes decisions based on local optimal choices at each step.

<br/></li></ul></div><b>Examples</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX6f6e2bc5b46b44fa8b0ea91e9'><li id='temp:C:VbXa8d3e4fbe4874ba1b676dd6b4' class='' value='1'><b>Prim's and Dijkstra's</b>: Both are greedy algorithms focusing on local optimality for MST and shortest paths, respectively.

<br/></li><li id='temp:C:VbX33ea049a29da401b8439c1eb5' class=''><b>Kruskal's Algorithm</b>: Another example, clearly demonstrating the greedy approach by selecting the smallest edge not forming a cycle.

<br/></li></ul></div><b>Characteristics</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc0cfae1df07544fd955567883'><li id='temp:C:VbX494f91fe6ba24d1393fb4dbd4' class='' value='1'><b>Simplicity</b>: Conceptually straightforward, focusing on the best current option.

<br/></li><li id='temp:C:VbX21d915354f304fce8efe5bd99' class=''><b>Efficiency</b>: Often provide polynomial time solutions.

<br/></li></ul></div><b>Limitations</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1f39106acb6d435984f72d66e'><li id='temp:C:VbX4e0eadd4a0a145898e8595c41' class='' value='1'><b>Not Always Optimal</b>: Local choices may not lead to the best global solution.

<br/></li><li id='temp:C:VbX7c78d25fd53b450d8b1c8f97a' class=''><b>Traveling Salesman Problem (TSP)</b>: Illustrates the failure of greedy strategies to guarantee optimal solutions.

<br/></li></ul></div><b>Greedy Strategy in TSP</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX344a8204741d47b6938ca2bdc'><li id='temp:C:VbX23d16d1293074c95a14855414' class='' value='1'><b>Approach</b>: Choose the nearest unvisited neighbor at each step.

<br/></li><li id='temp:C:VbX34cf8b14f4fb4c35ad165ad4f' class=''><b>Outcome</b>: Can result in suboptimal or even the worst possible route.

<br/></li></ul></div><b>Advantages Despite Limitations</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX0193d81f41be4b0abc7df3846'><li id='temp:C:VbXbe3b9bfb76c14132a0020e191' class='' value='1'><b>Foundation for Complex Strategies</b>: Greedy methods can be a starting point for more sophisticated algorithms.

<br/></li><li id='temp:C:VbX574acf6574d34a65aa404d4a8' class=''><b>Good Approximations</b>: Often yield solutions close to optimal in practice.

<br/></li><li id='temp:C:VbX2cbd92b6a87e4740923c04ba1' class=''><b>Efficiency</b>: Provide a balance between solution quality and computational cost.

<br/></li></ul></div><b>Conclusion</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX3dd35e3bf6224ba2bd84e3415'><li id='temp:C:VbXd90400fc782c4115b70660639' class='' value='1'><b>Greedy algorithms</b>, while not always yielding optimal solutions, offer a simple and efficient framework for approaching a variety of problems. They serve as a valuable tool in algorithm design, especially when combined with other strategies to improve approximation quality.

<br/></li></ul></div><h2 id='temp:C:VbXf46eacd1504343a2a95e5a554'>Krukal’s Algorithm</h2>

<h3 id='temp:C:VbX4dc4f0dcccb0407baa992456c'>Overview</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/wuPoIWBaFc57YiSAAKrRKw?a=RJimcYvEX5MeFj4vINZKfj2wRLgNtmaIt5aaLMNjUWwa' id='temp:C:VbX6483646e221d4c13a1859387f' width='800' height='379' alt="Screen Shot 2024-07-14 at 7.43.46 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/g5SKKUMccDIaG2BEACK8Tw?a=JGPeuTzrgXk7v23y6mvTKKZ8mbP4Ea4HvuzanWlfpQUa' id='temp:C:VbX87ffab51996f4d67831fedcdb' width='800' height='362' alt="Screen Shot 2024-07-14 at 7.45.04 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/6ifB3obd4xS0xZKw59nt9A?a=5WbTl7XUXCgJJctzoN5fReYVJBu2cjBjQdatcFoWxaQa' id='temp:C:VbX1a7baa20d2fa4844b7cb49caf' width='800' height='347' alt="Screen Shot 2024-07-14 at 7.45.24 PM.png"></img></div><h3 id='temp:C:VbX12c9a72857594ff3bde4feab2'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/OYHb3oMsbcNaUaCAs98PsA?a=7GFwaaa27xhWveUv17n5w216e5QJpJwUKBaPjq4QOZ0a' id='temp:C:VbX259812d2447e4c338f3421a83' width='800' height='296' alt="Screen Shot 2024-07-14 at 7.45.47 PM.png"></img></div><b>CSVizTool</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/s2X_tRbySgB1gIb6cYPV5Q?a=KTK9qnleaKpH7iWmj7UITV9YJNhDlwUmvXgMcQNO9rga' id='temp:C:VbX073b2f182b2443f6a7ae9d681' alt="image.png"></img></div><br/>

<h3 id='temp:C:VbX653be795fc744d6c9b629d4ee'>Example</h3>

Video: <br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXda57be9b188542e1902f3e056'><li id='temp:C:VbXdd7b03569de0425383dd5b7d1' class='' value='1'>Ex 1 <a href="https://gatech.instructure.com/courses/406950/pages/in-depth-example-of-kruskals-algorithm?module_item_id=4026350">https://gatech.instructure.com/courses/406950/pages/in-depth-example-of-kruskals-algorithm?module_item_id=4026350</a>

<br/></li><li id='temp:C:VbXa50dc2c409054dd78b1831a1a' class=''>Ex 2 <a href="https://gatech.instructure.com/courses/406950/pages/another-look-at-kruskals-algorithm?module_item_id=4026352">https://gatech.instructure.com/courses/406950/pages/another-look-at-kruskals-algorithm?module_item_id=4026352</a>

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/x3mwA1kIlfynHqLgaaIe1g?a=lTVFMRp0dc7aKlxYms09aOi8K2MNh6Cd8bgkco7BpZIa' id='temp:C:VbXcaa7247d50174cc88692b2205' width='800' height='373' alt="Screen Shot 2024-07-14 at 7.47.09 PM.png"></img></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/tmEIkXFwauLrr5sxkx5ykQ?a=QxxyYNY1WGMSCGLCn4XEflrKSagRY2XIseus4DjDRqsa' id='temp:C:VbX539d8cfa677245e9b1898c10b' width='800' height='378' alt="Screen Shot 2024-07-14 at 7.58.26 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbX2b867914ee1b4931b0bcfb7fc'><li id='temp:C:VbX436e657cca114ca8806f29ba4' class='' value='1'>Edges in orange are included in MST

<br/></li><li id='temp:C:VbX94509f2a7c1b47078fd29374e' class=''>Edges in black were in minimum priorirty queue, but never considered.

<br/></li></ul></div><h3 id='temp:C:VbXdf3642a4466945c7aef2309ec'><b>Algorithm Steps</b></h3>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX88dc944749884afd8562015ea'><li id='temp:C:VbX751d7d8484b54c9090e27b3e3' class='' value='1'>Add every edge of the graph into a priority queue

<br/></li><li id='temp:C:VbX9793777f0c6045ffb90d568c2' class=''>While the PQ != empty &amp;&amp; MST size is not reached, dequeue an edge from PQ.  If dequeued edge doesn’t form a cycle, add the edge to the MST

<br/></li></ul></div><b>Motivation</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX61f1a428aa434f6fb975a08b6'><li id='temp:C:VbXbe1daafa05104876b09e6034c' class='' value='1'><b>Cycle property of MSTs</b>: Cycle property states, “if we consider <i>any</i> cycle in the graph and look at the edge of max weight in the cycle, then that edge won’t be contained in <u><i>any</i></u><b> MST.</b>

<br/></li><li id='temp:C:VbX35e99baac0f8420db5a7821a8' class='parent'><b>How cycle property proves correctness: </b>Any edge that creates a cycle in the MST, based on cycle property, is excluded from the MST.

<br/></li><ul><li id='temp:C:VbXa578dbb193f54c2bb60719d92' class=''>Any dequeued edge before maximum weight edge, based on cycle property of MSTs, had lower weight.

<br/></li></ul></ul></div><b>Motivation for Disjoint Sets</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXf9e1cccc351e4a6ab23487b5c'><li id='temp:C:VbX3dc878e908a84ce2b52d57b84' class='' value='1'><b>Visited sets don’t work</b>: Visited sets, as used in algorithms like Depth-First Search (DFS), Breadth-First Search (BFS), Dijkstra's, and Prim's, are designed to track the nodes that have been explored from a<span style="color:#cc8b00" textcolor="#cc8b00"> single source point</span>, ensuring that the algorithm does not revisit nodes and potentially create cycles or redundant paths. These algorithms build their solution outward from this single source, expanding the frontier of visited nodes until the desired goal (e.g., spanning tree, shortest path) is achieved.

<br/></li><li id='temp:C:VbXa529f5a4b48f4fc8b54844656' class=''><b><span bgcolor="#252526" style="background-color:#252526">Kruskal’s use of multiple origin sources: </span></b><span bgcolor="#252526" style="background-color:#252526">Kruskal's algorithm does not build the MST from a single source. Instead, it considers all edges in the graph, sorted by weight, and adds them to the MST one by one, provided they do not create a cycle. This process does not inherently rely on a concept of "visited" nodes in the same way.</span>

<br/></li><li id='temp:C:VbX3e1ede2df7b84ef5a0fadfe9f' class=''><b>Kruskal’s use of disjoint sets: </b>Instead of using visited sets to prevent cycles, Kruskal's algorithm uses a Disjoint Set (Union-Find) data structure. This structure efficiently tracks which vertices are in which components of the growing forest. When considering an edge, if both vertices belong to the same set (component), adding that edge would create a cycle, so it is skipped.

<br/></li><li id='temp:C:VbXbd5df257497540729e83d1f95' class=''><b>Edge vs Vertice Focus: </b>Kruskal’s algo is more edge-centric while other algos are vertex-focused.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/-O2n3fcQqeoLdjC6_Ecuow?a=Ub89V2l6oDHhb82vZnF0riCrSX9JjOndA6pOqQlYoCka' id='temp:C:VbXe0687bede0c146f4b4d85cf51' alt="image.png"></img></div><p id='temp:C:VbX8155ae1643e4445aa8183d535' class='line align-center'>Example of where a visited set will fail (DF edge will create a cycle)</p>

<br/>

<h3 id='temp:C:VbX9c69e86226ae470e99d8f547c'>Disjoint Steps</h3>

<h4 id='temp:C:VbX296a13d81d2b448d9a5de7b92'>Disjoint Set (Union-Find) Data Structure</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7d1e74f724bf4ce384d6b6cc9'><li id='temp:C:VbXfba7cae7a1a347d1ba874f700' class='' value='1'><b>Purpose</b>: Addresses the MST cycle issue by managing a partition of a universe set (U), ensuring efficient updates as subsets merge.

<br/></li><li id='temp:C:VbX8e01663077f54f40ac9c7c9c8' class=''><b>Partition Definition</b>: A collection of disjoint subsets of (U), where no element appears in more than one subset.

<br/></li><li id='temp:C:VbX4780d8daaa094c0995771a881' class=''><b>Example</b>: Given (U = {1, 2, 3, 4}), a valid partition is {{1}, {2, 3}, {4}}, while {{1, 2}, {2, 3}} is invalid due to overlap.

<br/></li></ul></div><b>Kruskal's Algorithm Context</b>:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX615a24d078e94de5bdf3c9776'><li id='temp:C:VbX6634965a17f14543b89aff3d3' class='' value='1'><b>Universe Set (<i>V</i>)</b>: The set of vertices in the graph.

<br/></li><li id='temp:C:VbX712aa0a2cc5f42bd83ef58763' class='parent'><b>Initial Partition</b>: Each vertex is in its own subset, representing the state before any edges are added to the MST.

<br/></li><ul><li id='temp:C:VbX00d95677d8f84806bcb1efaa2' class=''><control data-remapped="true" id="temp:C:VbXb726519739624b3b9c01365f0">C={{v1​},{v2​}…{vn​}}</control>

<br/></li></ul><li id='temp:C:VbX9494d552858e4119b4cac228c' class=''><b>Edge Addition</b>: As edges are added, they connect vertices, effectively merging the subsets (clusters) those vertices belong to.

<br/></li><li id='temp:C:VbX87c46bcd5aef41a8b8a6cde14' class=''><b>Goal</b>: Efficiently manage these merges to ensure no cycles are formed in the MST, using the Disjoint Set structure to track connected components.

<br/></li></ul></div><h4 id='temp:C:VbX75dc8b52675b4cdd8d26edaf3'>Tree-based Solution</h4>

<b>Data Structure Requirements:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX50050af5fb304de3962399211'><li id='temp:C:VbX87cefb7c99cb4395b52bcc5e7' class='' value='1'>Check if 2 vertices are connected

<br/></li><li id='temp:C:VbX9784fde7436e43dbbfabeef14' class=''>Merge/union connected components together efficiently so that all vertices belong to the same component.

<br/></li></ul></div><b>Operations:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX2ad79c0c57f34d0b9521da9ae'><li id='temp:C:VbX75838db23d5b485abacd95ebc' class='parent' value='1'><code>find(v)</code>: Check a “representative vertex” for 2 vertices and check if they are the same.

<br/></li><ul><li id='temp:C:VbX7aa2b5ae11524dfa8337f3c7f' class=''>How: To find the representative of 𝑣, follow the outgoing edge path to each ancestor until the root is reached. The root is the component's representative, so return the root. To implement this procedure, we will need efficient access to where 𝑣 is located in the disjoint set forest. This is accomplished by using a HashMap from vertex objects in the graph to node objects in the disjoint set forest.

<br/></li></ul><li id='temp:C:VbX2a013281c9aa455b9112f62c5' class='parent'><code>union(u,v)</code>: Combine vertices with the same representative vertex

<br/></li><ul><li id='temp:C:VbX4d6a2173ea674603a34ec6352' class=''>How: To merge the sets that 𝑢 and 𝑣 belong to, first compute 𝑢𝑟𝑜𝑜𝑡←find(u) and 𝑣𝑟𝑜𝑜𝑡←find(v) to obtain their roots. Next, make either 𝑢𝑟𝑜𝑜𝑡 a child of 𝑣𝑟𝑜𝑜𝑡 or vice versa. This will ensure that the representative of the component is unique, and, as more and more clusters are unioned together, the number of children will continually increase.

<br/></li></ul></ul></div><b>How the operation works:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXafcb19bb7efd4afeab6e25f5f'><li id='temp:C:VbXfb742148036b4aaea939bc4de' class='' value='1'>Top left: Graph G

<br/></li><li id='temp:C:VbX933e993bdbde47eaad5e8aa51' class=''>Top right: Disjoint sets representing clusters in the graph

<br/></li><li id='temp:C:VbXedfb23a4964f42d194691f763' class=''>Top row: Illustrates adding of an edge between vertex C and A to the MST, where C and A aren’t in the same cluster.

<br/></li><li id='temp:C:VbX9a5f6a9736cd43f8bbf347ac2' class=''>Bottom row: Illustrates how clusters are merged.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/q9A5j4_KCIl8k79v-tJQdQ?a=lk8gsRRA7FOmzpLhI8YvVtjxdAxhfVmA9Gkz0K8cDD0a' id='temp:C:VbXd5e7f6d8cf56467789eae1bff' width='800' height='500' alt="image.png"></img></div><b>Efficiency</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXcd99f39ca02946e49f1eb41c8'><li id='temp:C:VbX0f142a62fa824d5ba11b19ee2' class='' value='1'>In the worst case, it is 𝑂(|𝑉|) for both find and union operations.

<br/></li><li id='temp:C:VbX9cc9feb2ed094113b58170c8a' class=''>Merging the trees once the roots have been found is 𝑂(1), but finding the roots can be up to 𝑂(|𝑉|)

<br/></li></ul></div><h4 id='temp:C:VbX33ed954641544010a544be22a'>Path Compression and Rank</h4>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXc178c1b2b7dd44cb8d6e73a03'><li id='temp:C:VbXe37a42f7e1cf43bb9fa44bc53' class='' value='1'><b>Goal</b>: Improve<span style="color:#cccccc" textcolor="#cccccc"> </span><code>find</code><span style="color:#cccccc" textcolor="#cccccc"> </span>operation efficiency in Disjoint Set.

<br/></li><li id='temp:C:VbX07e5edce92054443bdb7c3f61' class=''><b>Method</b>: During a<span style="color:#cccccc" textcolor="#cccccc"> </span><code>find</code><span style="color:#cccccc" textcolor="#cccccc"> </span>operation, make each node on the path from a vertex to the root directly point to the root. This reduces the path length to 1 for future operations.

<br/></li><li id='temp:C:VbX89b086e0461140ffbf9551d80' class=''><b>Benefits</b>: Significantly speeds up subsequent<span style="color:#cccccc" textcolor="#cccccc"> </span><code>find</code><span style="color:#cccccc" textcolor="#cccccc"> </span>operations by flattening the tree structure.

<br/></li><li id='temp:C:VbX6efcccee4fe6469cb809a7740' class=''><b>Non-Recursive Alternatives</b>: Path splitting and path halving (not covered in this course).

<br/></li></ul></div><b>Union by Rank</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX80cb2006fe214954a9f14e415'><li id='temp:C:VbXb490e6d0b7d747ef9ea8abe69' class='' value='1'><b>Goal</b>: Optimize the<span style="color:#cccccc" textcolor="#cccccc"> </span><code>union</code><span style="color:#cccccc" textcolor="#cccccc"> </span>operation to maintain a balanced tree structure.

<br/></li><li id='temp:C:VbXe2f296c4a2944b3e9330c0c3d' class=''><b>Method</b>: Use the height (or "rank") of trees to decide which root becomes the parent during a union. The root of the tree with the larger height becomes the parent of the root with the smaller height.

<br/></li><li id='temp:C:VbXfa4c1c5331b34f489f7aa0a15' class=''><b>Rank</b>: An efficient approximation of the tree's height, used because path compression makes accurate height maintenance cumbersome.

<br/></li><li id='temp:C:VbXda236c3c5d3141328dabddef3' class='parent'><b>Implementation Changes</b>:

<br/></li><ul><li id='temp:C:VbX1496d6deadd244079c5ab06f5' class=''><b>Initial Rank</b>: Set to 0 for all nodes.

<br/></li><li id='temp:C:VbXcaaaf85435ff4c8fb04765029' class=''><b>Union Operation</b>: Compare ranks to decide the parent-child relationship. If ranks are equal, choose either, but increment the rank of the new parent.

<br/></li></ul></ul></div><b>New <code>find</code> and <code>union</code></b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/3e_n3xQR8FJve7HGoPaScw?a=hKT79RuEgv9ivEqCMX0MSWC8q5nyrMfvZfFxucbvqsga' id='temp:C:VbXc3dc4d86dca24c529d618218d' width='800' height='163' alt="Screen Shot 2024-07-14 at 7.35.39 PM.png"></img></div><br/>

<b>Summary</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX2a0c863a5ee34b7287b2a6ade'><li id='temp:C:VbX26cfbf64d140414181ee0149c' class='' value='1'><b>Path Compression</b><span style="color:#cccccc" textcolor="#cccccc"> </span>and<span style="color:#cccccc" textcolor="#cccccc"> </span><b>Union by Rank</b><span style="color:#cccccc" textcolor="#cccccc"> </span>are key optimizations for Disjoint Sets, enhancing the performance of<span style="color:#cccccc" textcolor="#cccccc"> </span><code>find</code><span style="color:#cccccc" textcolor="#cccccc"> </span>and<span style="color:#cccccc" textcolor="#cccccc"> </span><code>union</code><span style="color:#cccccc" textcolor="#cccccc"> </span>operations.

<br/></li><li id='temp:C:VbX26c5fff11aca4567bb862abb6' class=''>These optimizations help maintain a more flat and balanced tree structure, ensuring efficient operation of the Disjoint Set, especially in applications like Kruskal's algorithm for finding the Minimum Spanning Tree (MST).

<br/></li></ul></div><h3 id='temp:C:VbX23fa816c27164a29968de527f'>Efficiency of Kruskal's Algorithm</h3>

<b><span style="color:#cccccc" textcolor="#cccccc">Disjoint Set Optimizations</span></b><span style="color:#cccccc" textcolor="#cccccc">: The </span><code><span style="color:#cccccc" textcolor="#cccccc">find</span></code><span style="color:#cccccc" textcolor="#cccccc"> and </span><code><span style="color:#cccccc" textcolor="#cccccc">union</span></code><span style="color:#cccccc" textcolor="#cccccc"> operations have an amortized cost of O(alpha |V|) where (alpha) is the inverse Ackermann function. This function grows extremely slowly, making these operations nearly constant time O(1) for all practical purposes.</span><br/>

<br/>

<b><span style="color:#cccccc" textcolor="#cccccc">Kruskal's Algorithm Efficiency</span></b><span style="color:#cccccc" textcolor="#cccccc">:</span><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX95e58e33c5334439aa91e5c44'><ul><li id='temp:C:VbX167c56f0d89b47a08a75ca872' class='' value='1'><b>Cycle Detection: O(1)</b>

<br/></li><li id='temp:C:VbX5cdcccc22b5744dab4b437a8b' class=''><b>Adding edges to priority queue: </b>Use BuildHeap algo which is O(|E|).  If we end up dequeueing all edges from PQ, then worst case time complexity is O(|E| log |E|).

<br/></li></ul></ul></div><b><span style="color:#cccccc" textcolor="#cccccc">Overall Complexity</span></b><span style="color:#cccccc" textcolor="#cccccc">: Since dequeuing and cycle detection dominate, the overall time complexity of Kruskal's algorithm is O(|E| log |E|).</span><br/>

<br/>

<b><span style="color:#cccccc" textcolor="#cccccc">Simplification for Simple Graphs</span></b><span style="color:#cccccc" textcolor="#cccccc">: If the graph is simple (no self-loops or parallel edges), then |E| = O(|V|)^2.  Simplifies to O(|E| log |V|)</span><br/>

<h2 id='temp:C:VbX4a8bf188285e4218ac4bc8c09'>Prim vs Kruskal’s Algorithm</h2>

<h3 id='temp:C:VbXf47a021ca8a94801aaeac7d89'>Time Complexity</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX37ff8437b8fe45e38be088b14'><li id='temp:C:VbXd961af3245014b3b82b10df63' class='parent' value='1'><b>Prim's Algorithm</b>:

<br/></li><ul><li id='temp:C:VbXa69e212dfee6419f831b0f1e9' class=''>General: (O(|E|\log|E|))

<br/></li><li id='temp:C:VbX3e96b2c1de6b4f789fef98e0d' class=''>With decreaseKey: (O((|V|+|E|)\log|V|))

<br/></li></ul><li id='temp:C:VbX2ea9f40ff9df41879247fd50b' class=''><b>Kruskal's Algorithm</b>: (O(|E|\log|E|))

<br/></li></ul></div><h3 id='temp:C:VbX97707f2de6a44abfacb95c3ea'>Dense Graphs</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXe5261b7175fb497590fef7f49'><li id='temp:C:VbX1ff1726ce31c4eaf876c9ed5b' class='' value='1'><b>Both Algorithms</b>: (O(|E|\log|E|)) for dense simple graphs.

<br/></li><li id='temp:C:VbX15ffb99017194dd2b00631d8f' class=''><b>Prim's Advantage</b>: Performs better in dense graphs, especially non-simple ones, due to fewer global edge dequeues and cycle checks.

<br/></li></ul></div><h3 id='temp:C:VbX1b1f046b2c0e47d3af1b1ca17'>Sparse Graphs</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX08386b761d504c09b3aaca037'><li id='temp:C:VbXd963c7021ec44886b16dc2068' class='' value='1'><b>Prim's</b>: Becomes (O(|V|\log|V|)) due to (|V|) term dominance.

<br/></li><li id='temp:C:VbX2f53389574914504a49efa1a3' class=''><b>Kruskal's</b>: Remains (O(|E|\log|E|)). Generally performs better for sparse graphs, but struggles with disconnected graphs by processing every edge.

<br/></li></ul></div><h3 id='temp:C:VbX871d1a6047744dbe963f6bb1e'>Special Cases</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd22feb2e9f8e4e3b81787cc26'><li id='temp:C:VbXff8982e7b4074958970ef3950' class='' value='1'><b>Pre-sorted Edges</b>: Kruskal's efficiency improves to (O(|E|)).

<br/></li><li id='temp:C:VbX906c1b8389a545d1857d56b09' class=''><b>Disconnected Graphs</b>: Kruskal's naturally handles Multiple Spanning Forests (MSF); Prim's requires adjustments.

<br/></li><li id='temp:C:VbXdd849a67a3c346b9aefdcc3f7' class=''><b>Memory Considerations</b>: Prim's may be preferred for its lower active memory requirement.

<br/></li></ul></div><h3 id='temp:C:VbX7555552172254983bcdf2100d'>Other Considerations</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX92f322515ffb44989f48b54b7'><li id='temp:C:VbX5098f253ae8d4a08827ce20f1' class='' value='1'><b>Borůvka's Algorithm (<a href="https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">wiki</a>)</b>: Not as well-known but significant for parallel computing.

<br/></li></ul></div><h3 id='temp:C:VbXe50e98e44aef47e7889cdc475'>Conclusion</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX16bc04cb69df45cc9ee3034e2'><li id='temp:C:VbX8d0a560e18e347f5b594c3885' class='' value='1'><b>Choice Depends on Graph Density and Structure</b>: Prim's is generally better for dense graphs, while Kruskal's is suited for sparse or when edges are pre-sorted.

<br/></li><li id='temp:C:VbXb354200c32c94179946b21c9e' class=''><b>Other Algorithms</b>: Exist and may be more suitable for specific scenarios, such as parallel computing.

<br/></li></ul></div><br/>

<h1 id='temp:C:VbXe1f02679539b4a7e94413ae6f'>M16 - Dynamic Programming</h1>

<b><span style="color:#2cab21" textcolor="#2cab21">Key Idea: Store the solutions to subproblems so that when they are needed for reuse, we do not recompute the subproblem</span></b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/bCfPFhwHCwoiWEdAZA2JEQ?a=9abQLRSebL1d9cRQ5Evh6Sb7basS9s68mqfvxF2TYgwa' id='temp:C:VbX98b284eaf72845b6a388d14ea' width='800' height='304' alt="Screen Shot 2024-07-19 at 10.16.23 PM.png"></img></div><b>Naive Fibonacci:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/O_nphu7sb2Hcyw36XI2iiw?a=fpJvFaXNCMkOeoadorjrOpoQ2KtMF1pQblmgj4KiWLka' id='temp:C:VbX86ae5f84ba1343008b2de45a2' width='800' height='355' alt="Screen Shot 2024-07-19 at 10.17.04 PM.png"></img></div><b>DP Fibonacci:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/biaC5m1GVSht5y-KWjP1qQ?a=VnUx5xbxD7OyeVqk7X9tqUEV8gxcvodsDaUUwYPHej8a' id='temp:C:VbX2911be07d5604770be95f56ab' width='800' height='358' alt="Screen Shot 2024-07-19 at 10.18.00 PM.png"></img></div><div class="" style="" data-section-style='5'><ul id='temp:C:VbXcdeded8167384bd4a15e98a56'><li id='temp:C:VbX55e31b7cec7a488f861ada513' class='' value='1'>typically, you find  the recursive solution, then apply DP to it.

<br/></li></ul></div><h2 id='temp:C:VbX95366eb896e249c7948835dc2'>Dynamic Programming: More Formally</h2>

<b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Dynamic Programming (DP) Overview:</span></span></b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX3b5d278730014cc8a7c0e1832'><li id='temp:C:VbX4169f74fbeff422cb20f40250' class='' value='1'>DP is a generalization of divide and conquer.

<br/></li><li id='temp:C:VbX57c4e38f58d94ad3a7357353d' class=''>Examples include the failure table construction for KMP and Dijkstra's algorithm.

<br/></li><li id='temp:C:VbXea0f425bbefb479e9c42929f9' class=''>DP is effective for problems with overlapping subproblems, unlike divide and conquer algorithms like merge sort.

<br/></li></ul></div><b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Fibonacci Example:</span></span></b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX8d242f80d38a48628c29279c5'><li id='temp:C:VbXd1c8bd73e7c94dca914c6e109' class='' value='1'>Computing the nth Fibonacci number recursively leads to exponential time complexity (O(2^n)) due to overlapping subproblems.

<br/></li><li id='temp:C:VbX76a736b0c4414afb9bdddaa4c' class=''>DP addresses this by storing solutions to subproblems (memoization), turning a recursive solution into a top-down DP approach.

<br/></li><li id='temp:C:VbXc33892c7b8834f1a84205b074' class=''>Top-down DP involves checking a stored array for the solution before computing; if not found, compute recursively, store, and return the solution.

<br/></li><li id='temp:C:VbX913aca1d3c0f4ce2b789fe18d' class=''>Bottom-up DP computes subproblems iteratively in order of complexity, starting with base cases, which is often more efficient than recursion.

<br/></li></ul></div><b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Top-Down vs. Bottom-Up DP:</span></span></b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX170343e8aa7142cb971e62f47'><li id='temp:C:VbX5e67ab14edef481cacc2a14c4' class='' value='1'>Top-down is intuitive and useful when only a subset of subproblems needs to be computed.

<br/></li><li id='temp:C:VbXc3269cd60f8b45a091b3e52ce' class=''>Bottom-up is preferred for its efficiency due to iteration over recursion.

<br/></li><li id='temp:C:VbXd74ea7af48314194b38f8adc9' class=''>The choice depends on the specific problem and the need to compute all or some subproblems.

<br/></li></ul></div><b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Nuances and Benefits of DP:</span></span></b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXdb33f3360d944783a4925074c'><li id='temp:C:VbXd72ba05fa67c40f3b1e2c50dc' class='' value='1'>DP solutions are easy to implement but identifying and combining subproblems is the challenge.

<br/></li><li id='temp:C:VbXdd5b00c168b14bc09f0d51c22' class=''>Optimal substructure is key: solving optimal subproblems leads to solving the larger problem optimally.

<br/></li><li id='temp:C:VbX75f787d91e8f4a75ab116cb75' class='parent'>DP increases space complexity but significantly reduces time complexity, which is often a worthwhile trade-off.

<br/></li><ul><li id='temp:C:VbXd66ae810c1094e298321c5831' class=''>Turns O(2^n) time and O(1) space algo to a O(n) time and O(n) space algo.

<br/></li><li id='temp:C:VbX1d3193dee9e34a7486a22ed40' class=''>Space is generally cheaper than time, so this is often not an issue.

<br/></li></ul></ul></div><b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Underlying Implicit DAG in DP:</span></span></b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX30afb8973fa24e078b4ee71cc'><li id='temp:C:VbX641de5202a324a65b84bad38f' class='' value='1'>Viewing subproblems as a directed acyclic graph (DAG) helps in understanding and applying DP.

<br/></li><li id='temp:C:VbXf3a3f912b8804dacba5c8d6b5' class=''>Edges represent dependencies (recursive calls), and nodes represent subproblems.

<br/></li><li id='temp:C:VbX65e7ba9771db42338fcc03929' class=''>A DAG ensures there's an order to compute subproblems, crucial for both top-down and bottom-up approaches.

<br/></li><li id='temp:C:VbX8f03d98b7f484b1a963575d08' class=''>Top-down DP performs a depth-first search on the DAG, storing solutions, while bottom-up pre-sorts subproblems for efficient computation.

<br/></li><li id='temp:C:VbXe479af86dd97405283c2cdb3c' class=''>This perspective aids in algorithm development, not implementation.

<br/></li></ul></div><b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">Key Takeaway:</span></span></b><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526"> Dynamic Programming is a powerful technique for solving problems with overlapping subproblems and optimal substructure, using either a top-down (with memoization) or bottom-up approach to efficiently compute solutions while managing increased space complexity.</span></span><br/>

<br/>

<h2 id='temp:C:VbXccb5ab3db91f4386bf7bc4508'>The P = NP Problem</h2>

<b>Introduction</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX4868ed8c50274154991de3304'><li id='temp:C:VbXe33048c8af4243d78fb699e44' class='' value='1'><b>Context</b>: The P = NP problem is a central question in computer science, particularly in complexity theory.

<br/></li><li id='temp:C:VbX49dc6c67e4a5463b9f955a148' class=''><b>Importance</b>: It distinguishes between "easy" problems (with polynomial time solutions) and "hard" problems (where no polynomial time solution is known).

<br/></li></ul></div><b>Definitions</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXcef1dcb829a6455480b2c34ba'><li id='temp:C:VbXf67fc259cdaf4521b7f5e17d4' class='parent' value='1'><b>Decision problem:</b> a problem that has a yes or no answer.

<br/></li><ul><li id='temp:C:VbX6a25d784f1f14d1da4d9dd6f2' class=''>E.g. "Is the number composite?" or "Is there an occurrence of the pattern in the text?" are decision problems.

<br/></li><li id='temp:C:VbX84f40eeb275b4abd87fe1a264' class=''>P = NP is defined in terms of decision problems.

<br/></li></ul><li id='temp:C:VbX57dd74017f0248f8863940534' class=''><b>P</b>: Class of decision problems solvable in polynomial time.

<br/></li><li id='temp:C:VbX081b576e600245f686192874a' class='parent'><b>NP (nondeterministic polynomial time)</b>: Class of decision problems where, if the answer is YES, it can be verified in polynomial time.

<br/></li><ul><li id='temp:C:VbX63d76f8696434dca986e5167f' class=''>E.g. For the question "Is the number 𝑛 composite," a proof could be the prime factorization of 𝑛, and the verifying algorithm would just be to multiply the factorization together and check if we got back 𝑛. 

<br/></li></ul><li id='temp:C:VbX0758cd211617489c9b727084f' class=''><b>NP-Complete</b>: Problems in NP for which every problem in NP reduces to them. Solving any NP-complete problem efficiently would solve all NP problems efficiently.

<br/></li><li id='temp:C:VbXaed397dac2974c2e8cd3063b7' class='parent'><b>NP-Hard</b>: Problems as hard as the NP-complete problems but not necessarily in NP (may not be decision problems).

<br/></li><ul><li id='temp:C:VbX860fcab497eb48d0bf2ee8c7d' class=''>If a problem𝐵 is in NP-complete, then for any problem𝐴 in NP, we have 𝐴≤𝐵. 

<br/></li><li id='temp:C:VbXe923df5ab949434ba7ce8206f' class=''><span style="color:#2cab21" textcolor="#2cab21">In plain-speak: These are problems where, if we obtained a polynomial-time algorithm for it, then we'd automatically have a polynomial-time algorithm for every problem in NP.</span>

<br/></li><li id='temp:C:VbXc6c39e8f7390437c99e0c374d' class=''>If a problem satisfies the requirements of NP-completeness, but is not in NP (for example not being a decision problem), then it is called an NP-hard problem.

<br/></li></ul></ul></div><b>Why do we care</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXbc078bc6941a43a09d179b0a5'><li id='temp:C:VbXc2065c9ad91441058319743ba' class='' value='1'>NP is interesting because every problem in NP can be solved in exponential time. Thus, there can only be so many solutions.

<br/></li><li id='temp:C:VbX617c6b9fcadf4aa783453532d' class='parent'>P = NP problem is asking: "Are these classes of problems the same?"

<br/></li><ul><li id='temp:C:VbXebba0b7abf3a44e3bec8745f7' class=''>we should see that𝑃 ⊆𝑁𝑃 because if the answer is YES, then the algorithm we used to solve the problem can be used to verify correctness.

<br/></li></ul><li id='temp:C:VbXdf9507e77ce144c4b0abd00ce' class='parent'>The more interesting question is 𝑃 ⊇𝑁𝑃. 

<br/></li><ul><li id='temp:C:VbXc125bca9d0e9473c87b2f84e6' class=''>This direction is asking: "If we have an efficient way to check if an answer is correct, does that mean there exists an efficient way to compute the answer?"

<br/></li></ul></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/H1EgW8EfbSYORNhEHgg-QA?a=SPbM0Gdh7MR4TVN57azo1zTQYskBEDw3A29UMcr9Lw4a' id='temp:C:VbXdb302bc3745a4a36b8a08710d' alt="image.png"></img></div><br/>

<b>Hard vs. Easy Problems</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX1cf4bdc8d7ef4c6382cd3f02b'><li id='temp:C:VbX1e502d3fbb434f679170bd1f5' class='' value='1'><b>Reductions</b>: Used to compare problem difficulties. A problem A reduces to B if solving B (assumed easy) helps in solving A.

<br/></li><li id='temp:C:VbXeba20a794c73497098f3e5e30' class=''><b>Efficiency</b>: An algorithm is considered efficient if it runs in polynomial time. However, not all polynomial time algorithms are practically efficient.

<br/></li></ul></div><b>The P = NP Question</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5e5d642e99294d98acdb86d9a'><li id='temp:C:VbXe7834b1acf294da8ba6322a41' class='' value='1'><b>Essence</b>: Asks whether every problem whose solution can be quickly verified (NP) can also be quickly solved (P).

<br/></li><li id='temp:C:VbXf413f0d778224beb960fa04ff' class=''><b>Implications</b>: A proof that P = NP could revolutionize computing, affecting fields like cryptography. Conversely, proving P ≠ NP would confirm the inherent difficulty of certain problems.

<br/></li></ul></div><b>Consequences of P = NP</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX189ee940237f49d8a21fd7a61'><li id='temp:C:VbXcf85a460bc85455b8a956581b' class='' value='1'><b>Cryptography</b>: Most modern cryptography relies on P ≠ NP. If P = NP, many encryption methods would become insecure.

<br/></li><li id='temp:C:VbX52b169f03f93428c9f7461d54' class=''><b>Computational Limits</b>: Proving P ≠ NP would clarify the limits of what can be computed efficiently.

<br/></li></ul></div><b>Perspectives</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX603bffe2296f4c13bb6e6eaf3'><li id='temp:C:VbX8751e6fd0e4945e386c0d8bb1' class='' value='1'><b>Majority View</b>: Most computer scientists believe P ≠ NP, suggesting a fundamental gap between problem-solving and solution verification.

<br/></li><li id='temp:C:VbX1470e01b4ba84fcf85afe8e07' class=''><b>Philosophical Reflection</b>: Scott Aaronson highlights the profound implications of P = NP for creativity, problem-solving, and human achievement.

<br/></li></ul></div><b>Conclusion</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX9cc26d22035c4c6eb6c0606e4'><li id='temp:C:VbX0136e9c2434f47608d485d551' class='' value='1'><span style="color:#cccccc" textcolor="#cccccc"><span bgcolor="#252526" style="background-color:#252526">The P = NP problem remains unsolved, with significant implications for computer science, cryptography, and our understanding of computational complexity.</span></span>

<br/></li></ul></div><h2 id='temp:C:VbX9951a4eac3d54c37a46e26225'>Exploratory Lab: Modeling Dynamic Programming</h2>

<h3 id='temp:C:VbX9f1de39edcbb4f30819ad92f1'>Problem 1: Largest Contiguous Sum</h3>

Suppose we have an array𝐴 of integers of length 𝑛. We'd like to compute the largest contiguous sum of the array, which is a block of numbers for which the sum is maximized. For example, suppose our array is <control data-remapped="true" id="temp:C:VbX142fb51940dd498c9b74ec433">[−1,52,−1,4​​,5,−3,1,3]</control>. Our largest contiguous sum is denoted having a value of 5. In the worst case, you can always choose the empty sum, which gives a value of 0. Come up with a dynamic programming algorithm to compute the value of the sum.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX4f999c4b30164d0580b95a513'><li id='temp:C:VbX18b8ad4d4c5c4e16b145fb16c' class='' value='1'>Hint 1: The straightforward solution we have in mind has a time and space complexity of 𝑂(𝑛). However, the space usage can easily be reduced to 𝑂(1).

<br/></li><li id='temp:C:VbX18405f57f2d446b0b83c16a79' class=''>Hint 2: Rather than trying to have the subproblems 𝑆[𝑖] represent the largest contiguous sum present in the subarray 𝐴[0,…,𝑖], instead make it a more local measure that more easily allows for combining subproblems.

<br/></li><li id='temp:C:VbX0eb89539d0a54888a03d0e353' class=''>Hint 3: For the subproblems, let 𝑆[𝑖] represent the largest contiguous sum ending at index 𝑖 in the subarray𝐴[0,…,𝑖].

<br/></li></ul></div><b>Solution:</b><br/>

<pre id='temp:C:VbX8c2a560cf8ed413da13c90af1'>Scratch Pad:<br>- Loop over sets of 2 to n sets where n is sum of entire array.<br>- Each smaller loop keeps the sum of 2 saved, which is then used by loop of 3 sets<br>- Keep an additional data structure storing the set of number with the greatest max <br>  so far.</pre>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/UwREMZrd9lZL4gJPMYzhUQ?a=xQYSEjMsBWCk4oCV2pu9teO6zU51iczHaJDt5uDaahQa' id='temp:C:VbX94bab5da35f84c398d4c745c2' alt="Screen Shot 2024-07-20 at 4.55.17 PM.png"></img></div><br/>

More explanation of solution:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX85855b79ee9b4692aad20e775'><li id='temp:C:VbX2f1f1592166e4c9f90c3d6d8e' class='' value='1'><b><span style="color:#cccccc" textcolor="#cccccc">Definition of (S[i])</span></b><span style="color:#cccccc" textcolor="#cccccc">: (S[i]) represents the largest contiguous sum ending at index (i) in the subarray (A[0..i]). This means (S[i]) is the maximum sum of a subarray that ends exactly at position (i).</span>

<br/></li><li id='temp:C:VbXbc1fb8972d924af383b2e3579' class='parent'><b><span style="color:#cccccc" textcolor="#cccccc">Recurrence Relation</span></b><span style="color:#cccccc" textcolor="#cccccc">: The key part of the solution is the recurrence relation: <control data-remapped="true" id="temp:C:VbX182c4b01be474174a136e28d2">S[i+1]=max{S[i]+A[i+1],A[i+1]}</control>. </span>

<br/></li><ul><li id='temp:C:VbX640e57cd0ddf4b09bfffdc07c' class='parent'><span style="color:#cccccc" textcolor="#cccccc">This relation states that the largest sum ending at (i) is either:</span>

<br/></li><ul><li id='temp:C:VbX4c56fa9b06cc4deb90e8f2a05' class=''><span style="color:#cccccc" textcolor="#cccccc">the element at (i) itself (if adding the previous largest sum ending at (i-1) would decrease the sum), or </span>

<br/></li><li id='temp:C:VbX9095864059b748a7bb337d47b' class=''><span style="color:#cccccc" textcolor="#cccccc">it's the sum of the element at (i) and the largest sum ending at (i-1).</span>

<br/></li></ul></ul><li id='temp:C:VbX6ff7584c2d864f21922e3cd2d' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Bottom-Up Computation</span></b><span style="color:#cccccc" textcolor="#cccccc">: The solution is computed in a linear, bottom-up fashion, starting from the beginning of the array and moving towards the end. This means you calculate (S[0]), then (S[1]), and so on, using the recurrence relation to build up the solution.</span>

<br/></li><li id='temp:C:VbX17412ca6c5cc443aa3f090385' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Returning the Result</span></b><span style="color:#cccccc" textcolor="#cccccc">: The final result, which is the largest contiguous sum in the entire array, is the maximum value in the S array. This is because the largest sum subarray could end at any index.</span>

<br/></li></ul></div><h3 id='temp:C:VbX867d8052b2f54fd9bb6194946'>Problem 2: Longest Increasing Subsequence</h3>

Suppose that we have an array𝐴 of length 𝑛 as input consisting of integers. A <b>subsequence</b> of the array is a sequence of some of the array entries in the order that they appear. For example, suppose that we have the array <control data-remapped="true" id="temp:C:VbX82624c96b33d437f89b8a78f5">[1,7,3,5,2,8,10,24,−1,−5,4]</control>. Then, <control data-remapped="true" id="temp:C:VbX54d2d2f8ad33404e80f7b91a2">3,2,−1,−5,4</control> is a valid subsequence since the numbers appear in the sequence in array order, <control data-remapped="true" id="temp:C:VbXdf284454c793430581244d8cc">1,7,10,8</control> is not a valid subsequence. An <b>increasing subsequence</b> is a subsequence where the numbers go in (strictly) increasing order. Come up with a dynamic programming algorithm to compute the length of the longest increasing subsequence of the array.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX9c6979b7974249f8956e00a7b'><li id='temp:C:VbX130aadebf4874892938749fe2' class='parent' value='1'>Hint 1: The solution we have in mind has a time complexity of 𝑂(𝑛^2) and a space complexity of 𝑂(𝑛).

<br/></li><ul><li id='temp:C:VbX219428ecd9924928970dc307c' class=''><b>Time Complexity (O(n^2))</b>: This suggests that the algorithm likely involves a nested loop where for each element in the array, you're performing some operation that involves the other elements as well, leading to a quadratic time complexity.

<br/></li><li id='temp:C:VbX6e2272d2785647278659bcac9' class=''><b>Space Complexity (O(n))</b>: This indicates that you need an auxiliary array (or similar data structure) of size proportional to the input array to store information useful for solving the problem, such as the length of the longest increasing subsequence up to each index.

<br/></li></ul><li id='temp:C:VbX5275a97a457343e39d7525cee' class='parent'>Hint 2: Unlike the largest contiguous sum problem, we have some more leeway in allowing for potentially costly operations to combine subproblems. Consider non-𝑂(1) ways to combine subproblems.

<br/></li><ul><li id='temp:C:VbXb9028bd74df74e6996f08a9b6' class=''>This hint suggests that unlike some dynamic programming problems where combining subproblems is straightforward and can be done in constant time, in this problem, combining subproblems might involve operations that take more than constant time, possibly involving iterations or comparisons that are dependent on the size of the subproblems.

<br/></li></ul><li id='temp:C:VbX692525fcab894706a69b0c9ff' class='parent'>Hint 3: For the subproblems, let 𝑆[𝑖] represent the longest increasing subsequence for the subarray 𝐴[0,…,𝑖]. How can we compute 𝑆[𝑖+1] in 𝑂(𝑛) time using subproblems 𝑆[𝑗] for𝑗≤𝑖?

<br/></li><ul><li id='temp:C:VbX7c229029251b418baf3e0a326' class=''><b>Defining (S[i])</b>: The hint defines (S[i]) as the length of the longest increasing subsequence for the subarray ending at index (i). This is a classic approach in dynamic programming where you solve smaller subproblems (in this case, finding the longest increasing subsequence up to each index) and use those solutions to build up to the final solution.

<br/></li><li id='temp:C:VbX02c01b39bbe74f188f1df7e3e' class=''><b>Computing (S[i]) in (O(i)) Time</b>: To compute (S[i]), you need to look at all previous (S[j]) values where (j &lt; i). For each (j), you check if you can extend the longest increasing subsequence ending at (j) by including the element at (i) (i.e., if the element at (i) is greater than the last element of the subsequence ending at (j)). This involves iterating over all previous indices to find the best (S[j]) to extend, which takes (O(i)) time for each (i).

<br/></li><li id='temp:C:VbXc101cd08db1d4174807a32ba6' class=''><b>Combining Subproblems</b>: The process of finding the maximum (S[j]) that can be extended by the current element involves comparing the current element with elements at previous indices and possibly updating (S[i]) based on those comparisons. This is the "potentially costly operation" mentioned in Hint 2, as it involves iterating over previous subproblems to find the optimal one to extend.

<br/></li></ul></ul></div><b>Solution:</b><br/>

<pre id='temp:C:VbXdc17debf30fc4254881bbcd95'>Scratch pad:<br>- Initial thought would be to approach the problem recursively, similar to merge sort.<br>- Loop i starts a A[0] and continues <br>- Loop j accumulates integers from i until array is non-increasing (n-1 &gt; n)<br>    - Longest series from A[n] is saved.<br>- Continue doing this, while checking if some longest running series is longer than<br>  the current max.  Replace if it is longer.</pre>

<br/>

<h3 id='temp:C:VbX19a23c55325e466799838749b'>Problem 3: Rod Cutting</h3>

We have a rod of length 𝑛 centimeters. We'd like to chop up this rod into smaller segments to sell at the market, but the market only accepts rods of lengths ℓ1,…,ℓ𝑘 as marketable items. All of these lengths are integral in nature. Rods of length <br>ℓ𝑖 sell for cost 𝑐𝑖. Come up with a dynamic programming algorithm to maximize our potential profit.<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX8c8bc4da6427480d85eae479e'><li id='temp:C:VbXd486d478ea604ce982c7fdddc' class='' value='1'>Hint 1: The solution we have in mind has a worst case time complexity of at most 𝑂(𝑘𝑛) and a space complexity of 𝑂(𝑛).

<br/></li><li id='temp:C:VbXbb76bbae70b1438c883c51c8e' class=''>Hint 2: Unlike the largest contiguous sum problem, we have some more leeway in allowing for potentially costly operations to combine subproblems. Consider non-𝑂(1) ways to combine subproblems. Additionally, a top-down approach may be easier to come up with here.

<br/></li><li id='temp:C:VbX4ff37593324d465b812f2b6b0' class=''>Hint 3: For the subproblems, let 𝑆[𝑖] represent the maximum profit we can make with a rod of length 𝑖.

<br/></li></ul></div><b>Solution:</b><br/>

<pre id='temp:C:VbX089d94fef51c4f489aaed69e7'></pre>

<h2 id='temp:C:VbX8376471657ab4e3898941ebfc'>Longest Common Subsequence</h2>

<h3 id='temp:C:VbX56c63e3b386c4f309f2e27898'>Definitions</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/d7-t6UyB3oPnPjVxF8hOgw?a=4f0Ow83aTbA2W4dCOQ9nu9Hka7dKb47y942VZ6uXU0ca' id='temp:C:VbX7c60efbca9d14cb29a3c86138' width='800' height='320' alt="Screen Shot 2024-07-20 at 5.17.47 PM.png"></img></div><h3 id='temp:C:VbX39f7f0d217e04e9e9ccf25e46'>How do we find the LCS?</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/VGJQArYbquv-NAQUBfPwnw?a=QvsQOiJBMNJW8acgu9mNQybAIz0TzhFEfYKpNwueOMIa' id='temp:C:VbXf0c4971d961f467f8dc875430' width='800' height='286' alt="Screen Shot 2024-07-20 at 5.19.07 PM.png"></img></div><h3 id='temp:C:VbX5ce370a936084a31b9be4571c'>Pseudocode</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/qQkWB0ABr7S3E5ArYqbFdw?a=isfFAXy3BBlTvtYUveFcyTKyjgrereIAaj1wNYlHHIsa' id='temp:C:VbXb8cbe6c0e8724b28a4d81d107' width='800' height='328' alt="Screen Shot 2024-07-20 at 5.22.32 PM.png"></img></div><b>CSVizTool:</b><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/m6cLvSpaQ25uOS6PUNpq7w?a=aglraIbf5o6aaQOjqVHQHmX4BoH2xDfTNtBxuFck4sQa' id='temp:C:VbXb2826ec14a98470db468ab873' width='800' height='514' alt="image.png"></img></div><b>Uses:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7a3b684209c54a5a8b8dfef84'><li id='temp:C:VbX38cca7cbd16b4b8ca71e67c85' class='' value='1'>Used in revision control (Git, Google docs)

<br/></li><li id='temp:C:VbX290279c37cf942d2a41b10069' class=''>Use to protect privacy of patients when patient d ata is used in research.

<br/></li><li id='temp:C:VbXb5a4e9b22075436ca4e408d6e' class=''>Widely used in DNA sequencing.

<br/></li></ul></div><h2 id='temp:C:VbX8d6f79b215ae443096bc1cda6'>Brief Example of LCS</h2>

Tracing Forward (orange arrow):<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX217188db3d0c4a61ac86fbdea'><li id='temp:C:VbXfc01511bbcee4d7daf0a57abd' class='' value='1'>Note the “empty” character at row 0 column 0.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/dc-NR7YgNiLkgedkscSG8Q?a=MaWRkYwZJ1Cu8iTmFHCeDA4OasTiJztjKKbgyPIqVhga' id='temp:C:VbX42b003498fdb42418a3050d4c' width='800' height='369' alt="Screen Shot 2024-07-20 at 7.27.14 PM.png"></img></div>Tracing Backward (blue arrow):  LCS is [A, D]<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/jDx25gsOP3nlLjsnnkrNtw?a=PSlFKuYfRDKeswa9xGZoTXjdzJHDObLsd8c9qEZEvA4a' id='temp:C:VbXb9f96d984c214e8ab4cf2ff89' width='800' height='366' alt="Screen Shot 2024-07-20 at 7.28.17 PM.png"></img></div><h2 id='temp:C:VbX595c48bc89ce4d7d9d3aed067'>More Complex Example</h2>

Case where there are multiple LCS<br/>

<br/>

Tracing Forward:<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb31fcee5fd124a348de1ce07e'><li id='temp:C:VbX589a2c5025d744dfbd311462f' class='' value='1'>Helps to visualize outline regions where values change.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/fyCyaD0U4SjnGon9RI3xKQ?a=OelO3o1MR7VI5sxhKqv9KIgFecQW1Q6ic5O3mDwyTToa' id='temp:C:VbX593423c46f334364b3e5bdef2' width='800' height='363' alt="Screen Shot 2024-07-20 at 7.31.20 PM.png"></img></div>Tracing Backward:  LCS is [T, O, A]<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/ZPEQ5epP86AJ2BFLY0SSPA?a=gE1nR7R7XYSuXweCI3sW8p2zQaiCialpvdew1ERafZYa' id='temp:C:VbX90fd847821df4356990fe89f0' width='800' height='359' alt="Screen Shot 2024-07-20 at 7.32.29 PM.png"></img></div><h2 id='temp:C:VbXae63b3789ae542c2af2ceafc8'>In-Depth Example of LCS</h2>

This example drives home the point that finding a longest common sequence is NOT unique.<br/>

<br/>

Multiple paths can be traced in this example:<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/WlHxhjMjRvhI75lwJI-1dQ?a=IIo1zQEAItLaeamoQsXatdlwXMwaavIlBs6mMh2dL5Ua' id='temp:C:VbXd62265f9df24421abd1ad2933' width='800' height='376' alt="Screen Shot 2024-07-20 at 7.34.12 PM.png"></img></div>Blocking value changes makes it easier to visualize where the LCS backtrace can go.<br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX6e134add18124cc482ddfbf7a'><li id='temp:C:VbXb8a05725fa6e4e908e8f48cf9' class='' value='1'>Any time a diagonal movement occurs, we add a character to the LCS.

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/HP-k5VjVsZIGVsLatRyFtQ?a=TF6WY2R2vyInvvHxhTZdvrn4LXp7rNw1YsGcLl9HkuIa' id='temp:C:VbX92ce52fbc58a4307bc6a63a8f' width='800' height='377' alt="Screen Shot 2024-07-20 at 7.34.47 PM.png"></img></div>One path, [C A C E]<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eil2ZejGsfiPSxyoojZdBg?a=8iwPOPGRRT6jN3Z69O6nPtiAry0DU9T7nSVtm4m8TQsa' id='temp:C:VbX2cb6a7ca750d439c99d140776' width='800' height='413' alt="Screen Shot 2024-07-20 at 7.36.47 PM.png"></img></div>Another path,  [C, A, D, E]<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/CGoN2UwRSl1yjBF94JWGCg?a=n2IvejhlGhKeb1aVRluEjLu3Pcj2qjSp5btaxva5Xp4a' id='temp:C:VbX837be70856334c9a9ff75c028' width='800' height='403' alt="Screen Shot 2024-07-20 at 7.37.11 PM.png"></img></div>Another path, [C A D E] - same LCS but different path.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/MJezEJN3NoCrYPVsNwUfkQ?a=PTo7sLsMAGYm5spov3j9yglrjcCp88CdtxWG27SqHvoa' id='temp:C:VbX3190be8dc2e34827ba23d15a0' width='800' height='387' alt="Screen Shot 2024-07-20 at 7.37.31 PM.png"></img></div>and more....<br/>

<br/>

<h2 id='temp:C:VbX6810f05c182f4a1385255ec3b'>Food-for-thought: Knapsack Problem</h2>

<b>What is Knapsack (0-1 Knapsack version)</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXd4ca92d1f8c34ac18ac739bbb'><li id='temp:C:VbX1d15ef241ab84967ac8a75fbe' class='' value='1'>We're a burglar shoplifting in a store (don't do this at home, kids!). 

<br/></li><li id='temp:C:VbXf20a0661271644ba9c08b0495' class=''>Want to make as much money as we can from our shoplifting endeavor, so we've brought along a large knapsack to store the items. 

<br/></li><li id='temp:C:VbX6b15ff44e75543a08cc9fda92' class=''>Our knapsack has a weight capacity of 𝑊, and the items have integral weights of 𝑤1,…,𝑤𝑛. 

<br/></li><li id='temp:C:VbXe545ddb15527456bae26e1f27' class=''>The item with weight 𝑤𝑖 can be sold for value 𝑣𝑖. 

<br/></li><li id='temp:C:VbX7aa7fcf494d04d87aba5ce920' class=''>There is only one of each item (hence the name 0-1 knapsack).

<br/></li><li id='temp:C:VbX04bcf7dc717a4201bcfc102ff' class=''><b>Q: What is the maximum value we can obtain from our burglary attempt?</b>

<br/></li></ul></div><b>Solution</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXb2ee667b576d48c494f245b48'><li id='temp:C:VbX2ac32fba11b3470ea4ad36baf' class='' value='1'>Tabulate a table 𝑆 of dimension (𝑊+1)×(𝑛+1), where 𝑆[𝑖][𝑗] represents the maximum value we can obtain with a knapsack of capacity 𝑖 and using the first 𝑖 items. This makes our base case: 𝑆[𝑖][0]=0 for all 0≤1≤𝑊.

<br/></li><li id='temp:C:VbX231eb558fd094998b16697c3f' class=''>For convenience of notation, if we try to access 𝑆[𝑖][𝑗] and 𝑖 becomes negative, then just have it return 𝑆[0][𝑗].

<br/></li><li id='temp:C:VbX85ce937127cd454c8b03428c7' class=''>For our optimal substructure, we have 𝑆[𝑖][𝑗]=max{𝑆[𝑖][𝑗−1],𝑆[𝑖−𝑤𝑗][𝑗−1]+𝑣𝑗} since we can either take item 𝑗 or not. This can be computed easily bottom-up (or top-down), and we can return 𝑆[𝑊,𝑛] as our answer. This solution has a time complexity of 𝑂(𝑛𝑊).

<br/></li></ul></div><div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/lvU9w71-owuIanLO7toFxw?a=rTrYgiSeHWPL8IrvAGmWDcRJeSE64JKGaXdpLS6vveUa' id='temp:C:VbXaea846396600442c80d7af656' alt="image.png"></img></div><b>How is this NP-Complete?</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5728e9dac75b4e96b91a931b0'><li id='temp:C:VbX9edfb9a9dfb34999804b953ff' class='' value='1'><b>Polynomial-Time Algorithm for NP-Complete Problems:  </b>The initial confusion arises from presenting a polynomial-time algorithm for a problem that is considered NP-complete. This seems to contradict the widely held belief that NP-complete problems do not have polynomial-time solutions unless P = NP.

<br/></li><li id='temp:C:VbXee9eb8c71db14345b22251a99' class=''><b>Distinction Based on Input Representation</b>:  The subtlety lies in how the input size is represented and understood. For many algorithms, including the one discussed, the complexity is polynomial in terms of the numerical value of the input (e.g., the weight capacity of the knapsack, (W)),<span style="color:#cc0300" textcolor="#cc0300"> not in the length of the input's representation (the number of digits or bits needed to represent (W)).</span>

<br/></li><li id='temp:C:VbXf3e18648c0f642b897c8e58ee' class=''><b>Exponential in the Size of Input Representation</b><span style="color:#cccccc" textcolor="#cccccc">: The algorithm's runtime is polynomial in the value of (W), but since (W) is represented in binary (or any base greater than 1), the actual size of (W) in terms of input bits is logarithmic ((log W)). Therefore, </span><span style="color:#ff3633" textcolor="#ff3633">the algorithm is exponential in the size of the input representation, not polynomial.</span>

<br/></li><li id='temp:C:VbX760fe9c487d244fdba077439d' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Weakly-NP-Complete Problems</span></b><span style="color:#cccccc" textcolor="#cccccc">: The knapsack problem is highlighted as an example of a weakly-NP-complete problem. This category includes problems for which polynomial-time algorithms exist but only when the problem is expressed in terms of the numerical value of the inputs, not the length of their representation. This is a crucial distinction because it means that while these problems can be solved in polynomial time for small numerical values,</span><span style="color:#ff3633" textcolor="#ff3633"> the solution times can grow exponentially with the size of the input representation, maintaining their NP-complete status under standard definitions.</span>

<br/></li><li id='temp:C:VbXf42b0379af21442caa2a386d5' class=''><b><span style="color:#cccccc" textcolor="#cccccc">Implications for P = NP</span></b><span style="color:#cccccc" textcolor="#cccccc">: The existence of polynomial-time algorithms for weakly-NP-complete problems does not imply that P = NP. This is because the </span><span style="color:#ff3633" textcolor="#ff3633">polynomial time is relative to the numerical value of the input, not the length of the input's representation</span><span style="color:#cccccc" textcolor="#cccccc">, which is the standard measure used in complexity theory.</span>

<br/></li></ul></div><br/>

<h2 id='temp:C:VbX5ef052f4e602494486d853879'>Bellman-Ford Algorithm</h2>

<h3 id='temp:C:VbX615a1ac18ffd421f8b726edcc'>Pseudocode</h3>

The underlying principle of the Bellman-Ford algorithm is simple: every shortest path between two vertices will use at most <control data-remapped="true" id="temp:C:VbX953b274075674ca7ba63c8a66">∣V∣−1</control> edges. With this in mind, here's the algorithm. <br/>

<pre id='temp:C:VbX89ec6734d03c41a3bb78db578'>def bellmanFord(source):<br>   Initialize dist, a mapping from vertices to distances.<br>    for each vertex v:<br>        distMap[v] = ∞<br>    dist[source] = 0<br><br>    for i = 1, 2, ..., |V| - 1:<br>        for each directed edge (u, v, w):<br>            if dist[v] &gt; dist[u] + w<br>                dist[v] = dist[u] + w<br><br>    return dist</pre>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX009613f2521549cab00f30e92'><li id='temp:C:VbX19d5bca229a54fd4a1af51282' class='parent' value='1'><span style="color:#2d3b45" textcolor="#2d3b45">The algorithm goes through all |𝐸| edges |𝑉|−1 times, updating the shortest path found up to that point in the algorithm.</span>

<br/></li><ul><li id='temp:C:VbXf27f11ab03a74b9993274d343' class=''><span style="color:#2d3b45" textcolor="#2d3b45">By doing so, on iteration 𝑖 the algorithm computes the shortest paths from the source to all other vertices using at most 𝑖 edges.</span>

<br/></li><li id='temp:C:VbX5546287a88c744d9b0f878563' class=''><span style="color:#2d3b45" textcolor="#2d3b45">Since every shortest path will use at most |𝑉|−1 edges, by the end, we will have computed all of the shortest paths</span>

<br/></li><li id='temp:C:VbX11a478065e644f85a2dcc8561' class=''><span style="color:#2d3b45" textcolor="#2d3b45">In terms of dynamic programming, this algorithm is formulated bottom-up, where the subproblems are defined by the destination and the max edge length of the path.</span>

<br/></li></ul><li id='temp:C:VbXc528d02ce7c5485b90f55ac99' class='parent'>Complexity: 

<br/></li><ul><li id='temp:C:VbX2ceb83b92c2f498db47687beb' class=''>Time: O(|V| * |E|) - nested loop

<br/></li><li id='temp:C:VbX734d50a291af4e18b15e267da' class=''>Space: O(|V|) - space needed to store the distance map

<br/></li></ul></ul></div><b>Negative Cycle Detection</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXd40424ca5c024bc38b431c289'><li id='temp:C:VbX2ab35d68fad843038d62615d8' class='' value='1'>How: Run the algorithm for |𝑉| iterations rather than |𝑉|−1 iterations. In final iteration, if distance map is updated due to finding a shorter path, that means a negative cycle is present.

<br/></li><li id='temp:C:VbXe30ec54af85a46e78762adcbe' class=''>Why does this work? We found a shorter path uses |V| edges, which is only possible if we repeated at least one edge in the path.

<br/></li></ul></div><b>Example</b><br/>

<br/>

Below is an example worked out on a small graph. As you can see, on iteration 𝑖, we just find the shortest path that uses 𝑖 edges and update it if it's shorter.<br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/5lzsHcD846ZqmvJiS-Xwow?a=Hxrw6hLLuLTRBKYxRHrvlXv7bfaBkE3I4M5kiiYpVO4a' id='temp:C:VbX076b4e3db7b34729b75c1c42d' width='800' height='527' alt="image.png"></img></div><h2 id='temp:C:VbXc998e1ffeca6462f932358856'>Food-for-thought: Application: Routing Protocols</h2>

Routing protocols like Dijkstra's algorithm and Bellman-Ford algorithm play a crucial role in small internal networks. Networks are modeled as weighted graphs with routers as vertices and physical links as edges. The weights can represent distance, cost, etc. The main goal of routing algorithms is to guide routers on forwarding packets based on routing information.<br/>

<br/>

<span style="color:#2d3b45" textcolor="#2d3b45"> </span><br/>

The goal of routing algorithms is to help routers determine what link to send packets along based on the packet's routing information (source, destination, etc.). Each router has only a local view of the network, seeing only what routers it is physically linked to. This is usually done by <b>forwarding tables</b>, which tell the router where to send the packet based on that information. The problem is: How can each router make informed decisions on where to forward packets with only a local view of the network? Below are two approaches.<br/>

<h3 id='temp:C:VbX73772ca29ea8406cbb829b37e'>Centralized Approach (Link-State)</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5daa26202efc482283d243b91'><li id='temp:C:VbXc7c69b5257ac496abb64638e0' class='' value='1'><b>Mechanism</b>: Each router maintains a global network view.

<br/></li><li id='temp:C:VbX070d20756dd3401fa3afef812' class=''><b>Algorithm</b>: Utilizes Dijkstra's algorithm for routing tables.

<br/></li><li id='temp:C:VbX0ff48f1cd9f7496cafa93b63b' class=''><b>Maintenance</b>: Global view updated through broadcasts or centrally at a computing center.

<br/></li><li id='temp:C:VbX97ee48de497140c1b62f43eeb' class=''><b>Challenges</b>: Keeping the network view updated.

<br/></li></ul></div><h3 id='temp:C:VbXff1db24c51d447298d4a2e850'>Decentralized Approach (Distance-Vector)</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbXccf4295562184279a5b8d1811'><li id='temp:C:VbX660022ac25b94670a1bc2baa2' class='' value='1'><b>Mechanism</b>: Routers operate without a global network view.

<br/></li><li id='temp:C:VbXa66d9f68728c4074ac737af80' class=''><b>Algorithm</b>: Employs Bellman-Ford algorithm for finding shortest paths.

<br/></li><li id='temp:C:VbXd98f38b2423c40518a22559f9' class=''><b>Operation</b>: Routers update routing tables iteratively based on shortest paths.

<br/></li><li id='temp:C:VbX80ad335861374cca88740161b' class=''><b>Challenges</b>: Ensuring path accuracy and timeliness without a global view.

<br/></li></ul></div>Both algorithms, despite their simplicity, are vital for efficient network routing, each fitting different network management strategies.<br/>

<h2 id='temp:C:VbXa48e2710ff7e409d89c2dee60'>Floyd-Warshall Algorithm</h2>

<b>What is it:</b><br/>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX510579412cdf45ff99d819bf0'><li id='temp:C:VbX5cce2e47d7954e27bac313a80' class='' value='1'>Solves the all-pairs shortest paths problem and works with negative edge weights

<br/></li></ul></div><h3 id='temp:C:VbXd82f4c6496994402a2fa10190'>Defining the Algorithm</h3>

<b>Key traits:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbXec183a5e254d465183ddc9e65'><li id='temp:C:VbXe41b8063b3f743dc9e9d2afb9' class='' value='1'>Works under the assumption that the graph is represented using an adjacency matrix

<br/></li><li id='temp:C:VbX62ffe4368684437ea20dba8c7' class='parent'>Underlying principle is simple: 

<br/></li><ul><li id='temp:C:VbX7a2dc145a4344020a25e60bd9' class=''>Any shortest path can be written as the sum of two shortest paths between some intermediate vertex. 

<br/></li><li id='temp:C:VbX078b217406ff42af9d8192b01' class=''>If not, then we could improve the shortest path by splitting that path along the intermediate vertex and using the shorter one.

<br/></li><li id='temp:C:VbXf1cdf230e19349aeaa47bb831' class=''>Even if the shortest path is a direct edge (𝑢,𝑣,𝑤), we can decompose this as the shortest path from 𝑢 to 𝑢 of length 0, then the shortest path from𝑢 to 𝑣 of length 𝑤.

<br/></li></ul></ul></div><b>How it works:</b><br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX93f23a03387249b39f57ba237'><li id='temp:C:VbXc08b52d08ab5476fa6be76ff7' class='' value='1'>Defines a distance matrix to store all shortest distances between pairs of vertices found so far, and initializes to adjacency matrix.

<br/></li><li id='temp:C:VbX497cb7f0b8734f64921b04507' class='parent'>Subproblems defined in terms of what vertices are allowed to be intermediate points.

<br/></li><ul><li id='temp:C:VbX443f2a17345048b7b749c8f7f' class=''>E.g. For convenience, let's label the vertices 0,1,…,|𝑉|−1 so that we don't need to worry about mapping vertices to integers. In the <i>first iteration</i>, we compute the shortest paths going through only vertex 0 as an intermediate point. In the <i>second iteration</i>, we compute the shortest paths going through only vertices {0,1} as intermediate points.

<br/></li><li id='temp:C:VbX10ac685d30814bc8885e19a00' class='parent'>The process is repeated for |V| iterations until in iteration |V|, we compute shortest paths going through any vertex as an intermediate point.

<br/></li><ul><li id='temp:C:VbXb124977606f6402ea25ede39e' class=''>Key point: Shortest paths are split along intermediate vertices, which is O(1) per pair per iteration cost.

<br/></li></ul></ul></ul></div><pre id='temp:C:VbXc02e76b20d884308ad02fd017'>def floydWarshall(adjMatrix):<br>    Initialize dist, a |V| x |V| matrix initialized to take the values of adjMatrix.<br><br>    for each vertex vj:<br>        for each vertex vi:<br>            for each vertex vk:<br>                if dist[vi][vk] &gt; dist[vi][vj] + dist[vj][vk]<br>                    dist[vi][vk] = dist[vi][vj] + dist[vj][vk]<br><br>    return dist</pre>

<h3 id='temp:C:VbXe3041709ed5f4b988ecb1df0c'>Complexity</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX65ec3bee1c9a460a8e1a90468'><li id='temp:C:VbX7dcb98eebfc14cb692b9d15d1' class='' value='1'>The algorithm iterates through all pairs of vertices |V| times.

<br/></li><li id='temp:C:VbXda2db936782a40c4b1b571d97' class=''>There are <control data-remapped="true" id="temp:C:VbXf86696c508ed476a8984d3f96">O(∣V∣2)</control> pairs (including degenerate pairs of the same vertex), so the time complexity is <control data-remapped="true" id="temp:C:VbX40b14f90781d4dfa915f11229">O(∣V∣3)</control>.

<br/></li><li id='temp:C:VbXbaef1431beb94a689302d746d' class=''>The space complexity is <control data-remapped="true" id="temp:C:VbX0896cba9b690435ab9db7f2ef">O(∣V∣2)</control>

<br/></li><li id='temp:C:VbXcc555b44009941f38fff2ec0b' class=''>This seems expensive, but consider that the problem has a lower bound of <control data-remapped="true" id="temp:C:VbX4e3f827e545e47958869004b5">Ω(∣V∣2)</control> to just write down the output.  This is much more efficient.

<br/></li><li id='temp:C:VbXda65c5bbd47c456d8ec53fb65' class=''>In terms of dynamic programming techniques, this algorithm is formulated bottom-up, where the subproblems are defined by the set of intermediate vertices allowed and the pair for the shortest path.

<br/></li></ul></div><h3 id='temp:C:VbXe7fca7065843457f87304ef84'>Negative Cycle Detection</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX448d9c60692f49379ef6469f1'><li id='temp:C:VbX9bc3706980a0407d82a5b9abd' class='' value='1'>If there is a negative cycle, then some negative distance path will be found for some vertex pair (𝑖,𝑖). These are the values along the diagonal of the distance matrix.

<br/></li><li id='temp:C:VbX72e137c099c74d1aad1d50fc6' class=''>If the diagonal values ever change/become negative, then that signals to the algorithm that there is a negative cycle

<br/></li><li id='temp:C:VbXf75c8ada9afb450eb02e59f74' class=''>If we let the algorithm keep running in perpetuity, then we'd find that all paths in the graph would become shorter and shorter forever.

<br/></li></ul></div><h3 id='temp:C:VbXa08ab623c01d44dcb0b5ba649'>Example</h3>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/eaWin7ZFtAN7bWZV9XxXnQ?a=qC5zebJTMAiRC70zzAxgn34JJYMzWLiHR0QRPahrAU4a' id='temp:C:VbX1ca77f070f6b42c29935c9f91' alt="Screen Shot 2024-07-20 at 8.18.11 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/njNu8yU18tcKIg_4sbnhZQ?a=ExQRXZx3LoefbIoymVBgRyOGQ9ZiWvJzeeLNiea2fRoa' id='temp:C:VbX7868c6212d484a228d2fb5353' alt="Screen Shot 2024-07-20 at 8.18.22 PM.png"></img></div><br/>

<div data-section-style='11' style='max-width:100%' class=''><img src='https://quip.com/blob/VbXAAAKnj4j/OH7DAds0BSYt6hiC9-Jrcg?a=PPBHOOs0Kv047Tg3k4r7QIy3JA6wgk6OQ33DAR1y4Ska' id='temp:C:VbXe37606e6f6934c9baefc9528f' alt="Screen Shot 2024-07-20 at 8.18.31 PM.png"></img></div><br/>

<h2 id='temp:C:VbXea02b8b7fcc94c00b8bc470f7'>Hamilton and Euler: "Food for Thought"</h2>

<h3 id='temp:C:VbXd97242e40e3246f5a52fc7a2b'>Hamilton Cycles and Euler Circuits</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX3218f921a4534b68bc7ac7062'><li id='temp:C:VbX18ab731dbfe54e62a5fce2145' class='' value='1'><b>Hamilton Cycle</b>: A cycle that passes through all vertices exactly once. Determining if a graph has a Hamilton cycle is an NP-complete problem.

<br/></li><li id='temp:C:VbX635a8a24a6a04797a4c806f44' class=''><b>Euler Circuit</b>: A circuit that passes through all edges exactly once. A graph has an Euler circuit if all vertices have an even degree and the graph is connected, which can be checked in polynomial time, making this problem in P.

<br/></li></ul></div><h3 id='temp:C:VbX68e4cef9606648839a62e0843'>Key Differences</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX7fe465fe134444c6850672302'><li id='temp:C:VbXc4ae0b33526a401683c2f9d9a' class='' value='1'><b>Complexity</b>: Euler circuit problems are solvable in polynomial time, while Hamilton cycle problems are NP-complete.

<br/></li><li id='temp:C:VbXadfe381bd5e246a18a8527f2c' class=''><b>Criteria for Existence</b>: Euler circuits have a simple, easily verifiable criterion (even degree and connectivity), unlike Hamilton cycles.

<br/></li></ul></div><h3 id='temp:C:VbXa0458a63f23f4270aa3f8859a'>Similar Formulations, Different Difficulties</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5beb74f604b34efab5d03b9d5'><li id='temp:C:VbX6de77f26c8ee4d8692244ddec' class='' value='1'>Despite their similar formulations, these problems differ significantly in difficulty. This highlights that similar-looking problems can have vastly different computational complexities.

<br/></li><li id='temp:C:VbX6257239d6df04bf0b92b0554e' class=''><b>Shortest vs. Longest Path</b>: Another example of similarly formulated problems with different difficulties. The shortest path problem is in P, while the longest path problem is NP-Hard.

<br/></li></ul></div><h2 id='temp:C:VbX4233de0b719a46dd9dbbf9dbb'>Module 15 Review</h2>

Key Idea: One useful property of dynamic programming is that when applicable, it can turn simple exponential time algorithms into polynomial time ones<br/>

<br/>

DP Algorithms we covered:<br/>

<div class="" data-section-style='6' style=""><ul id='temp:C:VbX1731c1f92f64486284c5e939d'><li id='temp:C:VbX88cb215ce802494a99323c825' class='' value='1'>Dijkstra

<br/></li><li id='temp:C:VbXc8335a2937164df78e6ab96a4' class=''>KMP

<br/></li><li id='temp:C:VbX94f59aa699714a4c90ac06730' class=''>LCS

<br/></li><li id='temp:C:VbX06c4068407da47b5a589b5653' class=''>Bellman-Ford

<br/></li><li id='temp:C:VbXd6be0b33d60848bd8af2102b9' class=''>Floy-Warshall

<br/></li></ul></div><h3 id='temp:C:VbX449225fa2e494467873a70b2c'>Big O - Complexity</h3>

<div class="" style="" data-section-style='5'><ul id='temp:C:VbX5a7c7dfe024b43968f1ba9763'><li id='temp:C:VbX1d93dcbc87c0468e950062f6f' class='' value='1'>Given strings of length (m) and (n), the LCS algorithm has a time complexity of (O(mn)) and a space complexity of (O(mn)).

<br/></li><li id='temp:C:VbXcf9cbce3c7fc414b95f8a647b' class=''>Given a graph (G=(V,E)), the Bellman-Ford algorithm solves the single source shortest path problem with a time complexity of (O(|V| * |E|)) and a space complexity of (O(|V|)).

<br/></li><li id='temp:C:VbX1f0b74912a9743a8b93cb1d9b' class=''>Given a graph (G=(V,E)), the Floyd-Warshall algorithm solves the all-pairs shortest path problem with a time complexity of (O(|V|^3)) and a space complexity of (O(|V|^2)).

<br/></li></ul></div></body></html>
